<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="软件测试作业相关"><meta name="keywords" content="软件开发,软件测试"><meta name="author" content="GiyaYon"><meta name="copyright" content="GiyaYon"><title>软件测试作业相关 | GiyaYon's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="GiyaYon's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一、软件测试相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.软件测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.软件质量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-number">1.3.</span> <span class="toc-text">3.软件缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">3.软件测试基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9B%AE%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">4.软件测试目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">5.软件测试对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E6%B5%8B%E8%AF%95%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.7.</span> <span class="toc-text">6.如何降低测试代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.8.</span> <span class="toc-text">7.测试用例设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%90%84%E9%98%B6%E6%AE%B5%E6%96%87%E6%A1%A3"><span class="toc-number">1.9.</span> <span class="toc-text">8.软件测试各阶段文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B5%8B%E8%AF%95%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%8F%8A%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.</span> <span class="toc-text">9.测试缺陷报告及缺陷管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B5%8B%E8%AF%95%E7%B4%A0%E5%85%BB"><span class="toc-number">1.11.</span> <span class="toc-text">10.测试素养</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82"><span class="toc-number">1.12.</span> <span class="toc-text">12.测试报告的内容。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二、测试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">2.1.</span> <span class="toc-text">1.白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">逻辑覆盖法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">基本路径测试法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">等价类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">边界值分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">组合测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">场景法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">因果图测试法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E8%A1%A8%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">决策表法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">三、测试策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.</span> <span class="toc-text">1.静态测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B5%B0%E6%9F%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">代码走查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E6%B5%8B%E8%AF%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.动态测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">四、测试级别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">4.1.</span> <span class="toc-text">1.单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">4.2.</span> <span class="toc-text">2.集成测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.</span> <span class="toc-text">3.系统测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">五、测试类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95"><span class="toc-number">5.1.</span> <span class="toc-text">1.接口测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">2.性能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">5.3.</span> <span class="toc-text">3.渗透测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.4.</span> <span class="toc-text">4.回归测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%CE%B1%E6%B5%8B%E8%AF%95"><span class="toc-number">5.5.</span> <span class="toc-text">5.α测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-s%E6%B5%8B%E8%AF%95"><span class="toc-number">5.6.</span> <span class="toc-text">6.ß测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">六、测试手段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%8B%E5%B7%A5%E6%B5%8B%E8%AF%95"><span class="toc-number">6.1.</span> <span class="toc-text">1.手工测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">6.2.</span> <span class="toc-text">2.自动化测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">五、应用题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95"><span class="toc-number">7.1.</span> <span class="toc-text">1.路径测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95"><span class="toc-number">7.2.</span> <span class="toc-text">2.逻辑覆盖测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">7.3.</span> <span class="toc-text">3.黑盒测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">7.4.</span> <span class="toc-text">4.系统测试</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/header.jpg"></div><div class="author-info__name text-center">GiyaYon</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/GiyaYon">查看项目</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">GiyaYon's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/github">GitHub</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">软件测试作业相关</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1>一、软件测试相关概念</h1>
<p>不同角度的测试分类</p>
<p>（1） 从测试阶段或对象的角度， 可以分为<code>单元测试</code>、<code>集成测试</code>、 <code>系统测试</code>和<code>验收测试</code>；</p>
<p>（2） 从测试技术的角度， 可以分为<code>黑盒测试</code>、 <code>白盒测试</code>和<code>灰盒测试</code>；</p>
<p>（3） 从测试目标的角度， 可以分为更多的测试类型，包括<code>回归测试</code>、 <code>功能测试</code>、 <code>性能测试</code>、 <code>Alpha测试</code>、<code>Beta测试</code>、 <code>压力测试</code>、 <code>负载测试</code>、 <code>安全性测试</code>、 <code>配置测试</code>、 <code>安装测试</code>、<code> 可用性测试</code>、 <code>可恢复性测试</code>等。</p>
<p>（4） 从测试执行方式的角度， 可以分为<code>手动测试</code>、 <code>自动化测试</code>和<code>半自动化测试</code>。</p>
<h2 id="1-软件测试">1.<strong>软件测试</strong></h2>
<p>​	软件测试是指对软件系统进行验证和验证的过程，以确定其是否满足指定的要求、预期的功能和性能。它涉及执行软件应用程序或系统的各个部分的检查和评估，以发现潜在的错误、缺陷和问题。</p>
<h2 id="2-软件质量">2.<strong>软件质量</strong></h2>
<p>​	软件质量是指软件在其整个生命周期内满足用户需求和预期的程度。它是衡量软件产品的可靠性、可用性、性能、安全性和符合性的指标。</p>
<blockquote>
<p>软件质量是一个多维度的概念，涵盖了以下几个方面：</p>
<ol>
<li>功能性：软件是否按照用户需求和规格说明书的要求提供所需的功能。</li>
<li>可靠性：软件在特定环境下的稳定性和可靠性，即软件在长时间运行和处理异常情况时的表现。</li>
<li>易用性：软件是否易于使用，用户界面是否友好，用户能否轻松学习和操作软件。</li>
<li>性能：软件在给定条件下的执行速度、响应时间、吞吐量和资源利用率等方面的表现。</li>
<li>可维护性：软件是否易于维护和修改，包括代码的可读性、模块化、可扩展性和文档的完整性。</li>
<li>安全性：软件的抵御潜在威胁和保护数据的能力，包括防止未经授权访问、数据保密性和完整性等方面。</li>
<li>兼容性：软件在不同操作系统、平台和设备上的兼容性，能否正常运行和与其他系统进行集成。</li>
<li>可测试性：软件是否易于进行测试，包括测试用例的设计、自动化测试和错误跟踪等方面。</li>
</ol>
<p>软件质量的提高需要全面的软件测试、代码审查、质量控制和质量保证等措施。同时，还需要遵循良好的软件工程实践和标准，如软件需求分析、设计、编码和测试等阶段的规范和流程。</p>
</blockquote>
<h2 id="3-软件缺陷">3.<strong>软件缺陷</strong></h2>
<p>​	软件缺陷指的是在软件中存在的错误、问题或不符合预期的行为。它们可能会导致软件无法正常工作、功能不完整、性能下降或安全漏洞等。软件缺陷是软件开发过程中常见的问题，需要进行缺陷管理和修复。</p>
<p><strong>软件的缺陷等级：</strong></p>
<ul>
<li><strong>可重现性</strong></li>
<li><strong>严重性</strong></li>
<li><strong>优先级</strong></li>
</ul>
<blockquote>
<p>以下是一些常见的软件缺陷类型：</p>
<ol>
<li>逻辑错误：软件中的代码或算法逻辑错误导致程序无法按照预期工作，例如计算错误、条件判断错误等。</li>
<li>功能缺陷：软件缺少某些功能或功能无法按照预期工作，例如某个功能模块无法启动、按钮点击无效等。</li>
<li>用户界面问题：软件的用户界面设计存在问题，导致用户体验不佳或操作不方便，例如布局错乱、字体颜色不明显等。</li>
<li>性能问题：软件在处理大量数据或复杂操作时出现性能问题，例如响应时间过长、内存占用过高等。</li>
<li>安全漏洞：软件存在安全弱点或漏洞，可能导致未经授权的访问、数据泄露或恶意攻击，例如密码明文存储、SQL注入等。</li>
<li>兼容性问题：软件在不同操作系统、浏览器或设备上无法正常工作，例如界面错位、功能不支持等。</li>
<li>数据处理问题：软件在处理数据时出现错误或异常情况，导致数据丢失、损坏或不一致，例如数据丢失、数据格式错误等。</li>
<li>文档和说明问题：软件的文档、帮助文件或用户手册存在错误、遗漏或不清晰，影响用户的理解和使用。</li>
</ol>
<p>及时发现和修复软件缺陷对于确保软件质量至关重要。软件开发团队通常会使用缺陷跟踪系统来记录、分析和修复缺陷。通过软件测试、代码审查和质量控制等措施，可以减少软件缺陷的数量和影响，并提高软件的可靠性和稳定性。</p>
</blockquote>
<h2 id="3-软件测试基本流程">3.软件测试基本流程</h2>
<p>​	软件测试是软件开发过程的一个重要环节，是在软件投入运行之前，对软件需求分析、实际规格说明书和编码实现的最终审定，贯穿于软件定义和开发的整个过程之中，它们是应相辅相成和相互依赖的。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620232049912.png" alt="image-20230620232049912"></p>
<p>软件测试的流程通常包括以下几个阶段：</p>
<ol>
<li>
<p><strong>需求分析和测试计划</strong>：在这个阶段，测试团队与相关利益相关者一起分析软件需求，并制定测试计划。测试计划确定测试的范围、目标、资源和时间安排。</p>
</li>
<li>
<p><strong>测试设计</strong>：在这个阶段，测试团队根据需求和测试计划设计测试用例。测试用例描述了对软件功能、性能和其他方面的预期行为和期望结果。</p>
</li>
<li>
<p><strong>测试环境设置</strong>：测试团队设置测试环境，包括硬件、操作系统、网络设置和其他必要的软件和工具。测试环境应与实际生产环境尽可能相似。</p>
</li>
<li>
<p><strong>测试执行</strong>：在这个阶段，测试团队根据设计的测试用例执行测试。他们运行软件，并记录测试结果和发现的问题。</p>
</li>
<li>
<p><strong>缺陷管理和修复</strong>：测试团队将测试期间发现的问题记录为缺陷，并将其报告给开发团队。开发团队修复这些缺陷，并将修复后的版本交付给测试团队。</p>
</li>
<li>
<p><strong>回归测试</strong>：在缺陷修复后，进行回归测试以确保修复的问题不会引入新的问题。回归测试通常包括重新执行之前的测试用例和验证修复是否有效。</p>
</li>
<li>
<p><strong>测试报告和评估</strong>：测试团队生成测试报告，总结测试的结果、问题和发现的缺陷。他们还评估软件是否符合预期的质量标准和需求。</p>
</li>
<li>
<p><strong>测试完成和交付</strong>：在完成测试并确保软件符合质量标准后，测试团队将测试结果和相关文档交付给利益相关者，以便他们做出最终的决策和评估。</p>
</li>
</ol>
<p>需要注意的是，具体的软件测试流程可能因组织、项目和方法的不同而有所差异。灵活性和适应性是软件测试流程的重要特征，以确保根据具体情况进行调整和优化。</p>
<h2 id="4-软件测试目的">4.软件测试目的</h2>
<p>​	软件测试的目的，就是以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正各种错误和缺陷提高软件质量，避免软件发布后由于潜在的软件缺陷和错误造成的隐患所带来的商业风险。</p>
<h2 id="5-软件测试对象">5.软件测试对象</h2>
<p>​	软件测试的对象是<strong>软件系统或应用程序</strong>。它可以是任何类型的软件，包括桌面应用程序、移动应用程序、Web应用程序、嵌入式系统、服务器端应用程序等。</p>
<h2 id="6-如何降低测试代价">6.如何降低测试代价</h2>
<p>降低测试成本是软件测试中的一个重要目标。以下是一些常见的方法和策略，可以帮助降低测试成本：</p>
<ol>
<li>
<p>自动化测试：利用自动化测试工具和框架，可以减少人工测试的工作量，提高测试效率，并且可以重复执行测试用例，节省时间和资源。</p>
</li>
<li>
<p>测试策略和计划：制定明确的测试策略和计划，根据需求和风险评估确定测试的重点和范围，避免进行不必要的测试工作。</p>
</li>
<li>
<p>测试优先级：根据软件功能的重要性和影响程度，对测试用例进行优先级排序，首先测试关键功能和核心业务流程，降低次要功能的测试成本。</p>
</li>
<li>
<p>随机抽样：对于大规模的测试数据集或大规模的测试用例集，可以使用随机抽样的方法，选择一部分代表性的测试数据或测试用例进行测试，以减少测试工作量。</p>
</li>
<li>
<p>集成测试：及早进行集成测试，将不同模块或组件进行集成测试，早期发现和解决问题，避免问题在后续阶段扩大和影响其他模块。</p>
</li>
<li>
<p>环境管理：合理管理测试环境，确保测试环境的稳定性和一致性，避免由于环境问题导致的测试延迟和成本增加。</p>
</li>
<li>
<p>风险驱动的测试：根据风险评估的结果，优先测试高风险的功能和模块，减少低风险功能的测试工作量。</p>
</li>
<li>
<p>测试重用：利用测试工件的重用，包括测试用例、测试数据、测试工具等，避免重复开发和测试，提高测试效率。</p>
</li>
<li>
<p>合作与协作：测试团队与开发团队、产品团队等密切合作，及早进行需求讨论、设计评审等，减少后期修改和调整的成本。</p>
</li>
<li>
<p>持续集成与持续交付：采用持续集成和持续交付的开发模式，频繁进行集成和部署，及时发现和解决问题，降低问题的积累和修复成本。</p>
</li>
</ol>
<p>这些方法和策略并非适用于所有情况，选择合适的方法需要根据具体的项目和需求进行评估和决策。在实际应用中，还需要综合考虑项目的时间、资源、风险和质量目标等因素，以达到在有限成本下提高测试效率和质量的目标。</p>
<h2 id="7-测试用例设计">7.测试用例设计</h2>
<p><strong>什么是测试用例？</strong></p>
<ul>
<li>测试用例就是为特定目标而开发的一组测试输入、执行条件和预期结果，其目标可以是测试某个程序路径或核实是否满足某个特定的需求。</li>
</ul>
<p><strong>为什么需要测试用例？</strong></p>
<ul>
<li>设计测试用例是为了更有效、更快地发现软件缺陷</li>
<li>测试用例具有很高的有效性和可重复性，依据测试用例进行测试可以节约测试时间，提升测试效率</li>
<li>测试用例具有良好的组织性和可跟踪性，有利于测试的管理</li>
</ul>
<p><strong>设计原则：</strong></p>
<ol>
<li>测试用例的代表性：能够代表并覆盖各种合理的和不合理的、合法的和非法的、边界的和越界的以及极限的输入数据、操作和环境设置等。</li>
<li>测试结果的可判定性：即测试执行结果的正确性是可判定的，每一个测试用例都应有相应的期望结果。</li>
<li>测试结果的可再现性：即对同样的测试用例，系统的执行结果应当是相同的。</li>
</ol>
<p><strong>作用：</strong></p>
<ul>
<li>–测试用例构成了设计和制定测试过程的基础。测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件或经由产品的事件流，因而，随着测试用例数量的增加，对软件产品质量和测试流程也就越有信心。</li>
<li>–测试工作量与测试用例的数量成比例。测试设计和开发的类型以及所需的资源主要都受控于测试用例。</li>
</ul>
<p><strong>元素</strong>：</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620232528369.png" alt="image-20230620232528369" style="zoom: 80%;" />
<h2 id="8-软件测试各阶段文档">8.软件测试各阶段文档</h2>
<p>在软件测试的各个阶段，通常会涉及以下一些文档和文件：</p>
<ol>
<li><strong>测试计划</strong>：测试计划是测试活动的总体计划和指导文件，其中包括测试目标、测试范围、测试策略、测试资源、测试进度等信息。</li>
<li><strong>测试用例</strong>：测试用例是描述测试场景、输入数据、操作步骤和期望结果的文档，用于指导测试人员执行具体的测试工作。</li>
<li><strong>测试设计规格说明书</strong>：测试设计规格说明书是对测试用例进行组织和说明的文档，它可以按功能模块、测试类型或其他逻辑方式组织测试用例。</li>
<li><strong>缺陷报告</strong>：缺陷报告是记录测试过程中发现的缺陷或错误的文档，包括缺陷的详细描述、重现步骤、优先级和状态等信息。</li>
<li><strong>测试执行日志</strong>：测试执行日志是记录测试人员执行测试用例的过程和结果的文档，包括测试开始时间、结束时间、执行结果、发现的问题等信息。</li>
<li><strong>测试总结报告</strong>：测试总结报告是对整个测试活动进行总结和评估的文档，包括测试结果、问题统计、测试覆盖率、测试效率等信息。</li>
<li><strong>测试环境配置文档</strong>：测试环境配置文档描述了测试所需的硬件、软件和网络环境的配置要求和步骤，确保测试环境的正确设置和准备。</li>
<li><strong>验收测试文档</strong>：验收测试文档是在软件开发完成后进行的最终测试，包括验收测试计划、验收测试用例、验收测试报告等。</li>
</ol>
<h2 id="9-测试缺陷报告及缺陷管理">9.测试缺陷报告及缺陷管理</h2>
<p>​	<strong>测试缺陷报告是软件测试过程中记录和跟踪缺陷或错误的文档。它包含了发现的缺陷的详细描述、重现步骤、优先级、状态以及其他相关信息。缺陷报告的目的是向开发团队提供准确的缺陷信息，以便他们能够定位、修复和验证缺陷。</strong></p>
<p>以下是一般情况下缺陷报告中包含的信息：</p>
<ol>
<li>缺陷概述：对缺陷的简要描述，包括标题、缺陷编号等。</li>
<li>缺陷描述：详细描述缺陷的现象、问题和影响。</li>
<li>重现步骤：描述如何重现缺陷，包括操作步骤、输入数据、预期结果等。</li>
<li>缺陷分类：根据缺陷的类型和严重程度进行分类，如功能性缺陷、性能缺陷、界面缺陷等。</li>
<li>优先级：根据缺陷的重要程度和紧迫程度进行评估和分类，如高、中、低等。</li>
<li>状态：记录缺陷的当前状态，如新建、已分配、待修复、已修复、已验证等。</li>
<li>影响范围：描述缺陷对系统功能、用户体验和业务流程的影响范围。</li>
<li>附件：如截图、日志文件、测试数据等，以支持缺陷的重现和分析。</li>
<li>提交人：记录报告缺陷的测试人员的信息。</li>
<li>分配给：记录缺陷被分配给的开发人员或团队的信息。</li>
</ol>
<p>**缺陷管理是指在整个软件开发和测试过程中对缺陷进行跟踪、分析和管理的活动。**缺陷管理包括以下步骤：</p>
<ol>
<li>缺陷记录：测试人员通过缺陷报告工具或系统将发现的缺陷记录在缺陷数据库或缺陷跟踪工具中。</li>
<li>缺陷分类和优先级：根据缺陷的类型、严重程度和影响范围对缺陷进行分类和优先级评估。</li>
<li>缺陷分析：开发人员对缺陷进行分析，确定产生原因和修复方法，并进行相应的处理和解决。</li>
<li>缺陷分配：将缺陷分配给相应的开发人员或团队进行修复。</li>
<li>缺陷修复和验证：开发人员根据缺陷报告进行修复，并将修复后的代码提交给测试团队进行验证。</li>
<li>缺陷关闭：当缺陷被修复并经过验证</li>
</ol>
<p>后，将其标记为已关闭，并在缺陷报告中记录相应的信息。</p>
<ol start="7">
<li>缺陷跟踪和报告：定期生成缺陷报告，包括缺陷的状态、趋势、修复效率等指标，以便管理层和团队了解缺陷管理情况。</li>
</ol>
<p>通过缺陷报告和缺陷管理，测试团队能够有效地跟踪、管理和解决软件中的缺陷，提高软件质量并促进项目的成功交付。</p>
<h2 id="10-测试素养">10.测试素养</h2>
<p>测试素养（Testing Aptitude）是指<strong>软件测试人员应该具备的一系列技能、知识和品质</strong>，以有效地进行软件测试工作并取得良好的测试结果。以下是测试素养的一些关键方面：</p>
<ol>
<li>技术能力：测试人员应具备扎实的技术背景，包括软件开发、编程语言、数据库操作、网络通信等相关知识。他们应该能够理解软件系统的技术细节，进行技术分析和故障排除。</li>
<li>测试方法和技巧：测试人员应熟悉各种测试方法和技巧，包括黑盒测试、白盒测试、功能测试、性能测试、安全测试等。他们应该知道如何选择合适的测试方法，并能够根据需求制定有效的测试策略和测试计划。</li>
<li>缺陷管理：测试人员应了解缺陷管理的基本原则和流程。他们应该能够准确地记录和报告缺陷，追踪和验证缺陷的修复，并与开发人员和其他团队成员进行有效的沟通和协作。</li>
<li>分析和解决问题能力：测试人员应具备良好的分析和解决问题的能力。他们应该能够分析测试结果和日志，找出问题的根本原因，并提出相应的解决方案和改进建议。</li>
<li>沟通和团队合作：测试人员应具备良好的沟通和团队合作能力。他们应该能够与项目团队的其他成员有效地合作，理解需求和交流测试进展，并能够清晰地向团队成员和利益相关者报告测试结果。</li>
<li>注重细节和质量：测试人员应具备注重细节和质量的意识。他们应该细致入微地进行测试，确保每个测试用例都被覆盖到，并对测试结果进行仔细分析和评估，以确保软件的质量和可靠性。</li>
<li>学习和适应能力：测试人员应具备良好的学习和适应能力。他们应该持续学习新的测试方法和工具，关注行业的最新趋势和技术发展，并能够快速适应项目的变化和需求的变更。</li>
<li>责任心和自我驱动：测试人员应具备责任心和自我驱动的品质。他们应该对自己的工作负责，积极主动地解决问题，不断提升自己的测试技能和知识，并追求卓越的测试结果。</li>
</ol>
<p>​	测试素养是测试人员成功从事软件测试工作的基础，它不仅包括技术方面的知识和技能，还涵盖了团队合作、沟通、问题解决和质量意识等方面的品质和能力。通过不断学习和实践，测试人员可以不断提升自己的测试素养，并为项目的成功交付做出重要贡献。</p>
<h2 id="12-测试报告的内容。">12.测试报告的内容。</h2>
<p>•在测试周期内发生了什么？比如达到测试出口准则的日期；</p>
<p>•通过分析相关信息和度量可以对下一步的活动提供建议和做出决策，比如对遗留缺陷的评估、继续进行测试的经济效益、未解决的风险以及被测试软件的置信度等。</p>
<p>•测试总结报告的大纲可以参考“软件测试文档标准”（IEEE Std 829-1998）。</p>
<p>•需要在测试级别的过程中和完成时收集度量信息，来评估：该测试级别的测试目标实现的充分性；</p>
<p>•采用的测试方法的适当性；</p>
<p>•针对测试目标的测试的有效性。</p>
<h1>二、测试方法</h1>
<p>从测试技术的角度， 可以分为黑盒测试、 白盒测试和灰盒测试；</p>
<h2 id="1-白盒测试">1.白盒测试</h2>
<p>​	白盒测试，也称为结构测试、透明盒测试或逻辑驱动测试，是一种软件测试方法，它基于对软件内部结构和实现细节的了解来设计测试用例和执行测试。</p>
<p>​	在白盒测试中，<strong>测试人员具有对软件内部的详细了解</strong>，包括源代码、设计文档和系统架构。测试人员使用这些信息来分析软件的内部逻辑、路径和数据流，以评估其正确性、可靠性和性能。</p>
<blockquote>
<p>白盒测试的目标是覆盖软件的所有代码路径，并验证每个逻辑分支和条件的正确性。它关注以下几个方面：</p>
<ol>
<li>代码覆盖：通过执行测试用例来覆盖软件中的所有代码行、分支和路径，以确保代码的正确性和可执行性。</li>
<li>控制流测试：测试人员基于软件内部结构设计测试用例，覆盖不同的控制流路径，例如循环、条件语句和异常处理。</li>
<li>数据流测试：测试人员分析软件中的数据流路径，设计测试用例以验证数据的正确传递和处理，例如变量赋值、数据引用和数据转换。</li>
<li>边界值测试：测试人员选择接近边界值的测试数据，以测试软件在边界条件下的行为和处理能力，例如最大值、最小值、边界情况等。</li>
<li>异常处理测试：测试人员针对软件中的异常情况设计测试用例，验证软件在异常情况下的处理和恢复能力，例如错误输入、资源不足、网络中断等。</li>
<li>性能测试：在白盒测试中也可以关注软件的性能方面，例如检查资源利用率、响应时间和吞吐量等。</li>
</ol>
<p>白盒测试可以帮助发现软件内部的逻辑错误、代码缺陷和潜在的安全漏洞。通过对软件的内部结构进行深入分析和测试，可以提高软件的质量、可靠性和安全性。白盒测试通常由开发人员或专门的测试人员执行，并结合其他测试方法（如黑盒测试）来全面评估软件的质量。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620222800107.png" alt="image-20230620222800107"></p>
<h3 id="逻辑覆盖法">逻辑覆盖法</h3>
<p>​	逻辑覆盖是通过对<strong>程序逻辑结构的遍历实现对程序的覆盖</strong>，它是一系列测试过程的总称，这组测试过程逐渐实现越来越完整的通路测试。逻辑覆盖标准包括以下不同的覆盖标准：</p>
<p>语句覆盖（Statement Coverage，SC）</p>
<blockquote>
<p>​	语句覆盖，又称行覆盖（LineCoverage）、段覆盖（SegmentCoverage）、基本块覆盖（BasicBlockCoverage），这是最常用也是最常见的一种覆盖方式。其基本思想是设计若干个测试用例，运行被测程序，<strong>使程序中每一条可执行语句至少应该执行一次</strong>。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223107154.png" alt="image-20230620223107154"></p>
</blockquote>
<p>判定覆盖（Decision Coverage，DC）</p>
<blockquote>
<p>​    希望通过设计足够多的测试用例，使得程序中的<strong>每个判定至少都获得一次“真”值和“假”值</strong>， 也就是使程序中的每个取“真”分支和取“假”分支至少均经历一次，这种设计测试用例的方法称为判定覆盖，也称为“分支覆盖”。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223126809.png" alt="image-20230620223126809"></p>
</blockquote>
<p>条件覆盖（Condition Coverage，CC）</p>
<blockquote>
<p>​    通过设计足够多的测试用例，使得程序中<strong>每个判定包含的每个条件的可能取值（真/假）都至少出现一次</strong>。这种设计测试用例的方法称为条件覆盖。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223200557.png" alt="image-20230620223200557"></p>
</blockquote>
<p>条件判定组合覆盖（Condition/Decision Coverage,DC）</p>
<blockquote>
<p>通过设计足够多的测试用例，使得程序中每个判定包含的每个条件的所有情况（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次。这种设计测试用例的方法称为判定/条件覆盖。</p>
<p>满足判定/条件覆盖的测试用例集一定同时满足判定覆盖和条件覆盖。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223227566.png" alt="image-20230620223227566"></p>
</blockquote>
<p>多条件覆盖（Multiple Condition Coverage,MCC）</p>
<blockquote>
<p>通过设计足够多的测试用例，使得程序中每个判定的所有可能的条件取值组合都至少出现一次。这种设计测试用例的方法称为组合覆盖。</p>
<p>满足组合覆盖的测试用例集一定满足判定覆盖、条件覆盖和判定/条件覆盖。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223309937.png" alt="image-20230620223309937"></p>
</blockquote>
<p>修正条件判定覆盖（modified condition decision coverage,MCDC）</p>
<h3 id="基本路径测试法">基本路径测试法</h3>
<p>通过设计足够多的测试用例，要求覆盖程序的基本路径集合中所有可能的路径。这种设计测试用例的方法称为基本路径覆盖。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223012197.png" alt="image-20230620223012197"></p>
<p><strong>程序的控制流图</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621004819804.png" alt="image-20230621004819804"></p>
<p><strong>控制流图的环路复杂性</strong></p>
<p>​	程序的<strong>环路复杂性</strong>即McCabe复杂性度量，在进行程序的基本路径测试时，从程序的环路复杂性可导出程序<strong>基本路径</strong>集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</p>
<p>独立路径是指包括一组以前没有处理过的语句或条件的一条路径。从控制流图来看，一条独立路径是至少包含有一条在其他独立路径中从未有过的边的路径。(b)所示的控制流图中,一组独立的路径如下:</p>
<p>path1：1-11</p>
<p>path2：1-2-3-4-5-10-1-11</p>
<p>path3：1-2-3-6-8-9-10-1-11</p>
<p>path4：1-2-3-6-7-9-10-1-11</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621005024704.png" alt="image-20230621005024704" style="zoom:50%;" />
<p><strong>基本路径覆盖-测试用例设计步骤</strong></p>
<p>（1）以详细的设计或源代码为基础，导出程序的控制流程图</p>
<p>（2）计算控制流图G的环路复杂性V（G）</p>
<p>V（G）=区域数</p>
<p>V（G）=判断节点数+1</p>
<p>V（G）=边的个数-节点个数+2</p>
<p>（3）导出独立路径</p>
<p>（4）设计测试用例，确保每条路径都被执行</p>
<p><strong>基本路径覆盖-案例</strong></p>
<p>将一个正整数分解为质因数的Java程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line">String rs=n+<span class="string">&quot;=&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==n)&#123;</span><br><span class="line">		rs=rs+n;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%k==<span class="number">0</span>)&#123;</span><br><span class="line">			rs=rs+k+<span class="string">&quot;*&quot;</span>;</span><br><span class="line">			n=n/k;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（1）画出程序控制流图</strong></p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621005354340.png" alt="image-20230621005354340" style="zoom:50%;" />
<p><strong>（2）计算环形复杂度：</strong></p>
<p>V(G)=9-8+2=2+1=3</p>
<blockquote>
<p>将V(G)定义为：</p>
<p>V(G)=e-n+2</p>
<p>这里，e是控制流图的边数，n是控制流图的节点数。我们还可以用如下两个方法计算环形复杂度：</p>
<p>V(G)=区域数</p>
<p>V(G)=判定节点数+1</p>
<p>这里，区域是指由边包围起来的形状，图中没有被边包围的部分也算一个区域。判定节点是有多个边以它作为起点的节点。</p>
</blockquote>
<p><strong>（3）找出一组独立路径（基本路径集合）：</strong></p>
<p>路径1：1-2-3-4</p>
<p>路径2：1-2-3-5-6-8-2-3-4</p>
<p>路径3：1-2-3-5-7-8-2-3-4</p>
<p><strong>（4）根据基本路径设计测试用例，覆盖基本路径集合中的所有路径</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621005710849.png" alt="image-20230621005710849"></p>
<h2 id="2-黑盒测试">2.黑盒测试</h2>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621010108798.png" alt="image-20230621010108798"></p>
<p>​	黑盒测试是一种软件测试方法，它在不考虑软件内部结构和实现细节的情况下，通过输入和输出来评估软件的功能和性能。</p>
<p>​	在黑盒测试中，测试人员只关注软件的外部行为和功能，而<strong>无需了解其内部实现</strong>。测试人员根据需求规格说明书、用户手册或软件规范来设计测试用例，并通过输入不同的数据和操作来触发软件的功能，然后检查输出结果是否符合预期。</p>
<blockquote>
<p>黑盒测试的目标是验证软件是否符合规格说明书、用户需求和预期功能。它关注以下几个方面：</p>
<ol>
<li>功能测试：测试人员验证软件的各项功能是否按照规格说明书和用户需求正常工作。他们设计测试用例，覆盖不同的功能路径，例如输入验证、功能操作、数据处理等。</li>
<li>界面测试：测试人员评估软件的用户界面，包括布局、样式、导航和用户交互。他们验证界面的易用性、一致性和响应性。</li>
<li>性能测试：在黑盒测试中也可以关注软件的性能方面，例如测试软件在各种负载条件下的响应时间、资源利用率和吞吐量等。</li>
<li>兼容性测试：测试人员验证软件在不同的操作系统、浏览器、设备或网络环境下的兼容性。他们检查软件是否在不同环境中正常运行和展现预期的行为。</li>
<li>安全性测试：测试人员评估软件的安全性，包括检查是否存在潜在的安全漏洞、验证用户身份验证和访问控制机制等。</li>
<li>错误处理测试：测试人员故意输入错误数据或异常情况，以测试软件的错误处理能力。他们验证软件是否能够正确识别、记录和处理错误，以及恢复到正常状态。</li>
</ol>
<p>黑盒测试侧重于从用户的角度评估软件的功能和性能，以确保软件的质量和用户满意度。它可以帮助发现功能缺陷、用户体验问题、兼容性和安全性漏洞等。黑盒测试通常由专门的测试人员执行，以独立于开发人员的视角来评估软件。</p>
</blockquote>
<h3 id="等价类">等价类</h3>
<p>背景：<strong>对系统进行穷尽测试是不可能的,使用有限的数据对系统进行测试是可能的</strong></p>
<p>我们可以选择少量测试用例来测试系统，并满足:</p>
<ul>
<li>测试是完备的</li>
<li>测试是没有冗余的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621010416678.png" alt="image-20230621010416678"></p>
<p><strong>分类：</strong></p>
<ul>
<li>有效等价类
<ul>
<li>输入域中一组有意义的数据的集合</li>
<li>有效等价类被用于检验系统指定功能和性能能否正确实现</li>
</ul>
</li>
<li>无效等价类
<ul>
<li>l输入域中一组无意义的数据的集合</li>
<li>无效等价类被用于检验系统的容错性</li>
</ul>
</li>
</ul>
<p><strong>划分等价类的规则</strong></p>
<p>•（1） 输入的数据是<strong>布尔值</strong>，这是一种特殊的情况，只有两个等价类：真（True）和假（False）。</p>
<p>•（2）在输入条件规定了<strong>取值范围</strong>的前提下，则可以确定一个有效等价类和两个无效等价类。例如，程序输入数据要求是两位正整数x，则有效等价类为10≤x≤99，两个无效等价类为x&lt;10和x&gt;99。</p>
<p>•（3）如果规定了输入数据的<strong>个数</strong>，则类似地可以划分出一个有效等价类和两个无效等价类。例如一个学生每学期只能选修1-3门课，则有效等价类是选修1-3门课，而无效等价类有“一门课都不选”或“选修超过3门”。</p>
<p>•（4）在输入条件规定了<strong>输入值的集合</strong>或者规定了“<strong>必须如何</strong>”的条件下，可以确定一个有效等价类和多个无效等价类。例如，邮政编码必须由6位数字构成有效的值，其有效集合是清楚的，对应存在一个无效的集合，包括多个无效等价类。</p>
<p>•（5）规定了<strong>一组列表形式</strong>（n个值）的输入数据，并且程序要对每一个输入值分别进行处理的情况下，可以确定n个有效等价类和一个无效等价类。例如将我国的直辖市作为程序的输入值，其有效等价类是一个固定的枚举类型{北京、上海、天津、重庆}，而且要针对每个城市分别取出相对应的数据，此时无效等价类为非直辖市的省、自治区等。</p>
<p>•（6）更复杂的情况是，输入数据只是要求符合某个规则，这时可能存在多个有效等价类和若干个无效等价类。</p>
<p><strong>等价类划分法-案例1</strong></p>
<p>假如某个系统的注册用户名要求由字母开头，后跟字母或数字的任意组合，有效字符数不超过6个。</p>
<p>等价类划分：</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011021039.png" alt="image-20230621011021039"></p>
<ul>
<li>弱覆盖
<ul>
<li>测试用例应覆盖所有的有效等价类</li>
</ul>
</li>
<li>强覆盖
<ul>
<li>测试用例应覆盖所有的有效等价类的组合</li>
</ul>
</li>
</ul>
<p><strong>等价类划分法-案例2</strong></p>
<p>在应用程序中经常要求输入电话号码，我国的固定电话号码一般由两部分组成：</p>
<p>地区码：以0开头的3位或者4位数字。</p>
<p>电话号码：以非0、非1开头的7位或者8位数字。</p>
<p>应用程序应接受一切符合上述规定的电话号码，但应拒绝不符合上述规定的号码。</p>
<p>等价类划分：</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011226908.png" alt="image-20230621011226908"></p>
<p>设计测试用例：</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011257920.png" alt="image-20230621011257920"></p>
<p>等价类测试流程：</p>
<ul>
<li>确定有几个输入条件</li>
<li>划分每个输入条件的等价类</li>
<li>选择合适的覆盖标准</li>
<li>设计测试用例</li>
</ul>
<h3 id="边界值分析">边界值分析</h3>
<p><strong>背景：</strong></p>
<ul>
<li>经过长期的测试工作经验表明，在输入域的边界或边界附近，常常会发现大量缺陷</li>
<li>边界值测试倾向于选择系统边界或边界附近的数据来设计测试用例</li>
</ul>
<p>试试根据以下业务的需求，设计边界值测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">某保险网站的前台计算保费的页面中要求输入被保险人的年龄，根据不同的年龄使用不同的保险费率计算标准。</span><br><span class="line">保费计算方式为：保费=投保额X保险费率。</span><br><span class="line">其中：</span><br><span class="line">1-15岁，保险费率为10%；</span><br><span class="line">16-20岁，保险费率为15%；</span><br><span class="line">21-50岁，保险费率为20%；</span><br><span class="line">51-70岁，保险费率为25%。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>依赖于边界值的等价类划分:</p>
<table>
<thead>
<tr>
<th>年龄</th>
<th>保险费率</th>
<th>年龄</th>
<th>保险费率</th>
</tr>
</thead>
<tbody>
<tr>
<td>x&lt;0</td>
<td>无效输入</td>
<td>20&lt;x≤50</td>
<td>20%</td>
</tr>
<tr>
<td>1≤x≤15</td>
<td>10%</td>
<td>50&lt;x≤70</td>
<td>25%</td>
</tr>
<tr>
<td>15&lt;x≤20</td>
<td>15%</td>
<td>x&gt;70</td>
<td>无效输入</td>
</tr>
</tbody>
</table>
<p><strong>问题1：边界在哪里？</strong></p>
<p>边界点就是可能导致被测系统内部处理机制<strong>发生变化</strong>的点</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011758838.png" alt="image-20230621011758838"></p>
<p>需求中有利于识别边界点的文字：</p>
<p>位置，尺寸，数量，长度，速度，高度，距离，质量，时间…</p>
<p>可能的边界点：</p>
<p>第一个/最后一个，最小/最大，最少/最多，最短/最长，最快/最慢，最高/最低，最近/最远，最重/最轻，最早/最晚…</p>
<p>总结：<strong>找到每个输入条件的边界点即可确定系统的边界点。</strong></p>
<p><strong>问题2：如何确定邻域？</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011930539.png" alt="image-20230621011930539"></p>
<p><strong>问题3：如何选择测试数据？</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011951271.png" alt="image-20230621011951271"></p>
<p><strong>问题4：如何设计测试用例？</strong></p>
<p>穷尽测试</p>
<p>在边界及边界附近的邻域内选择所有的测试数据，构成测试用例。</p>
<p>做一做：ind add(int x1,int x2)</p>
<p>​         1 ≤ x1 ≤ 100</p>
<p>​        10 ≤ x2 ≤ 50</p>
<p>使用边界值测试设计测试用例</p>
<h3 id="组合测试">组合测试</h3>
<p><strong>背景</strong>：等价类划分法和边界值分析法都假定程序的各个输入变量时完全独立的。在实际程序中，更多的情况时各个输入变量的组合共同导致了程序的输出。</p>
<p><strong>正交实验法</strong></p>
<p>在许多应用系统的测试工作中，输入条件的因素很多，而且每个因素也不能简单用“是”和“否”来回答。</p>
<p>例：为提高某化工产品的转化率，选择了三个有关因素进行条件试验：反应温度（A），反应时间（B），用碱量（C），这三个因素的试验范围如下：</p>
<p>A：80-90℃</p>
<p>B：90-150分钟</p>
<p>C：5-7％</p>
<p>对A、B、C三个因素分别取三个水平值，如下：</p>
<p>A：A1=80 ℃ ,A2=85 ℃,A3=90 ℃</p>
<p>B:B1=90分钟，B2=120分钟，B3=150分钟</p>
<p>C:C1=5%，C2=6%，C3=7%</p>
<p>对于3个因素、各因素3个水平的测试用例设计，完全组合需要3X3X3=27个测试用例。</p>
<p>依据Galois理论，从大量的（实验）数据（测试用例）中挑选适量的、有代表性的点（条件组合），从而合理地安排实验（测试）的一种科学实验设计方法。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621134351682.png" alt="image-20230621134351682" style="zoom:50%;" />
<p>在测试实践中，可以直接使用现成的正交表进行测试用例的设计。正交表用Ln(tc)标识，其中L为正交表的代号，n为试验的次数（行数），t为水平数，c为因子数，常见的正交表有L4(23)、L8(27)、L9(34)、L16(45)等。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621134427794.png" alt="image-20230621134427794"></p>
<p>实例1</p>
<p>某所大学通信系共有2个班级，这两个班刚考完某一门课程，现在要通过教务系统查询学生成绩。假设有3个独立的查询条件，可以获得特定学生的个人成绩。</p>
<p>性别：{男，女}</p>
<p>班级：{1班，2班}</p>
<p>成绩：{及格，不及格}</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621134441819.png" alt="image-20230621134441819"></p>
<h3 id="场景法">场景法</h3>
<p>​    场景法就是<strong>模拟用户操作软件时</strong>的场景，主要用于测试系统的业务流程。当拿到一个测试任务时，一般并不是先关注某个控件的边界值、等价类能否满足要求，而是要先关注它的<strong>主要功能和业务流程能否正确实现</strong>，这就需要场景法来完成测试。</p>
<p>用例场景用来描述用例流经的路径，从开始到结束遍历整条路径上所有的基本流和备选流。</p>
<ul>
<li>l基本流：按照正确的业务流程实现的一条操作路径（模拟正确的操作流程）。</li>
<li>l备选流：导致程序出现错误的操作流程（模拟错误的操作流程）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132411692.png" alt="image-20230621132411692"></p>
<p>在如图所示的操作流程中，可以确定以下场景：</p>
<p>场景1：基本流</p>
<p>场景2：基本流 备选流1</p>
<p>场景3：基本流 备选流1 备选流2</p>
<p>场景4：基本流 备选流3</p>
<p>场景5：基本流 备选流3 备选流1</p>
<p>场景6：基本流 备选流3 备选流1 备选流2</p>
<p>场景7：基本流 备选流4</p>
<p>场景8：基本流 备选流3 备选流4</p>
<p><strong>实例分析-ATM机取款的例子：</strong></p>
<table>
<thead>
<tr>
<th>步骤编号</th>
<th>基本流</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>插入银行卡：客户将银行卡插入ATM机的读卡器</td>
</tr>
<tr>
<td>2</td>
<td>验证银行卡：ATM机从银行卡的芯片中读取账户代码，并检查它是否属于可以接受的银行卡</td>
</tr>
<tr>
<td>3</td>
<td>输入密码：ATM机要求客户输入密码</td>
</tr>
<tr>
<td>4</td>
<td>验证密码：确定该密码是否正确</td>
</tr>
<tr>
<td>5</td>
<td>进入ATM机主界面：ATM机显示各种操作选项</td>
</tr>
<tr>
<td>6</td>
<td>取款并选择金额：客户选择“取款”，并选择取款金额</td>
</tr>
<tr>
<td>7</td>
<td>ATM机验证：ATM机验证账户余额、当日总取款金额等是否满足要求，验证ATM机内现金是否够用</td>
</tr>
<tr>
<td>8</td>
<td>更新账户余额、出钞：验证成功，更新账户余额，输出现金，提示用户收取现金</td>
</tr>
<tr>
<td>9</td>
<td>返回操作主界面</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132509790.png" alt="image-20230621132509790"></p>
<table>
<thead>
<tr>
<th>场景描述</th>
<th>基本流</th>
<th>备选流</th>
</tr>
</thead>
<tbody>
<tr>
<td>场景1：成功取款</td>
<td>基本流</td>
<td></td>
</tr>
<tr>
<td>场景2：银行卡无效</td>
<td>基本流</td>
<td>备选流1</td>
</tr>
<tr>
<td>场景3：密码错误</td>
<td>基本流</td>
<td>备选流2</td>
</tr>
<tr>
<td>场景4：密码3次错误</td>
<td>基本流</td>
<td>备选流3</td>
</tr>
<tr>
<td>场景5：账户余额不足</td>
<td>基本流</td>
<td>备选流4</td>
</tr>
<tr>
<td>场景6：当日总取款金额超出可取限额</td>
<td>基本流</td>
<td>备选流5</td>
</tr>
<tr>
<td>场景7：ATM机余额不足</td>
<td>基本流</td>
<td>备选流6</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132526015.png" alt="image-20230621132526015"></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132535176.png" alt="image-20230621132535176"></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132540311.png" alt="image-20230621132540311"></p>
<h3 id="因果图测试法">因果图测试法</h3>
<p><strong>背景：</strong></p>
<p>​	在一个功能或一个界面中，往往会有多个控件，这些控件一般会有一定的制约关系或组合关系，并且功能模块的输出会依赖于输入的条件。</p>
<p>​	如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p>
<p><strong>原理：</strong></p>
<p>​    一些程序的功能可以用判定表（或称决策表）的形式来表示，并根据输入条件的组合情况规定相应的操作。。</p>
<p>定义：是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p>
<p><strong>因果图基本符号：</strong></p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132703518.png" alt="image-20230621132703518" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132715860.png" alt="image-20230621132715860" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132726664.png" alt="image-20230621132726664" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132810064.png" alt="image-20230621132810064" style="zoom:50%;" />
<p>左结点ci表示输入状态（或称原因），右结点ei表示输出状态（或称结果）。</p>
<p>ci 与 ei 取值0或1，0表示某状态不出现，1则表示某状态出现。</p>
<p><strong>因果图4种关系:</strong></p>
<p>Ø恒等：若 c1 是1，则 e1 也为1，否则 e1 为0。</p>
<p>Ø非：若 c1 是1，则 e1 为0，否则e1为1。</p>
<p>Ø或：若 c1 或 c2 或 c3 是1，则 e1 为1，否则 e1 为0。</p>
<p>Ø与：若 c1 和 c2 都是1，则 e1 为1，否则 e1 为0。</p>
<p><strong>约束</strong></p>
<p>​    在实际问题中输入状态相互之间、输出状态相互之间可能存在某些依赖关系，称为“约束”或“制约”。对于输入条件的约束有E、I、O、R四种约束，对于输出条件的约束只有M约束。</p>
<p>ØE约束(异)：a和b中最多只有一个为1，即a和b不能同时 为1。（如3个a、b、c则a、b、c最多只有一个1，或全0）</p>
<p>ØI 约束(或)：a、b、c中至少有一个必须为1，即 a、b、c不能同时为0。</p>
<p>ØO约束(唯一)：a和b必须有一个且仅有一个为1。</p>
<p>ØR约束(要求)：a是1时，b必须是1，即a为1时，b不能为0。</p>
<p>ØM约束(强制)：若结果a为0，则结果b强制为0。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132925214.png" alt="image-20230621132925214" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132936586.png" alt="image-20230621132936586" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132942148.png" alt="image-20230621132942148" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132947615.png" alt="image-20230621132947615" style="zoom:50%;" />
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132955263.png" alt="image-20230621132955263" style="zoom:50%;" />
<p><strong>因果图测试流程</strong></p>
<p>1.根据程序规格说明书描述，分析并确定因（输入条件）和果（输出结果或程序状态的改变），画出因果图</p>
<p>2.将得到的因果图转换为判定表。</p>
<p>3.为判定表中每一列所表示的情况设计一个测试用例。</p>
<p><strong>因果图测试案例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">公交一卡通自动充值系统，其需求描述如下：</span><br><span class="line"></span><br><span class="line">Ø系统只接收50元或100元纸币，一次充值只能使用一张纸币，一次充值金额只能为50元或100元。</span><br><span class="line"></span><br><span class="line">Ø若输入50元纸币，并选择充值50元，完成充值后退卡，提示充值成功。</span><br><span class="line"></span><br><span class="line">Ø若输入50元纸币，并选择充值100元，提示输入金额不足，并退回50元。</span><br><span class="line"></span><br><span class="line">Ø若输入100元纸币，并选择充值50元，完成充值后退卡，提示充值成功，找零50元。</span><br><span class="line"></span><br><span class="line">Ø若输入100元纸币，并选择充值100元，完成充值后退卡，提示充值成功。</span><br><span class="line"></span><br><span class="line">Ø若输入纸币后在规定时间内不选择充值按钮，退回输入的纸币，并提示错误。</span><br><span class="line"></span><br><span class="line">Ø若选择充值按钮后不输入纸币，提示错误。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133121581.png" alt="image-20230621133121581" style="zoom:50%;" />
<p><strong>（1）条件之间的制约及组合关系</strong></p>
<p>根据上述描述，输入条件（原因）为：</p>
<p>① 投币50元</p>
<p>② 投币100元</p>
<p>③ 选择充值50元</p>
<p>④ 选择充值100元</p>
<p>输出（结果）有：</p>
<p>（a）完成充值、退卡</p>
<p>（b）提示充值成功</p>
<p>（c）找零</p>
<p>（d）提示错误</p>
<p><strong>（2）明确所有条件之间的制约关系以及组合关系</strong></p>
<p>条件之间的制约关系以及组合关系如图所示。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133141963.png" alt="image-20230621133141963" style="zoom:50%;" />
<p><strong>（3）画出因果图</strong></p>
<p>为了描述得更清楚，这里把每种情况单独画一个因果图出来。</p>
<p>条件①和条件③可以组合，输出a和b的组合，也就是投币50元，充值50元，会输出完成充值、退卡，提示充值成功的结果。其因果图如图所示。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133155285.png" alt="image-20230621133155285" style="zoom:50%;" />
<p>条件①和条件④可以组合，输出c和d的组合，也就是投币50元，充值100元，会输出找零、提示错误的结果。其因果图如图所示。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133217452.png" alt="image-20230621133217452" style="zoom: 67%;" />
<p>条件②和条件③可以组合，输出a、b、c的组合，也就是投币100元，充值50元，会输出找零、完成充值、提示充值成功的结果。其因果图如图所示。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133232452.png" alt="image-20230621133232452" style="zoom:67%;" />
<p>条件②和条件④可以组合，输出a和b的组合，也就是投币100元，充值100元，会输出完成充值、退卡，提示充值成功的结果。其因果图如图所示。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133240846.png" alt="image-20230621133240846" style="zoom:67%;" />
<p>条件①、②、③、④均可以单独出现，其因果图如图所示。</p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133258923.png" alt="image-20230621133258923" style="zoom:50%;" />
<p><strong>（4）根据因果图，写出判定表</strong></p>
<p>根据上面的因果图，写出对应的判定表。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133312023.png" alt="image-20230621133312023"></p>
<p><strong>（5）根据判定表，写出测试用例</strong></p>
<p>根据上面的判定图，写出对应的测试用例</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>用例说明</th>
<th>预期结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>投币50元 选择充值50元</td>
<td>正确充值50元，提示充值成功后退卡</td>
</tr>
<tr>
<td>2</td>
<td>投币50元 选择充值100元</td>
<td>系统提示错误并退回50元</td>
</tr>
<tr>
<td>3</td>
<td>投币100元 选择充值50元</td>
<td>正确充值50元，提示充值成功后退卡，并找回50元</td>
</tr>
<tr>
<td>4</td>
<td>投币100元 选择充值100元</td>
<td>正确充值100元，提示充值成功后退卡</td>
</tr>
<tr>
<td>5</td>
<td>投币50元</td>
<td>系统提示错误并退回50元</td>
</tr>
<tr>
<td>6</td>
<td>投币100元</td>
<td>系统提示错误并退回100元</td>
</tr>
<tr>
<td>7</td>
<td>选择充值50元</td>
<td>系统提示错误</td>
</tr>
<tr>
<td>8</td>
<td>选择充值100元</td>
<td>系统提示错误</td>
</tr>
</tbody>
</table>
<h3 id="决策表法">决策表法</h3>
<p><strong>背景</strong></p>
<p>Ø在所有的黑盒测试方法中，基于决策表（也称判定表）的测试是最为严格、最具有逻辑性的测试方法。</p>
<p>Ø决策表的概念：决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。</p>
<p><strong>优点：</strong></p>
<p>Ø能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用决策表能够设计出完整的测试用例集合。</p>
<p>Ø在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。决策表很适合于处理这类问题。</p>
<p>Ø了解五个概念——条件桩、动作桩、条件项、动作项和规则。</p>
<ul>
<li>l条件桩：列出问题的所有条件，如上述3个条件——功率大小、维修记录和运行时间。</li>
<li>l动作桩：列出针对问题所采取的操作，如优先维修。</li>
<li>l条件项：针对所列条件的具体赋值，即对每个条件可以取真值和假值。</li>
<li>l动作项：列出在条件项（各种取值）组合情况下应该采取的动作。</li>
<li>l规则：任何一个条件组合的特定取值及其相应要执行的操作。在决策表中贯穿条件项和动作项的一列就是一条规则。</li>
</ul>
<p><strong>构建步骤</strong></p>
<img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133608230.png" alt="image-20230621133608230" style="zoom: 50%;" />
<p>Ø若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。</p>
<p>Ø合并后的条件项用符号“-”表示，说明执行的动作与该条件的取值无关，称为无关条件。</p>
<p><strong>（1）使用决策表法为设备维修程序设计测试用例</strong></p>
<p>Ø仍以上述“设备维修”为例来说明如何制定决策表。首先，列出所有的条件桩和动作桩，本例的条件桩有3个，分别为：</p>
<p>Ø机器功率是否大于100马力？</p>
<p>Ø维修记录是否完整？</p>
<p>Ø运行时间是否超过6年？</p>
<p>l本例的动作桩有两个，分别为：</p>
<p>Ø优先维修。</p>
<p>Ø正常维修。</p>
<p>l接着确定条件项，即上述每个条件的值分别取“是（Y）”和“否（N）”。根据条件项的组合确定其对应的活动，如表所示。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133915660.png" alt="image-20230621133915660"></p>
<p>根据表6-23所示的4种组合可设计出以下4个测试用例：</p>
<p>l功率大于100马力（如，200马力），优先维修。</p>
<p>l功率不大于100马力（如，99马力），维修记录不全，优先维修。</p>
<p>l功率不大于100马力（如，99马力），维修记录全且运行时间超过6年（如，8年），优先维修。</p>
<p>l功率不大于100马力（如，99马力），维修记录全且运行时间不超过6年（如，3年），正常维修。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133758806.png" alt="image-20230621133758806"></p>
<h1>三、测试策略</h1>
<p>根据是否运行程序，软件测试技术可分为：<strong>静态测试，动态测试</strong></p>
<p>静态测试与动态测试的区别。</p>
<ol>
<li>对象：静态测试关注软件系统的静态属性和文档，如代码、需求规格、设计文档等；动态测试关注软件系统的运行时行为和功能。</li>
<li>执行：静态测试在不执行程序的情况下进行评审、检查和分析；动态测试需要执行程序，通过输入测试数据和执行测试用例来验证软件系统的行为。</li>
<li>目的：静态测试的目的是发现潜在的问题和缺陷，改进软件系统的质量；动态测试的目的是评估软件系统的正确性、稳定性、性能等方面。</li>
<li>方法：静态测试方法包括代码走查、需求审查、设计审查、静态分析等；动态测试方法包括单元测试、集成测试、系统测试、性能测试等。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620225130388.png" alt="image-20230620225130388"></p>
<h2 id="1-静态测试">1.静态测试</h2>
<p>静态测试（Static Testing）是一种软件测试方法，它在<strong>执行程序时不涉及实际运行代码</strong>，而是<strong>通过对软件产品或文档进行分析和检查来评估其质量和正确性</strong>。它主要关注于检查代码、设计、文档和其他软件工件的正确性、合规性和一致性。</p>
<p>静态测试通常包括以下活动：</p>
<ol>
<li>代码审查（Code Review）：通过检查源代码来发现潜在的错误、漏洞和质量问题。代码审查可以是手动的，由开发人员或测试人员逐行检查代码，也可以是自动的，利用静态分析工具来检查代码的规范性、安全性和性能问题。</li>
<li>静态分析（Static Analysis）：使用自动化工具对源代码、配置文件或其他软件工件进行静态分析，以检测潜在的问题。静态分析工具可以检查代码的语法错误、代码规范违规、潜在的内存泄漏、不安全的编码实践等。</li>
<li>文档审查（Document Review）：对软件需求规格、设计文档、用户手册等进行审查，以确保其准确性、完整性和一致性。文档审查可以帮助发现潜在的逻辑错误、需求不一致、遗漏的功能等问题。</li>
<li>静态测试工具使用：使用专门的静态测试工具对软件工件进行分析和检查。这些工具可以帮助发现代码中的潜在问题，如未使用的变量、死代码、低效的算法等。</li>
</ol>
<p>静态测试的优点包括：</p>
<ul>
<li>提早发现问题：静态测试可以在运行代码之前发现潜在的问题，减少后期修复的成本和风险。</li>
<li>提高代码质量：通过代码审查和静态分析，可以发现和纠正代码中的错误和缺陷，提高代码的质量和可靠性。</li>
<li>改进文档质量：文档审查可以帮助发现需求和设计文档中的错误和遗漏，确保文档的准确性和可理解性。</li>
<li>自动化支持：静态测试工具可以自动化执行测试，减少人工工作量，提高效率和一致性。</li>
</ul>
<p>需要注意的是，静态测试并不能替代动态测试（如单元测试、集成测试和系统测试），因为静态测试无法覆盖代码的实际执行路径和运行时环境。静态测试主要用于提高软件质量和发现潜在问题，而动态测试则用于验证软件在实际运行时的功能和性能。</p>
<h3 id="代码走查">代码走查</h3>
<p>代码走查（Code Review）是一种软件开发过程中的质量保证活动，<strong>旨在通过审查和检查源代码，发现潜在的错误、缺陷和改进点</strong>，以提高代码的质量、可读性、可维护性和性能。</p>
<p>代码走查通常由开发团队中的其他成员（如技术主管、高级开发人员或同行开发人员）进行，他们独立地检查和评估源代码的各个方面，包括但不限于以下内容：</p>
<ol>
<li>
<p>代码规范：检查代码是否符合组织或项目的编码规范，包括命名规则、缩进、注释、代码结构等。</p>
</li>
<li>
<p>潜在错误：寻找代码中的错误、逻辑问题、边界情况和异常处理，确保代码在各种情况下都能正确运行。</p>
</li>
<li>
<p>可读性：评估代码的可读性和可理解性，包括变量和函数命名的清晰度、代码注释的质量和准确性，以及代码块的组织结构等。</p>
</li>
<li>
<p>性能优化：查找可能影响性能的代码段，并提出改进建议，如减少不必要的循环、优化算法等。</p>
</li>
<li>
<p>安全性：检查代码是否存在潜在的安全漏洞，如输入验证不充分、密码存储不安全等，并提供改进建议以增强系统的安全性。</p>
</li>
<li>
<p>最佳实践：评估代码是否遵循最佳实践和设计原则，如单一职责原则、开闭原则、依赖倒置原则等。</p>
</li>
</ol>
<p>代码走查的目的是提高代码质量、减少错误和缺陷，并促进知识共享和团队合作。它是一种有效的方法，可以在代码进入测试和部署阶段之前发现和解决问题，从而降低后期修复成本和改进工作的复杂性。通过代码走查，开发团队可以相互学习、提高技术水平，并共同努力构建高质量的软件系统。</p>
<h2 id="2-动态测试">2.动态测试</h2>
<p>动态测试（Dynamic Testing）是一种软件测试方法，它涉及<strong>在实际运行时执行软件代码，通过输入测试数据并观察输出结果</strong>来评估软件的功能、性能和可靠性。</p>
<p>动态测试主要包括以下活动：</p>
<ol>
<li>单元测试（Unit Testing）：针对软件中的最小可测试单元（如函数、方法或类）编写和执行测试用例。单元测试旨在验证单元的行为是否符合预期，以确保其功能正确性和代码覆盖率。</li>
<li>集成测试（Integration Testing）：测试多个模块或组件之间的接口和交互。集成测试的目标是验证这些模块或组件在协同工作时是否能够正确地传递和处理数据，以及是否满足系统的功能需求。</li>
<li>系统测试（System Testing）：对整个系统进行完整的测试，以验证系统是否满足用户需求和规格要求。系统测试通常包括功能测试、性能测试、安全测试、兼容性测试等。</li>
<li>验收测试（Acceptance Testing）：由最终用户或客户执行的测试，以验证软件是否满足其期望和需求。验收测试通常涉及对实际使用场景进行测试，以确保软件在真实环境中的功能和性能。</li>
</ol>
<p>动态测试的优点包括：</p>
<ul>
<li>验证软件功能：通过输入测试数据并观察输出结果，可以验证软件的功能是否按照预期工作。</li>
<li>发现缺陷和错误：动态测试可以揭示代码中的错误、缺陷和异常情况，帮助开发团队改进和修复问题。</li>
<li>提高软件质量：通过系统化和全面的动态测试，可以提高软件的质量、可靠性和性能。</li>
<li>验证需求和规格：动态测试可确保软件满足用户需求和规格要求，帮助减少需求和设计方面的错误。</li>
</ul>
<p>需要注意的是，动态测试的有效性取决于测试用例的设计和执行质量。设计充分、覆盖全面的测试用例可以提高测试的效果和准确性。同时，动态测试也需要结合其他测试方法（如静态测试、自动化测试等）来实现全面的软件测试覆盖。</p>
<h1>四、测试级别</h1>
<p>测试级别与项目的职责相关联。 从测试阶段或对象的角度， 可以分为单元测试、集成测试、 系统测试和验收测试；</p>
<h2 id="1-单元测试">1.单元测试</h2>
<p>​	**单元测试是在软件开发过程中要进行的最低级别的测试活动，**或者说是针对软件设计的最小单位——程序模块，进行正确性检验</p>
<p>的测试工作。其目的在于发现每个程序模块内部可能存在的差错。</p>
<p>​</p>
<p><strong>测试对象:</strong></p>
<p>​	结构化编程-函数、过程</p>
<p>​	面向对象编程-类</p>
<p><strong>测试目的:</strong></p>
<p>​	发现设计或视线中的逻辑错误，及早暴露代码中的缺陷，便于问题的定义和解决</p>
<p><strong>测试方法</strong>:</p>
<p>​	一般以白盒测试为主、结合黑盒测试的方法，允许多个测试单元的测试并行展开。</p>
<p><strong>内容</strong>：</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620234037996.png" alt="image-20230620234037996"></p>
<p><strong>1.模块接口测试</strong></p>
<p>对通过被测模块的数据流进行测试，检查进出模块的数据是否正确。</p>
<p>主要涉及以下几方面的内容：</p>
<blockquote>
<ol>
<li>模块接收输入的实际参数个数与模块的形式参数个数是否一致。</li>
<li>输入的实际参数与模块的形式参数的类型是否匹配。</li>
<li>输入的实际参数与模块的形式参数所使用单位是否一致。</li>
<li>调用其他模块时，所传送的实际参数个数与被调用模块的形式参数的个数是否相同。</li>
<li>调用其他模块时，所传送的实际参数与被调用模块的形式参数的类型是否匹配。</li>
<li>调用其他模块时，所传送的实际参数与被调用模块的形式参数的单位一致。</li>
<li>调用内部函数时，参数的个数、属性和次序是否正确。</li>
<li>在模块有多个入口的情况下，是否有引用与当前入口无关的参数。</li>
<li>是否会修改了只读型参数。</li>
<li>出现全局变量时，这些变量是否在所有引用它们的模块中都有相同的定义。</li>
<li>有没有把某些约束当做参数来传送。</li>
</ol>
</blockquote>
<p><strong>2.模块局部数据结构测试</strong></p>
<p>检查局部数据结构能否保持完整性.</p>
<p>主要涉及以下几方面的内容：</p>
<blockquote>
<ul>
<li>不正确或不一致的数据类型说明</li>
<li>变量没有初始化</li>
<li>变量名拼写错或书写错</li>
<li>数组越界</li>
<li>非法指针</li>
<li>全局数据对模块的影响</li>
</ul>
</blockquote>
<p><strong>3.模块独立执行路径测试</strong></p>
<p>对模块中重要的执行路径进行测试。检查由于计算错误、判定错误、控制流错误导致的程序错误。</p>
<p>Checklist：</p>
<blockquote>
<p>死代码</p>
<p>错误的计算优先级</p>
<p>精度错误（比较运算错误、赋值错误）</p>
<p>表达式的不正确符号</p>
<p>循环变量的使用错误</p>
</blockquote>
<p><strong>4.模块内部错误处理测试</strong></p>
<p>检查内部错误处理设施是否有效.</p>
<p>Checklist：</p>
<blockquote>
<p>是否检查错误出现</p>
<p>出现错误，是否进行错误处理</p>
<p>抛出错误、通知用户、进行记录</p>
<p>错误处理是否有效</p>
</blockquote>
<p><strong>5.模块边界条件测试</strong></p>
<p>检查临界数据是否正确处理</p>
<p>Checklist：</p>
<blockquote>
<p>普通合法数据是否正确处理</p>
<p>普通非法数据是否正确处理</p>
<p>边界内最接近边界的(合法)数据是否正确处理</p>
<p>边界外最接近边界的(非法)数据是否正确处理</p>
</blockquote>
<p>基本单元本身不是一个独立的程序，自己不能运行，要靠其它部分来调用和驱动。</p>
<p><strong>驱动模块 (Driver)</strong></p>
<p>被测基本单元的主程序，它接收测试数据，并把数据传送给被测单元，最后输出实测结果。</p>
<p><strong>桩模块 (Stub)</strong></p>
<p>用来代替被测基本单元调用的其他基本单元。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620234412084.png" alt="image-20230620234412084"></p>
<h2 id="2-集成测试">2.集成测试</h2>
<p>集成（Integration）是指把多个单元组合起来形成更大的单元.</p>
<p>一种旨在暴露单元接口之间、组件/系统间交互或协同工作时所存在的缺陷的测试。</p>
<p><strong>自底向上</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620235905695.png" alt="image-20230620235905695"></p>
<p><strong>自顶向下</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620235847225.png" alt="image-20230620235847225"></p>
<p><strong>大棒式</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620235924529.png" alt="image-20230620235924529"></p>
<p><strong>三明治</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621000013683.png" alt="image-20230621000013683"></p>
<p><strong>持续集成</strong></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621000027913.png" alt="image-20230621000027913"></p>
<p><strong>桩程序</strong></p>
<p>桩程序（Stub Program）是软件开发和测试中的一种技术，用于<strong>模拟或替代系统的某些组件或功能</strong>。它是一个简化版的程序或模块，用于提供预定义的响应和行为，以满足被测试系统或组件的需求。</p>
<p>桩程序通常用于以下情况：</p>
<ol>
<li>替代外部依赖：当被测试系统或组件依赖于外部系统、服务或模块时，桩程序可以模拟这些外部依赖的行为，以便进行独立的测试。例如，如果被测试系统需要与数据库进行交互，但在测试环境中无法访问实际的数据库，可以使用桩程序模拟数据库的响应。</li>
<li>模拟复杂场景：在某些情况下，测试特定的功能或场景可能非常复杂或困难。使用桩程序可以简化测试环境，模拟所需的条件和事件，以验证系统在不同情况下的行为。这有助于提高测试的可控性和可预测性。</li>
<li>并行开发：在软件开发过程中，不同的团队可能同时进行工作，并且某些模块或组件可能尚未完成或可用。使用桩程序可以替代尚未完成的组件，以便其他团队可以继续开发和测试其依赖项。</li>
</ol>
<p>桩程序可以根据需要提供不同的实现方式。它们可以是简单的占位符代码，只返回预定义的值或执行基本的操作，也可以是更复杂的模拟程序，具有特定的行为和逻辑。桩程序通常在测试环境中使用，并且与实际的系统或组件相互作用。</p>
<p>使用桩程序的好处包括：</p>
<ul>
<li>解耦测试环境：通过使用桩程序，测试环境可以与外部依赖解耦，减少测试的复杂性和依赖性。</li>
<li>提高测试效率：桩程序可以模拟特定的场景和条件，使测试更加可控和可重复，从而提高测试的效率。</li>
<li>并行开发：通过使用桩程序，可以使开发和测试团队可以并行工作，而不受尚未完成的组件的影响。</li>
</ul>
<p><strong>驱动程序</strong><br>
驱动程序（Driver）是一种计算机程序或模块，用于<strong>与硬件设备或操作系统进行通信和控制</strong>。它充当了软件与硬件之间的接口，使得应用程序能够与硬件设备交互并利用其功能。</p>
<p>驱动程序的主要功能包括：</p>
<ol>
<li>设备通信：驱动程序负责与硬件设备进行通信，发送指令和接收数据。它使用硬件接口和协议，以确保应用程序与设备之间的正确和可靠的通信。</li>
<li>硬件控制：驱动程序控制硬件设备的各种操作和功能。它可以发送配置参数、控制设备状态、执行特定的硬件操作等。</li>
<li>数据传输：驱动程序处理数据在应用程序和设备之间的传输。它可以负责数据的缓冲、转换和传输协议的实现。</li>
<li>错误处理：驱动程序处理硬件设备或通信错误。它可以检测和处理错误情况，并提供错误报告和恢复机制。</li>
</ol>
<p>驱动程序通常是特定硬件设备或操作系统的一部分，或者由硬件制造商提供。它们可以是操作系统内核的一部分，也可以作为独立的软件模块加载到操作系统中。驱动程序与操作系统紧密相关，需要与操作系统的版本和硬件架构相匹配。</p>
<p>在操作系统中，驱动程序的安装和配置通常由操作系统自动处理。当插入新的硬件设备时，操作系统会自动加载相应的驱动程序，并与设备建立连接和通信。在某些情况下，用户可能需要手动安装或更新驱动程序，以确保硬件设备的正常工作和兼容性。</p>
<h2 id="3-系统测试">3.系统测试</h2>
<p><strong>什么是系统测试？</strong></p>
<p>​	系统测试（System Testing）是软件测试的一种<code>阶段</code>，它旨在<strong>验证</strong>整个软件系统在符合需求和规格说明书的情况下的功能、性能、稳定性和可靠性。</p>
<p><strong>典型系统测试对象：</strong></p>
<p>l系统管理手册和用户操作手册；</p>
<p>l系统功能和非功能需求；</p>
<p>l系统中使用的数据。</p>
<p><strong>系统测试主要内容：</strong></p>
<ul>
<li>
<p>l用户界面测试</p>
</li>
<li>
<p>l安装/卸载测试</p>
</li>
<li>
<p>l文档测试</p>
</li>
<li>
<p>l 回归测试</p>
</li>
<li>
<p>l压力测试</p>
</li>
<li>
<p>l容量测试</p>
</li>
<li>
<p>l安全测试</p>
</li>
<li>
<p>l功能测试；</p>
</li>
<li>
<p>l性能测试；</p>
</li>
<li>
<p>l安全性测试。</p>
</li>
</ul>
<p><strong>系统测试策略</strong></p>
<ul>
<li>l手工测试；</li>
<li>l自动化测试。</li>
</ul>
<p><strong>系统测试的方法：</strong></p>
<ul>
<li>l黑盒测试方法</li>
</ul>
<p><strong>系统测试是在集成测试完成之后进行的，它对整个系统进行端到端的测试</strong>，以确保系统在各种情况下都能正常运行。系统测试主要关注以下方面：</p>
<ol>
<li>功能测试：验证系统的功能是否符合需求和规格说明书。测试人员会根据系统的功能规范和用例，逐个测试系统的各个功能模块，并检查其是否按照预期进行操作和产生正确的输出。</li>
<li>性能测试：评估系统在各种负载和压力下的性能表现。这包括测试系统的响应时间、吞吐量、并发性能、资源利用率等，并确保系统能够在预期的性能指标范围内运行。</li>
<li>安全性测试：检查系统的安全性，验证系统是否受到潜在的安全威胁，如身份验证、访问控制、数据加密等，并进行漏洞扫描和渗透测试，以确保系统的安全性和防护能力。</li>
<li>兼容性测试：验证系统在不同的操作系统、浏览器、设备和网络环境下的兼容性。测试人员会测试系统在各种平台上的运行情况，确保系统能够在不同环境下正常工作。</li>
<li>可靠性测试：评估系统的稳定性和可靠性。测试人员会模拟各种故障和异常情况，如断电、网络中断、数据丢失等，以确保系统能够正确处理和恢复。</li>
<li>用户界面测试：测试系统的用户界面是否友好、易用，并符合用户体验的设计原则。测试人员会检查界面的布局、交互性和响应性，并确保用户可以轻松地完成各项任务。</li>
<li>回归测试：在系统进行修改或更新后，重新运行之前的测试用例，以确保修改没有引入新的错误或导致现有功能的退化。</li>
</ol>
<h1>五、测试类型</h1>
<p>​	从测试目标的角度， 可以分为更多的测试类型，包括回归测试、 功能测试、 性能测试、 Alpha测试、Beta测试、 压力测试、 负载测试、 安全性测试、 配置测试、 安装测试、 可用性测试、 可恢复性测试等。</p>
<h2 id="1-接口测试">1.接口测试</h2>
<p>测试系统间接口的一种测试，测试的对象主要是接口，主要是测试外部系统与所测系统之间以及内部系统之间的交互点。</p>
<p><strong>原理:</strong></p>
<p>是通过<strong>测试程序模拟客户端向服务器发送请求报文</strong>，服务器接收请求报文后对相应的报文做出处理然后再把应答报文发送给客户端，客户端接收应答报文这一个过程。</p>
<p><strong>目的：</strong></p>
<p>测试接口的正确性和稳定性（持续集成是接口测试的核心）。</p>
<p><strong>内容：</strong></p>
<p><strong>单一接口测试</strong>主要测试的是输入输出值，一些具有业务意义的值需要特别测试（例如，1和2分别代表两个测试场景，那么就不能够把他们看成是等价类，需要分开测试</p>
<p><strong>组合接口测试</strong>主要是通过组合多个单一接口，来测试一个业务场景</p>
<p>Example：测试购物网站的一个下单的功能，那么因为在下单之前还有一些流程，所以要测试一个场景。</p>
<p>测试：搜索商品 --&gt; 选中商品 --&gt; 添加进购物车 --&gt; 提交订单 --&gt;支付（提交订单时还涉及到地址的选取等）</p>
<p>[注：涉及到如果使用从cookie或者session在本例中的区别：如果使用cookie加入购物车，那么换一台电脑购物车里的商品就不存在了，但如果使用的是session，购物车里面的东西就一直存在，即：cookie是本机作用的，session不止于本机作用</p>
<p><strong>结构检查</strong></p>
<p>（1）检查返回值的结构是否正确，如是json类型还是xml类型的数据</p>
<p>（2）字段名称是否正确等</p>
<p><strong>HTTP</strong>：</p>
<p><strong>HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。</strong></p>
<p>HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。</p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003305627.png" alt="image-20230621003305627"></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003417932.png" alt="image-20230621003417932"></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描  述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>GET</td>
<td>请求读取一个Web页面</td>
</tr>
<tr>
<td>2</td>
<td>HEAD</td>
<td>请求读取一个Web页面的首部</td>
</tr>
<tr>
<td>3</td>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>请求存储一个Web页面</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>删除Web页面</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003512949.png" alt="image-20230621003512949"></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003529343.png" alt="image-20230621003529343"></p>
<p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003550668.png" alt="image-20230621003550668"></p>
<h2 id="2-性能测试">2.性能测试</h2>
<p>虽然强度测试、压力测试和负载测试在软件测试领域都与系统性能相关，但它们的重点和目标略有不同。下面是它们的区别：</p>
<ol>
<li><strong>强度测试（Stress Testing）</strong>：
<ul>
<li>目标：评估系统在超出正常工作负载条件下的性能和稳定性。</li>
<li>重点：测试系统在负载超出设计限制时的表现和反应。</li>
<li>方法：将系统暴露在高负载、极限条件下，并持续施加压力。</li>
<li>目的：识别系统在高负载条件下的性能瓶颈、资源耗尽、内存泄漏等问题。</li>
</ul>
</li>
<li><strong>压力测试（Load Testing）</strong>：
<ul>
<li>目标：评估系统在正常工作负载下的性能和稳定性。</li>
<li>重点：测试系统在正常负载下的性能指标，如响应时间、吞吐量等。</li>
<li>方法：模拟实际用户的并发访问，并逐渐增加负载，观察系统的性能表现。</li>
<li>目的：确定系统的瓶颈、性能指标，并保证系统在正常负载下的可靠性和性能要求。</li>
</ul>
</li>
<li><strong>负载测试（Load Testing）：</strong>
<ul>
<li>目标：评估系统在不同工作负载条件下的性能和稳定性。</li>
<li>重点：测试系统在不同负载级别下的性能表现和资源消耗情况。</li>
<li>方法：通过模拟多个并发用户或大量数据处理等操作，施加不同的负载。</li>
<li>目的：确定系统在不同负载情况下的性能瓶颈、资源需求和系统行为。</li>
</ul>
</li>
</ol>
<p>总结来说，强度测试主要关注系统在超出设计限制的极限负载下的表现，压力测试关注系统在正常工作负载下的性能指标，而负载测试则在不同负载级别下评估系统的性能和资源消耗情况。这些测试方法的目的都是为了确保系统在不同负载条件下的可靠性、稳定性和性能要求。</p>
<hr>
<p><strong>性能测试</strong>是一种软件测试方法，用于评估系统、应用程序或组件在不同负载条件下的性能表现。其目的是测量系统的响应时间、吞吐量、并发性能和稳定性，以确定系统在实际使用情况下的性能是否符合预期。</p>
<p>性能测试涉及模拟和测量系统在不同负载条件下的行为，并收集相关指标以评估系统性能。以下是一些常见的性能测试指标：</p>
<ol>
<li>
<p><strong>响应时间（Response Time）：</strong> 衡量系统对请求作出响应的时间。它是从发送请求到接收到响应所经过的时间。较短的响应时间表示系统快速响应用户请求。</p>
</li>
<li>
<p><strong>吞吐量（Throughput）：</strong> 衡量系统在单位时间内能够处理的请求数量。它表示系统的处理能力和效率。较高的吞吐量表示系统可以处理更多的请求。</p>
</li>
<li>
<p><strong>并发用户数（Concurrency）：</strong> 表示同时使用系统的用户数量。它用于评估系统在高并发情况下的性能表现。</p>
</li>
<li>
<p><strong>负载测试（Load Testing）：</strong> 在正常或预期的工作负载条件下，测试系统的性能表现。负载测试通常模拟实际用户数量，并观察系统在此负载下的响应时间和吞吐量。</p>
</li>
<li>
<p><strong>压力测试（Stress Testing）：</strong> 将系统推至其负载极限，并观察系统在此负载下的性能表现。压力测试旨在评估系统在高负载条件下的稳定性和性能。</p>
</li>
<li>
<p><strong>稳定性测试（Stability Testing）：</strong> 在长时间运行的情况下，测试系统的性能和稳定性。它可以检测系统是否存在内存泄漏、资源耗尽等问题。</p>
</li>
<li>
<p><strong>资源利用率（Resource Utilization）：</strong> 测量系统在运行过程中使用的资源，如 CPU、内存、网络带宽等。资源利用率指标可以帮助评估系统的效率和性能。</p>
</li>
<li>
<p><strong>容量规划（Capacity Planning）：</strong> 根据系统的性能测试结果和预期的用户需求，规划系统所需的硬件、网络和资源配置，以确保系统能够满足未来的用户需求。</p>
</li>
</ol>
<p>这些指标和概念在性能测试中起着重要的作用，帮助评估系统的性能表现、发现性能瓶颈和优化系统性能。根据具体的测试目标和需求，可以选择适当的指标进行性能测试，并根据测试结果进行系统优化和调整。</p>
<hr>
<p><strong>压力测试：</strong></p>
<p>​	压力测试（Stress Testing）是一种软件测试方法，旨在<strong>评估系统在负载增加的情况下的稳定性、性能和可靠性</strong>。压力测试通过模拟大量用户并在系统处于高负载状态下执行各种操作，以确定系统的性能极限、响应时间和资源利用情况。</p>
<p>在进行压力测试时，通常会使用以下方法和技术：</p>
<ol>
<li>定义测试场景：确定测试的目标、范围和关注点，制定测试计划和测试策略。</li>
<li>设置负载：创建并模拟大量用户，并在系统上执行各种操作，如并发访问、大量数据处理、频繁的请求等，以增加系统的负载。</li>
<li>监测系统指标：监测系统的性能指标，如响应时间、吞吐量、并发用户数、CPU和内存使用情况等。</li>
<li>分析和评估结果：根据监测到的指标和性能数据，分析系统在不同负载下的表现，确定性能瓶颈和潜在问题。</li>
</ol>
<p>压力测试的目标包括：</p>
<ul>
<li>确定系统的性能极限：通过逐渐增加负载，测试系统在负载达到极限时的性能表现，以确定系统的容量和稳定性。</li>
<li>发现性能瓶颈：通过分析系统在高负载下的性能指标，确定系统中的瓶颈点和性能瓶颈，以便进行优化和改进。</li>
<li>评估系统的可靠性：测试系统在高负载和压力下的稳定性和可靠性，发现潜在的问题和风险，并确保系统能够正常运行。</li>
<li>验证系统的扩展性：通过测试系统在不同负载下的性能，评估系统在未来的扩展和增长中的可行性和可扩展性。</li>
</ul>
<p>压力测试可以帮助发现系统在高负载下的性能瓶颈、资源消耗过度、响应时间延迟等问题，并提供有关系统容量规划和优化改进的重要信息。它对于确保系统在真实使用情况下的稳定性和可靠性非常重要。</p>
<p><strong>负载测试：</strong></p>
<p>​	负载测试（Load Testing）是一种测试方法，旨在评估系统在正常和峰值负载条件下的性能和稳定性。它主要关注<strong>系统在高负载情况下</strong>的<strong>响应时间、吞吐量、并发用户数以及系统资源的利用情况</strong>。</p>
<p>负载测试的目标是确定系统在预期工作负载下的性能限制和瓶颈，并验证系统是否能够满足预期的性能要求。通过负载测试，可以识别和解决性能问题，提高系统的可靠性、稳定性和可扩展性。</p>
<p>在进行负载测试时，通常会模拟真实的用户行为和交互，并通过生成虚拟用户或并发请求来模拟负载条件。测试工具和框架可用于自动化执行负载测试，并提供性能指标和报告，以帮助评估系统的性能表现。</p>
<p>以下是负载测试的一些关键方面：</p>
<ol>
<li>
<p>负载模型：定义和创建合适的负载模型，以模拟真实世界中的用户行为和交互。这包括模拟用户数量、并发请求、事务处理量等。</p>
</li>
<li>
<p>性能指标：定义和监测关键性能指标，如响应时间、吞吐量、并发用户数、错误率等。这些指标可以帮助评估系统的性能表现，并与预期的性能要求进行比较。</p>
</li>
<li>
<p>测试环境：准备适当的测试环境，包括硬件、网络、数据库和应用程序配置。测试环境应尽可能接近生产环境，以确保准确的性能评估。</p>
</li>
<li>
<p>负载生成工具：使用适当的负载生成工具来模拟并发请求和用户行为。这些工具可以帮助生成大量的虚拟用户，以模拟真实的负载条件。</p>
</li>
<li>
<p>分析和优化：分析负载测试结果，识别性能瓶颈和问题，并提出相应的优化建议。这可以包括系统配置调整、代码优化、资源调整等措施。</p>
</li>
</ol>
<p>通过负载测试，可以发现系统在高负载条件下的性能瓶颈和问题，帮助团队制定性能改进计划，并确保系统在真实环境中的稳定性和可靠性。</p>
<p><strong>强度测试：</strong></p>
<p>​	强度测试（Stress Testing）是一种测试方法，旨在评估系统在<strong>超出正常工作负载条件下的性能和稳定性</strong>。它主要关注系统在极限负载和资源耗尽的情况下的行为和反应。</p>
<p>强度测试的目标是确定系统在负载超出其设计限制时的表现，验证系统的可靠性、稳定性和恢复能力。通过强度测试，可以识别系统在高负载条件下的性能瓶颈、资源耗尽、内存泄漏等问题，并采取相应的措施进行优化和改进。</p>
<p>在进行强度测试时，会将系统暴露在高负载、极限条件下，并持续施加压力，以测试系统的极限和边界情况。这可能包括同时启动大量的并发请求、增加数据量、模拟网络延迟等。</p>
<p>以下是强度测试的一些关键方面：</p>
<ol>
<li>
<p>负载模型：定义和创建具有极限负载的负载模型，以模拟系统在超出正常工作负载的情况下的行为。这包括模拟大量的并发用户、大量的数据处理、高频率的请求等。</p>
</li>
<li>
<p>资源监测：监测系统资源的使用情况，包括内存、CPU、磁盘、网络等。通过监测资源的消耗情况，可以确定系统在高负载条件下是否存在资源耗尽的问题。</p>
</li>
<li>
<p>容错和恢复能力：测试系统在遇到异常情况或资源耗尽时的容错和恢复能力。这包括测试系统的崩溃恢复、错误处理机制、故障转移等能力。</p>
</li>
<li>
<p>性能指标：定义和监测关键性能指标，如响应时间、吞吐量、错误率等。这些指标可以帮助评估系统在极限负载下的性能表现，并与预期的性能要求进行比较。</p>
</li>
<li>
<p>容量规划：根据强度测试的结果，评估系统的容量和扩展需求。这可以帮助团队确定系统的极限容量，以及在面临更高负载时需要采取的扩展措施。</p>
</li>
</ol>
<p>通过强度测试，可以评估系统在负载极限情况下的表现，发现潜在的性能瓶颈和问题，并采取相应的优化和改进措施，以确保系统在极限条件下的可靠性和稳定性。</p>
<hr>
<ol>
<li><strong>链接测试（Link Testing）：</strong> 链接测试主要关注软件内部各个模块之间的链接和交互。它确保软件在模块集成时，各个模块之间的接口和依赖关系正常工作。链接测试通常是软件开发过程中的一部分，以验证模块之间的正确连接和通信。</li>
<li><strong>兼容性测试（Compatibility Testing）：</strong> 兼容性测试是验证软件在不同环境、平台或配置下的兼容性和互操作性。它确保软件能够在不同的操作系统、浏览器、设备或网络条件下正常运行，并且与其他软件或硬件组件协同工作。兼容性测试有助于确保软件具有广泛的适用性和稳定性。</li>
<li><strong>性能测试（Performance Testing）：</strong> 性能测试评估软件在特定负载和压力条件下的性能表现。它包括测量响应时间、吞吐量、并发用户数和资源利用率等指标，以确定系统的性能瓶颈、瓶颈原因和优化需求。性能测试旨在确保软件在实际使用情况下具有良好的性能和可伸缩性。</li>
<li><strong>安全测试（Security Testing）：</strong> 安全测试旨在评估软件的安全性和防护能力。它涉及识别和验证软件中的潜在安全漏洞、弱点和威胁。安全测试可以包括网络漏洞扫描、身份验证和授权测试、数据加密和防御测试等。通过安全测试，可以发现和修复潜在的安全风险，保护软件和用户的数据安全。</li>
</ol>
<h2 id="3-渗透测试"><strong>3.渗透测试</strong></h2>
<p>​	渗透测试，也被称为漏洞评估或白帽黑客测试，是一种旨在评估计算机系统、网络或应用程序的安全性的测试方法。</p>
<p>​	渗透测试的目标是<strong>模拟真实的黑客攻击</strong>，以发现系统中的漏洞、弱点和安全风险，并提供有关如何修复这些问题的建议。</p>
<blockquote>
<p>渗透测试的目标是模拟真实的黑客攻击，以发现系统中的漏洞、弱点和安全风险，并提供有关如何修复这些问题的建议。渗透测试通常包括以下步骤：</p>
<ol>
<li>信息收集：收集有关目标系统的信息，例如网络拓扑、IP地址范围、域名、系统版本和服务等。这可以通过公开可用的信息、网络扫描工具和漏洞数据库等来完成。</li>
<li>漏洞扫描：使用自动化工具进行漏洞扫描，以发现目标系统中存在的已知漏洞。这些工具会检查系统中的常见漏洞、配置错误和安全弱点。</li>
<li>漏洞利用：通过利用已知漏洞或弱点，尝试进一步渗透目标系统。这可能涉及使用特定的工具或编写自定义脚本来利用系统中的漏洞。</li>
<li>权限提升：在成功进入目标系统后，试图提升权限以获得更高级别的访问权限。这可以通过提取密码、利用系统配置错误或操纵用户权限等方式来实现。</li>
<li>横向移动：如果目标系统是一个网络环境，渗透测试人员可能试图在网络中横向移动，获取对其他系统和资源的访问权限。</li>
<li>数据获取：在渗透测试过程中，收集有关系统和应用程序的详细信息，包括发现的漏洞、弱点和可能的攻击路径。</li>
<li>报告编写：根据渗透测试的结果，编写详细的报告，包括发现的漏洞、成功渗透的路径、潜在的风险和建议的修复措施。</li>
</ol>
<p>渗透测试需要具备深入的计算机和网络知识，以及对常见漏洞和攻击技术的理解。它有助于组织和企业评估其系统的安全性，并采取适当的措施来保护其敏感数据和资产免受潜在的黑客攻击。渗透测试通常由专门的安全团队或第三方安全公司执行，以提供客观和独立的评估结果。</p>
</blockquote>
<h2 id="4-回归测试">4.<strong>回归测试</strong></h2>
<p>​	回归测试（Regression Testing）是在<strong>对软件进行更改或修复后</strong>，<strong>重新运行既有测试用例</strong>以确保已有功能没有受到影响的过程。其目的是验证修改后的软件在进行更改的同时仍然保持原有功能的正确性。</p>
<blockquote>
<p>回归测试的主要目标是检测已有功能是否被破坏或受到不良影响，并帮助保证软件在修改后仍然能够按照预期进行工作。以下是回归测试的一些关键特点和目的：</p>
<ol>
<li>验证修改的影响：当进行软件修改、增加新功能或修复缺陷时，回归测试旨在验证这些修改对现有功能的影响。通过重新运行既有的测试用例，可以确定是否引入了新的问题或导致现有功能的故障。</li>
<li>防止功能退化：回归测试可以帮助检测功能退化的情况。功能退化是指在进行软件修改时，原本正常工作的功能因修改而变得不可用或产生错误。通过回归测试，可以确保软件的核心功能在修改后仍然正常运行。</li>
<li>确保软件稳定性：回归测试对于确保软件的稳定性和可靠性非常重要。通过重新运行测试用例，可以及时发现和解决引入的错误，从而提高软件的质量和可靠性。</li>
<li>提高软件维护效率：通过回归测试，可以快速定位和解决修改引起的问题。它可以帮助缩短故障修复的时间，减少维护成本，并提高团队的工作效率。</li>
</ol>
<p>回归测试可以采用不同的方法和技术，包括自动化测试和手工测试。自动化回归测试可以利用测试工具和脚本来执行测试用例，并快速发现问题。手工回归测试则需要测试人员手动运行测试用例并检查结果。</p>
<p>回归测试的频率和范围取决于项目的具体情况和变更的规模。一般来说，较小的变更可能只需要执行部分回归测试，而较大的变更可能需要执行全面的回归测试。</p>
<p>总之，回归测试是软件开发过程中不可或缺的一部分，它有助于保证软件质量、稳定性和可靠性，同时提高团队的工作效率和客户满意度。</p>
</blockquote>
<h2 id="5-α测试">5.<strong>α测试</strong></h2>
<p>​	α测试（Alpha Testing）是软件开发过程中的一种测试方法，旨在在软件开发的早期阶段，由<strong>开发团队内部或有限的用户群体</strong>进行测试。它通常在软件开发的内部环境中进行，以发现和解决潜在的问题和缺陷。</p>
<blockquote>
<p>​	α测试的主要目标是评估软件在功能、性能和稳定性等方面的整体质量，并提供反馈和建议以改进软件。以下是α测试的一些关键特点和目的：</p>
<ol>
<li>内部测试：α测试是由开发团队内部或特定的用户群体进行的测试，而不是广泛发布给所有最终用户。这使得测试团队能够在一个受控的环境中进行测试，并快速获取用户的反馈。</li>
<li>功能测试：α测试主要关注软件的功能性。测试团队会根据软件的规格说明和设计文档执行测试用例，以验证软件的功能是否按照预期工作。</li>
<li>性能测试：除了功能性测试，α测试也可以涉及对软件性能的初步评估。测试团队可以检查软件的响应时间、资源利用情况和容错性能等方面，以确保软件在预期的负载和环境条件下正常运行。</li>
<li>缺陷发现：α测试旨在发现潜在的问题和缺陷。测试团队会记录并报告发现的问题，并与开发团队合作解决这些问题。这有助于提高软件的质量和稳定性。</li>
<li>用户反馈：α测试也为测试团队提供了与用户进行直接交流和反馈的机会。用户可以提供对软件的使用体验、界面设计、功能需求等方面的意见和建议，以帮助改进软件。</li>
</ol>
<p>尽管α测试是在软件开发的早期阶段进行的，但它并不代表最终的软件质量。它是一个重要的测试阶段，旨在帮助发现和解决问题，并为软件的后续测试和改进提供反馈。</p>
<p>需要注意的是，α测试通常与β测试相互补充。α测试是在内部环境中进行的，而β测试是在真实用户环境中进行的，以获取更广泛的用户反馈。</p>
</blockquote>
<h2 id="6-s测试"><strong>6.ß测试</strong></h2>
<p>​	β测试（Beta Testing）是软件开发过程中的一种测试方法，它是在软件开发的后期阶段，将软件<strong>提供给真实用户</strong>进行测试和评估。β测试的目的是验证软件在真实环境中的功能、性能、兼容性和稳定性，并收集用户的反馈意见。</p>
<blockquote>
<p>以下是β测试的一些关键特点和目的：</p>
<ol>
<li>外部测试：β测试是在真实用户群体中进行的测试，将软件提供给最终用户使用并收集他们的反馈。这种测试方法可以帮助开发团队了解用户的真实需求和使用体验。</li>
<li>真实环境测试：β测试将软件放置在真实的操作环境中进行测试，以确保软件能够适应不同的硬件、操作系统和网络条件。这有助于发现和解决与特定环境相关的问题。</li>
<li>多样性测试：β测试涉及多种类型的测试，包括功能测试、性能测试、兼容性测试和用户体验测试等。测试团队会执行一系列测试用例，以验证软件在各个方面的表现。</li>
<li>用户反馈：β测试的一个重要目标是收集用户的反馈意见和建议。用户可以报告发现的问题、提出改进建议，甚至分享他们的使用体验和感受。这些反馈对于改进软件并满足用户需求至关重要。</li>
<li>验证功能：β测试还用于验证软件是否满足规格说明和用户需求。测试团队会核对软件的功能是否按照预期工作，并确保软件的稳定性和可靠性。</li>
</ol>
<p>β测试通常是在软件开发的最后一个阶段进行的，当软件已经具备一定的功能和稳定性时，才将其提供给用户进行测试。通过β测试，开发团队可以收集大量真实用户的反馈意见，从而改进软件，并确保它的质量和用户满意度。</p>
<p>需要注意的是，β测试不是软件发布的最终阶段。在β测试之后，可能还会进行修复和改进，以解决发现的问题，并进一步提高软件的质量。</p>
</blockquote>
<p><strong>性能测试概念，性能测试指标</strong></p>
<p>性能测试的指标用于<strong>评估系统在特定负载条件下的性能表现</strong>。下面是一些常见的性能测试指标：</p>
<ol>
<li>
<p>响应时间（Response Time）：系统处理请求所花费的时间，通常以毫秒为单位。响应时间是衡量系统性能的重要指标，较短的响应时间表示系统响应速度快。</p>
</li>
<li>
<p>吞吐量（Throughput）：系统单位时间内处理的请求数量。吞吐量反映了系统在一定时间内处理能力的大小，较高的吞吐量表示系统能够处理更多的请求。</p>
</li>
<li>
<p>并发用户数（Concurrent Users）：系统同时处理的用户数量。并发用户数反映了系统在同时处理多个用户请求时的性能表现，较高的并发用户数表示系统具有更好的并发处理能力。</p>
</li>
<li>
<p>服务器资源利用率（Server Resource Utilization）：系统在负载条件下的服务器资源利用情况，包括 CPU 使用率、内存占用、网络带宽利用率等。服务器资源利用率反映了系统在高负载情况下的资源消耗情况，可以帮助确定系统的扩展需求。</p>
</li>
<li>
<p>错误率（Error Rate）：系统在处理请求过程中出现错误的比例。错误率反映了系统在高负载条件下的稳定性和可靠性，较低的错误率表示系统的稳定性较高。</p>
</li>
<li>
<p>平均并发时间（Mean Time to Concurrency）：系统从接收请求到开始处理请求的平均时间。平均并发时间反映了系统在高负载条件下的响应速度，较短的平均并发时间表示系统可以迅速处理请求。</p>
</li>
<li>
<p>可扩展性（Scalability）：系统在增加负载时能否保持稳定的性能表现。可扩展性反映了系统在负载增加时的性能表现和资源利用情况，较好的可扩展性意味着系统能够有效地应对负载增加。</p>
</li>
</ol>
<p>以上是一些常见的性能测试指标，具体选择和关注哪些指标应根据系统特点、用户需求和测试目的进行确定。不同的应用场景可能会有不同的重点指标，因此在进行性能测试时需要结合实际情况进行评估和分析。</p>
<h1>六、测试手段</h1>
<p>从测试执行方式的角度， 可以分为手动测试、 自动化测试和半自动化测试。</p>
<p><strong>自动化测试与手工测试的区别：</strong></p>
<ol>
<li><strong>执行方式：</strong> 自动化测试是通过编写脚本、使用自动化工具或框架来执行测试过程，而手工测试是由测试人员手动执行测试步骤。</li>
<li><strong>效率和速度：</strong> 自动化测试相对于手工测试可以更快地执行测试用例，因为测试脚本可以自动化地重复执行，节省了大量的时间和人力资源。</li>
<li><strong>重复性：</strong> 自动化测试可以重复执行相同的测试用例，确保每次测试的一致性，而手工测试容易受到人为因素的影响，每次执行结果可能不同。</li>
<li><strong>覆盖范围：</strong> 自动化测试通常用于执行大规模的测试用例集合，可以覆盖更广泛的功能和场景，而手工测试更适用于少量、复杂或需要人工判断的测试用例。</li>
<li><strong>可靠性：</strong> 自动化测试执行的结果更可靠，因为测试脚本不会受到人为错误的影响，而手工测试可能存在人为疏漏或误操作的风险。</li>
<li><strong>适用性：</strong> 自动化测试适用于稳定的功能和场景，例如回归测试；而手工测试适用于新功能的探索、用户体验测试和复杂的场景模拟。</li>
<li><strong>成本和投入：</strong> 自动化测试需要一定的时间和资源来编写和维护测试脚本，因此在初期投入较高；而手工测试相对较低成本，但在长期和重复的测试过程中，手工测试的成本会逐渐增加。</li>
</ol>
<h2 id="1-手工测试"><strong>1.手工测试</strong></h2>
<p>手工测试（Manual Testing）是一种软件测试方法，通过<strong>人工执行测试用例</strong>来验证软件系统的功能、性能、用户界面和其他方面的正确性和质量。与自动化测试相对，手工测试不依赖于自动化工具或脚本，而是由测试人员直接进行操作和观察。</p>
<blockquote>
<p>手工测试通常包括以下步骤：</p>
<ol>
<li>需求分析：测试人员仔细阅读软件需求文档、设计文档或用户故事，了解系统的功能和预期行为。</li>
<li>测试计划编制：测试人员根据需求和项目要求，制定测试策略和测试计划。测试计划包括测试范围、测试目标、测试资源和时间安排等内容。</li>
<li>测试用例设计：根据需求和设计文档，测试人员编写测试用例，描述测试步骤、输入数据和预期结果。测试用例应覆盖系统的各个功能和场景。</li>
<li>环境准备：测试人员设置测试环境，包括安装软件、配置系统和准备测试数据等。</li>
<li>执行测试用例：测试人员按照测试计划和测试用例的要求，手动执行测试用例。他们将输入测试数据、操作用户界面、触发系统功能，并观察系统的响应和结果。</li>
<li>缺陷报告：如果测试中发现了问题、错误或缺陷，测试人员会编写缺陷报告，详细描述缺陷的现象、重现步骤和影响程度。他们可能还会提供截图或录屏作为证据。</li>
<li>缺陷跟踪和验证：测试人员与开发团队或质量保障团队合作，跟踪缺陷的修复进度，并进行验证测试，确保缺陷得到正确修复。</li>
<li>回归测试：当缺陷修复后，测试人员可能需要执行回归测试，验证修复后的系统是否仍然正常工作，并确保修复过程没有引入新的问题。</li>
</ol>
<p>手工测试的优点包括灵活性、适应性和直观性。测试人员可以根据实际情况进行测试，并直接观察和评估软件的行为和用户体验。然而，手工测试可能比较耗时和繁琐，特别是对于大型和复杂的软件系统。因此，在某些情况下，自动化测试可以提供更高效和可重复的测试方法。</p>
<p>手工测试和自动化测试通常是结合使用的，根据具体的测试需求和资源限制，选择合适的测试方法和工具进行软件测试，以确保软件的质量和稳定性。</p>
</blockquote>
<h2 id="2-自动化测试"><strong>2.自动化测试</strong></h2>
<p>​	自动化测试（Automated Testing）是一种使用<strong>自动化工具或脚本来执行</strong>测试任务和验证软件系统的方法。与手工测试相比，自动化测试使用编写的脚本或测试工具来代替人工操作，从而提高测试效率、减少人为错误，并支持反复执行测试用例。</p>
<p>​	自动化测试可以应用于不同层次和类型的软件测试，包括单元测试、集成测试、系统测试和回归测试等。它可以涵盖功能测试、性能测试、安全测试和界面测试等不同方面的测试需求。</p>
<blockquote>
<p>以下是自动化测试的一些关键特点和优势：</p>
<ol>
<li>提高测试效率：自动化测试可以快速执行大量的测试用例，比手工测试更高效。测试人员可以节省大量的时间和精力，特别是在需要频繁执行回归测试的场景下。</li>
<li>降低人为错误：自动化测试消除了人为操作中的错误和遗漏。脚本和工具可以准确地模拟用户操作，避免了手工测试中可能出现的疏忽和错误。</li>
<li>可重复性和一致性：自动化测试可以确保测试过程的一致性和可重复性。相同的测试用例可以在不同的环境中重复执行，确保测试结果的一致性。</li>
<li>提高覆盖率：自动化测试可以实现更广泛的测试覆盖，包括各种边界条件、异常情况和不同的测试场景。通过编写多样化的测试脚本，可以更全面地覆盖软件系统的功能和特性。</li>
<li>提高质量和稳定性：自动化测试可以更早地发现和报告问题、错误和缺陷。它可以帮助团队更快速地进行修复和验证，提高软件系统的质量和稳定性。</li>
</ol>
<p>自动化测试也有一些考虑因素和限制：</p>
<ol>
<li>技术要求：自动化测试通常需要具备一定的编程和脚本编写能力。测试人员需要熟悉测试工具和相关技术，以便有效地编写和维护测试脚本。</li>
<li>初始投入和维护成本：自动化测试需要一定的初始投入和开发时间。编写和维护测试脚本可能需要额外的资源和成本，特别是在项目早期或需求频繁变更的情况下。</li>
<li>无法涵盖所有测试情况：自动化测试不能涵盖所有可能的测试情况和使用场景。某些测试任务可能需要手工测试来进行人工观察和评估。</li>
<li>界面和用户体验测试：某些测试类型，如用户界面测试和用户体验测试，可能需要人工操作和主观评估，无法完全自动化。</li>
</ol>
<p>综上所述，自动化测试在软件测试中具有重要的作用，并且可以带来许多优势。然而，在实施自动化测试之前，需要仔细评估测试需求、项目资源和技术能力，以确定何时和如何使用自动化测试工具和方法。</p>
</blockquote>
<hr>
<p><strong>自动化测试的模型、数据驱动的原理</strong>：</p>
<ol>
<li>
<p><strong>自动化测试的模型：</strong><br>
自动化测试的模型是指在进行自动化测试时所采用的框架或模式，用于<strong>组织和管理测试用例、执行测试、生成测试报告等</strong>。常见的自动化测试模型包括线性模型、模块化模型和关键字驱动模型。</p>
<ul>
<li>线性模型：按照线性的顺序执行测试用例，适用于简单的测试场景。</li>
<li>模块化模型：将测试用例拆分为模块或功能，并组织成模块化的结构，便于维护和复用。</li>
<li>关键字驱动模型：将测试用例和测试步骤定义为关键字，并通过关键字的组合和参数化实现测试执行，提高测试的灵活性和可维护性。</li>
</ul>
<p>不同的自动化测试模型适用于不同的测试需求和项目特点，选择合适的模型可以提高自动化测试的效率和可靠性。</p>
</li>
<li>
<p><strong>数据驱动的原理：</strong><br>
数据驱动测试是一种测试方法，它基于<strong>不同的测试数据对系统进行测试</strong>，以验证系统在<strong>不同数据输入下的行为和结果</strong>。数据驱动测试的原理是将测试用例和测试数据分离，将测试数据从测试用例中独立出来，以实现更广泛的测试覆盖和更高的可维护性。</p>
<p>数据驱动测试的关键是将测试数据从测试逻辑中抽离，通常使用外部数据源（如Excel、CSV文件、数据库等）来存储测试数据。测试用例通过读取数据源中的测试数据，进行参数化的测试执行。这样做的好处是可以通过修改数据源中的测试数据，实现快速修改和扩展测试用例，而无需修改测试逻辑。</p>
<p>数据驱动测试的优势在于可以更全面地覆盖不同的测试场景，减少了测试用例的重复编写，提高了测试效率和可维护性。同时，数据驱动测试也使得测试数据的管理更加灵活，方便进行数据的维护和更新。</p>
</li>
</ol>
<p>总结起来，自动化测试的模型是指用于组织和管理测试用例的框架或模式，而数据驱动的原理是将测试数据与测试用例分离，通过外部数据源实现参数化的测试执行。这两个概念在自动化测试中常常结合使用，以提高测试的效率、灵活性和可维护性。</p>
<hr>
<h1>五、应用题</h1>
<h2 id="1-路径测试">1.路径测试</h2>
<p>（根据流程图画出控制流图，计算环形复杂度，写出基本路径即合，设计测试用例）。</p>
<h2 id="2-逻辑覆盖测试">2.逻辑覆盖测试</h2>
<p>（根据程序逻辑结构，设计满足覆盖要求的测试用例（代码发覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖））。</p>
<h2 id="3-黑盒测试">3.黑盒测试</h2>
<p>（因果图测试法、决策表法、场景法、等价类划分）</p>
<h2 id="4-系统测试">4.系统测试</h2>
<p>（链接测试、兼容性测试、性能测试、安全测试）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">GiyaYon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://giyayonlib.com/2023/07/01/软件测试基础/">http://giyayonlib.com/2023/07/01/软件测试基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2023/05/15/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%A4%A7%E5%85%A8%E6%95%B4%E7%90%86/"><span>常用网络协议整理</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2023 By GiyaYon</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>