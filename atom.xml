<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GiyaYon&#39;s Blog</title>
  
  
  <link href="http://giyayonlib.com/atom.xml" rel="self"/>
  
  <link href="http://giyayonlib.com/"/>
  <updated>2023-07-01T12:01:50.159Z</updated>
  <id>http://giyayonlib.com/</id>
  
  <author>
    <name>GiyaYon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试作业相关</title>
    <link href="http://giyayonlib.com/2023/07/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://giyayonlib.com/2023/07/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-01T11:35:02.789Z</published>
    <updated>2023-07-01T12:01:50.159Z</updated>
    
    <content type="html"><![CDATA[<h1>一、软件测试相关概念</h1><p>不同角度的测试分类</p><p>（1） 从测试阶段或对象的角度， 可以分为<code>单元测试</code>、<code>集成测试</code>、 <code>系统测试</code>和<code>验收测试</code>；</p><p>（2） 从测试技术的角度， 可以分为<code>黑盒测试</code>、 <code>白盒测试</code>和<code>灰盒测试</code>；</p><p>（3） 从测试目标的角度， 可以分为更多的测试类型，包括<code>回归测试</code>、 <code>功能测试</code>、 <code>性能测试</code>、 <code>Alpha测试</code>、<code>Beta测试</code>、 <code>压力测试</code>、 <code>负载测试</code>、 <code>安全性测试</code>、 <code>配置测试</code>、 <code>安装测试</code>、<code> 可用性测试</code>、 <code>可恢复性测试</code>等。</p><p>（4） 从测试执行方式的角度， 可以分为<code>手动测试</code>、 <code>自动化测试</code>和<code>半自动化测试</code>。</p><h2 id="1-软件测试">1.<strong>软件测试</strong></h2><p>​软件测试是指对软件系统进行验证和验证的过程，以确定其是否满足指定的要求、预期的功能和性能。它涉及执行软件应用程序或系统的各个部分的检查和评估，以发现潜在的错误、缺陷和问题。</p><h2 id="2-软件质量">2.<strong>软件质量</strong></h2><p>​软件质量是指软件在其整个生命周期内满足用户需求和预期的程度。它是衡量软件产品的可靠性、可用性、性能、安全性和符合性的指标。</p><blockquote><p>软件质量是一个多维度的概念，涵盖了以下几个方面：</p><ol><li>功能性：软件是否按照用户需求和规格说明书的要求提供所需的功能。</li><li>可靠性：软件在特定环境下的稳定性和可靠性，即软件在长时间运行和处理异常情况时的表现。</li><li>易用性：软件是否易于使用，用户界面是否友好，用户能否轻松学习和操作软件。</li><li>性能：软件在给定条件下的执行速度、响应时间、吞吐量和资源利用率等方面的表现。</li><li>可维护性：软件是否易于维护和修改，包括代码的可读性、模块化、可扩展性和文档的完整性。</li><li>安全性：软件的抵御潜在威胁和保护数据的能力，包括防止未经授权访问、数据保密性和完整性等方面。</li><li>兼容性：软件在不同操作系统、平台和设备上的兼容性，能否正常运行和与其他系统进行集成。</li><li>可测试性：软件是否易于进行测试，包括测试用例的设计、自动化测试和错误跟踪等方面。</li></ol><p>软件质量的提高需要全面的软件测试、代码审查、质量控制和质量保证等措施。同时，还需要遵循良好的软件工程实践和标准，如软件需求分析、设计、编码和测试等阶段的规范和流程。</p></blockquote><h2 id="3-软件缺陷">3.<strong>软件缺陷</strong></h2><p>​软件缺陷指的是在软件中存在的错误、问题或不符合预期的行为。它们可能会导致软件无法正常工作、功能不完整、性能下降或安全漏洞等。软件缺陷是软件开发过程中常见的问题，需要进行缺陷管理和修复。</p><p><strong>软件的缺陷等级：</strong></p><ul><li><strong>可重现性</strong></li><li><strong>严重性</strong></li><li><strong>优先级</strong></li></ul><blockquote><p>以下是一些常见的软件缺陷类型：</p><ol><li>逻辑错误：软件中的代码或算法逻辑错误导致程序无法按照预期工作，例如计算错误、条件判断错误等。</li><li>功能缺陷：软件缺少某些功能或功能无法按照预期工作，例如某个功能模块无法启动、按钮点击无效等。</li><li>用户界面问题：软件的用户界面设计存在问题，导致用户体验不佳或操作不方便，例如布局错乱、字体颜色不明显等。</li><li>性能问题：软件在处理大量数据或复杂操作时出现性能问题，例如响应时间过长、内存占用过高等。</li><li>安全漏洞：软件存在安全弱点或漏洞，可能导致未经授权的访问、数据泄露或恶意攻击，例如密码明文存储、SQL注入等。</li><li>兼容性问题：软件在不同操作系统、浏览器或设备上无法正常工作，例如界面错位、功能不支持等。</li><li>数据处理问题：软件在处理数据时出现错误或异常情况，导致数据丢失、损坏或不一致，例如数据丢失、数据格式错误等。</li><li>文档和说明问题：软件的文档、帮助文件或用户手册存在错误、遗漏或不清晰，影响用户的理解和使用。</li></ol><p>及时发现和修复软件缺陷对于确保软件质量至关重要。软件开发团队通常会使用缺陷跟踪系统来记录、分析和修复缺陷。通过软件测试、代码审查和质量控制等措施，可以减少软件缺陷的数量和影响，并提高软件的可靠性和稳定性。</p></blockquote><h2 id="3-软件测试基本流程">3.软件测试基本流程</h2><p>​软件测试是软件开发过程的一个重要环节，是在软件投入运行之前，对软件需求分析、实际规格说明书和编码实现的最终审定，贯穿于软件定义和开发的整个过程之中，它们是应相辅相成和相互依赖的。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620232049912.png" alt="image-20230620232049912"></p><p>软件测试的流程通常包括以下几个阶段：</p><ol><li><p><strong>需求分析和测试计划</strong>：在这个阶段，测试团队与相关利益相关者一起分析软件需求，并制定测试计划。测试计划确定测试的范围、目标、资源和时间安排。</p></li><li><p><strong>测试设计</strong>：在这个阶段，测试团队根据需求和测试计划设计测试用例。测试用例描述了对软件功能、性能和其他方面的预期行为和期望结果。</p></li><li><p><strong>测试环境设置</strong>：测试团队设置测试环境，包括硬件、操作系统、网络设置和其他必要的软件和工具。测试环境应与实际生产环境尽可能相似。</p></li><li><p><strong>测试执行</strong>：在这个阶段，测试团队根据设计的测试用例执行测试。他们运行软件，并记录测试结果和发现的问题。</p></li><li><p><strong>缺陷管理和修复</strong>：测试团队将测试期间发现的问题记录为缺陷，并将其报告给开发团队。开发团队修复这些缺陷，并将修复后的版本交付给测试团队。</p></li><li><p><strong>回归测试</strong>：在缺陷修复后，进行回归测试以确保修复的问题不会引入新的问题。回归测试通常包括重新执行之前的测试用例和验证修复是否有效。</p></li><li><p><strong>测试报告和评估</strong>：测试团队生成测试报告，总结测试的结果、问题和发现的缺陷。他们还评估软件是否符合预期的质量标准和需求。</p></li><li><p><strong>测试完成和交付</strong>：在完成测试并确保软件符合质量标准后，测试团队将测试结果和相关文档交付给利益相关者，以便他们做出最终的决策和评估。</p></li></ol><p>需要注意的是，具体的软件测试流程可能因组织、项目和方法的不同而有所差异。灵活性和适应性是软件测试流程的重要特征，以确保根据具体情况进行调整和优化。</p><h2 id="4-软件测试目的">4.软件测试目的</h2><p>​软件测试的目的，就是以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正各种错误和缺陷提高软件质量，避免软件发布后由于潜在的软件缺陷和错误造成的隐患所带来的商业风险。</p><h2 id="5-软件测试对象">5.软件测试对象</h2><p>​软件测试的对象是<strong>软件系统或应用程序</strong>。它可以是任何类型的软件，包括桌面应用程序、移动应用程序、Web应用程序、嵌入式系统、服务器端应用程序等。</p><h2 id="6-如何降低测试代价">6.如何降低测试代价</h2><p>降低测试成本是软件测试中的一个重要目标。以下是一些常见的方法和策略，可以帮助降低测试成本：</p><ol><li><p>自动化测试：利用自动化测试工具和框架，可以减少人工测试的工作量，提高测试效率，并且可以重复执行测试用例，节省时间和资源。</p></li><li><p>测试策略和计划：制定明确的测试策略和计划，根据需求和风险评估确定测试的重点和范围，避免进行不必要的测试工作。</p></li><li><p>测试优先级：根据软件功能的重要性和影响程度，对测试用例进行优先级排序，首先测试关键功能和核心业务流程，降低次要功能的测试成本。</p></li><li><p>随机抽样：对于大规模的测试数据集或大规模的测试用例集，可以使用随机抽样的方法，选择一部分代表性的测试数据或测试用例进行测试，以减少测试工作量。</p></li><li><p>集成测试：及早进行集成测试，将不同模块或组件进行集成测试，早期发现和解决问题，避免问题在后续阶段扩大和影响其他模块。</p></li><li><p>环境管理：合理管理测试环境，确保测试环境的稳定性和一致性，避免由于环境问题导致的测试延迟和成本增加。</p></li><li><p>风险驱动的测试：根据风险评估的结果，优先测试高风险的功能和模块，减少低风险功能的测试工作量。</p></li><li><p>测试重用：利用测试工件的重用，包括测试用例、测试数据、测试工具等，避免重复开发和测试，提高测试效率。</p></li><li><p>合作与协作：测试团队与开发团队、产品团队等密切合作，及早进行需求讨论、设计评审等，减少后期修改和调整的成本。</p></li><li><p>持续集成与持续交付：采用持续集成和持续交付的开发模式，频繁进行集成和部署，及时发现和解决问题，降低问题的积累和修复成本。</p></li></ol><p>这些方法和策略并非适用于所有情况，选择合适的方法需要根据具体的项目和需求进行评估和决策。在实际应用中，还需要综合考虑项目的时间、资源、风险和质量目标等因素，以达到在有限成本下提高测试效率和质量的目标。</p><h2 id="7-测试用例设计">7.测试用例设计</h2><p><strong>什么是测试用例？</strong></p><ul><li>测试用例就是为特定目标而开发的一组测试输入、执行条件和预期结果，其目标可以是测试某个程序路径或核实是否满足某个特定的需求。</li></ul><p><strong>为什么需要测试用例？</strong></p><ul><li>设计测试用例是为了更有效、更快地发现软件缺陷</li><li>测试用例具有很高的有效性和可重复性，依据测试用例进行测试可以节约测试时间，提升测试效率</li><li>测试用例具有良好的组织性和可跟踪性，有利于测试的管理</li></ul><p><strong>设计原则：</strong></p><ol><li>测试用例的代表性：能够代表并覆盖各种合理的和不合理的、合法的和非法的、边界的和越界的以及极限的输入数据、操作和环境设置等。</li><li>测试结果的可判定性：即测试执行结果的正确性是可判定的，每一个测试用例都应有相应的期望结果。</li><li>测试结果的可再现性：即对同样的测试用例，系统的执行结果应当是相同的。</li></ol><p><strong>作用：</strong></p><ul><li>–测试用例构成了设计和制定测试过程的基础。测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件或经由产品的事件流，因而，随着测试用例数量的增加，对软件产品质量和测试流程也就越有信心。</li><li>–测试工作量与测试用例的数量成比例。测试设计和开发的类型以及所需的资源主要都受控于测试用例。</li></ul><p><strong>元素</strong>：</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620232528369.png" alt="image-20230620232528369" style="zoom: 80%;" /><h2 id="8-软件测试各阶段文档">8.软件测试各阶段文档</h2><p>在软件测试的各个阶段，通常会涉及以下一些文档和文件：</p><ol><li><strong>测试计划</strong>：测试计划是测试活动的总体计划和指导文件，其中包括测试目标、测试范围、测试策略、测试资源、测试进度等信息。</li><li><strong>测试用例</strong>：测试用例是描述测试场景、输入数据、操作步骤和期望结果的文档，用于指导测试人员执行具体的测试工作。</li><li><strong>测试设计规格说明书</strong>：测试设计规格说明书是对测试用例进行组织和说明的文档，它可以按功能模块、测试类型或其他逻辑方式组织测试用例。</li><li><strong>缺陷报告</strong>：缺陷报告是记录测试过程中发现的缺陷或错误的文档，包括缺陷的详细描述、重现步骤、优先级和状态等信息。</li><li><strong>测试执行日志</strong>：测试执行日志是记录测试人员执行测试用例的过程和结果的文档，包括测试开始时间、结束时间、执行结果、发现的问题等信息。</li><li><strong>测试总结报告</strong>：测试总结报告是对整个测试活动进行总结和评估的文档，包括测试结果、问题统计、测试覆盖率、测试效率等信息。</li><li><strong>测试环境配置文档</strong>：测试环境配置文档描述了测试所需的硬件、软件和网络环境的配置要求和步骤，确保测试环境的正确设置和准备。</li><li><strong>验收测试文档</strong>：验收测试文档是在软件开发完成后进行的最终测试，包括验收测试计划、验收测试用例、验收测试报告等。</li></ol><h2 id="9-测试缺陷报告及缺陷管理">9.测试缺陷报告及缺陷管理</h2><p>​<strong>测试缺陷报告是软件测试过程中记录和跟踪缺陷或错误的文档。它包含了发现的缺陷的详细描述、重现步骤、优先级、状态以及其他相关信息。缺陷报告的目的是向开发团队提供准确的缺陷信息，以便他们能够定位、修复和验证缺陷。</strong></p><p>以下是一般情况下缺陷报告中包含的信息：</p><ol><li>缺陷概述：对缺陷的简要描述，包括标题、缺陷编号等。</li><li>缺陷描述：详细描述缺陷的现象、问题和影响。</li><li>重现步骤：描述如何重现缺陷，包括操作步骤、输入数据、预期结果等。</li><li>缺陷分类：根据缺陷的类型和严重程度进行分类，如功能性缺陷、性能缺陷、界面缺陷等。</li><li>优先级：根据缺陷的重要程度和紧迫程度进行评估和分类，如高、中、低等。</li><li>状态：记录缺陷的当前状态，如新建、已分配、待修复、已修复、已验证等。</li><li>影响范围：描述缺陷对系统功能、用户体验和业务流程的影响范围。</li><li>附件：如截图、日志文件、测试数据等，以支持缺陷的重现和分析。</li><li>提交人：记录报告缺陷的测试人员的信息。</li><li>分配给：记录缺陷被分配给的开发人员或团队的信息。</li></ol><p>**缺陷管理是指在整个软件开发和测试过程中对缺陷进行跟踪、分析和管理的活动。**缺陷管理包括以下步骤：</p><ol><li>缺陷记录：测试人员通过缺陷报告工具或系统将发现的缺陷记录在缺陷数据库或缺陷跟踪工具中。</li><li>缺陷分类和优先级：根据缺陷的类型、严重程度和影响范围对缺陷进行分类和优先级评估。</li><li>缺陷分析：开发人员对缺陷进行分析，确定产生原因和修复方法，并进行相应的处理和解决。</li><li>缺陷分配：将缺陷分配给相应的开发人员或团队进行修复。</li><li>缺陷修复和验证：开发人员根据缺陷报告进行修复，并将修复后的代码提交给测试团队进行验证。</li><li>缺陷关闭：当缺陷被修复并经过验证</li></ol><p>后，将其标记为已关闭，并在缺陷报告中记录相应的信息。</p><ol start="7"><li>缺陷跟踪和报告：定期生成缺陷报告，包括缺陷的状态、趋势、修复效率等指标，以便管理层和团队了解缺陷管理情况。</li></ol><p>通过缺陷报告和缺陷管理，测试团队能够有效地跟踪、管理和解决软件中的缺陷，提高软件质量并促进项目的成功交付。</p><h2 id="10-测试素养">10.测试素养</h2><p>测试素养（Testing Aptitude）是指<strong>软件测试人员应该具备的一系列技能、知识和品质</strong>，以有效地进行软件测试工作并取得良好的测试结果。以下是测试素养的一些关键方面：</p><ol><li>技术能力：测试人员应具备扎实的技术背景，包括软件开发、编程语言、数据库操作、网络通信等相关知识。他们应该能够理解软件系统的技术细节，进行技术分析和故障排除。</li><li>测试方法和技巧：测试人员应熟悉各种测试方法和技巧，包括黑盒测试、白盒测试、功能测试、性能测试、安全测试等。他们应该知道如何选择合适的测试方法，并能够根据需求制定有效的测试策略和测试计划。</li><li>缺陷管理：测试人员应了解缺陷管理的基本原则和流程。他们应该能够准确地记录和报告缺陷，追踪和验证缺陷的修复，并与开发人员和其他团队成员进行有效的沟通和协作。</li><li>分析和解决问题能力：测试人员应具备良好的分析和解决问题的能力。他们应该能够分析测试结果和日志，找出问题的根本原因，并提出相应的解决方案和改进建议。</li><li>沟通和团队合作：测试人员应具备良好的沟通和团队合作能力。他们应该能够与项目团队的其他成员有效地合作，理解需求和交流测试进展，并能够清晰地向团队成员和利益相关者报告测试结果。</li><li>注重细节和质量：测试人员应具备注重细节和质量的意识。他们应该细致入微地进行测试，确保每个测试用例都被覆盖到，并对测试结果进行仔细分析和评估，以确保软件的质量和可靠性。</li><li>学习和适应能力：测试人员应具备良好的学习和适应能力。他们应该持续学习新的测试方法和工具，关注行业的最新趋势和技术发展，并能够快速适应项目的变化和需求的变更。</li><li>责任心和自我驱动：测试人员应具备责任心和自我驱动的品质。他们应该对自己的工作负责，积极主动地解决问题，不断提升自己的测试技能和知识，并追求卓越的测试结果。</li></ol><p>​测试素养是测试人员成功从事软件测试工作的基础，它不仅包括技术方面的知识和技能，还涵盖了团队合作、沟通、问题解决和质量意识等方面的品质和能力。通过不断学习和实践，测试人员可以不断提升自己的测试素养，并为项目的成功交付做出重要贡献。</p><h2 id="12-测试报告的内容。">12.测试报告的内容。</h2><p>•在测试周期内发生了什么？比如达到测试出口准则的日期；</p><p>•通过分析相关信息和度量可以对下一步的活动提供建议和做出决策，比如对遗留缺陷的评估、继续进行测试的经济效益、未解决的风险以及被测试软件的置信度等。</p><p>•测试总结报告的大纲可以参考“软件测试文档标准”（IEEE Std 829-1998）。</p><p>•需要在测试级别的过程中和完成时收集度量信息，来评估：该测试级别的测试目标实现的充分性；</p><p>•采用的测试方法的适当性；</p><p>•针对测试目标的测试的有效性。</p><h1>二、测试方法</h1><p>从测试技术的角度， 可以分为黑盒测试、 白盒测试和灰盒测试；</p><h2 id="1-白盒测试">1.白盒测试</h2><p>​白盒测试，也称为结构测试、透明盒测试或逻辑驱动测试，是一种软件测试方法，它基于对软件内部结构和实现细节的了解来设计测试用例和执行测试。</p><p>​在白盒测试中，<strong>测试人员具有对软件内部的详细了解</strong>，包括源代码、设计文档和系统架构。测试人员使用这些信息来分析软件的内部逻辑、路径和数据流，以评估其正确性、可靠性和性能。</p><blockquote><p>白盒测试的目标是覆盖软件的所有代码路径，并验证每个逻辑分支和条件的正确性。它关注以下几个方面：</p><ol><li>代码覆盖：通过执行测试用例来覆盖软件中的所有代码行、分支和路径，以确保代码的正确性和可执行性。</li><li>控制流测试：测试人员基于软件内部结构设计测试用例，覆盖不同的控制流路径，例如循环、条件语句和异常处理。</li><li>数据流测试：测试人员分析软件中的数据流路径，设计测试用例以验证数据的正确传递和处理，例如变量赋值、数据引用和数据转换。</li><li>边界值测试：测试人员选择接近边界值的测试数据，以测试软件在边界条件下的行为和处理能力，例如最大值、最小值、边界情况等。</li><li>异常处理测试：测试人员针对软件中的异常情况设计测试用例，验证软件在异常情况下的处理和恢复能力，例如错误输入、资源不足、网络中断等。</li><li>性能测试：在白盒测试中也可以关注软件的性能方面，例如检查资源利用率、响应时间和吞吐量等。</li></ol><p>白盒测试可以帮助发现软件内部的逻辑错误、代码缺陷和潜在的安全漏洞。通过对软件的内部结构进行深入分析和测试，可以提高软件的质量、可靠性和安全性。白盒测试通常由开发人员或专门的测试人员执行，并结合其他测试方法（如黑盒测试）来全面评估软件的质量。</p></blockquote><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620222800107.png" alt="image-20230620222800107"></p><h3 id="逻辑覆盖法">逻辑覆盖法</h3><p>​逻辑覆盖是通过对<strong>程序逻辑结构的遍历实现对程序的覆盖</strong>，它是一系列测试过程的总称，这组测试过程逐渐实现越来越完整的通路测试。逻辑覆盖标准包括以下不同的覆盖标准：</p><p>语句覆盖（Statement Coverage，SC）</p><blockquote><p>​语句覆盖，又称行覆盖（LineCoverage）、段覆盖（SegmentCoverage）、基本块覆盖（BasicBlockCoverage），这是最常用也是最常见的一种覆盖方式。其基本思想是设计若干个测试用例，运行被测程序，<strong>使程序中每一条可执行语句至少应该执行一次</strong>。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223107154.png" alt="image-20230620223107154"></p></blockquote><p>判定覆盖（Decision Coverage，DC）</p><blockquote><p>​    希望通过设计足够多的测试用例，使得程序中的<strong>每个判定至少都获得一次“真”值和“假”值</strong>， 也就是使程序中的每个取“真”分支和取“假”分支至少均经历一次，这种设计测试用例的方法称为判定覆盖，也称为“分支覆盖”。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223126809.png" alt="image-20230620223126809"></p></blockquote><p>条件覆盖（Condition Coverage，CC）</p><blockquote><p>​    通过设计足够多的测试用例，使得程序中<strong>每个判定包含的每个条件的可能取值（真/假）都至少出现一次</strong>。这种设计测试用例的方法称为条件覆盖。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223200557.png" alt="image-20230620223200557"></p></blockquote><p>条件判定组合覆盖（Condition/Decision Coverage,DC）</p><blockquote><p>通过设计足够多的测试用例，使得程序中每个判定包含的每个条件的所有情况（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次。这种设计测试用例的方法称为判定/条件覆盖。</p><p>满足判定/条件覆盖的测试用例集一定同时满足判定覆盖和条件覆盖。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223227566.png" alt="image-20230620223227566"></p></blockquote><p>多条件覆盖（Multiple Condition Coverage,MCC）</p><blockquote><p>通过设计足够多的测试用例，使得程序中每个判定的所有可能的条件取值组合都至少出现一次。这种设计测试用例的方法称为组合覆盖。</p><p>满足组合覆盖的测试用例集一定满足判定覆盖、条件覆盖和判定/条件覆盖。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223309937.png" alt="image-20230620223309937"></p></blockquote><p>修正条件判定覆盖（modified condition decision coverage,MCDC）</p><h3 id="基本路径测试法">基本路径测试法</h3><p>通过设计足够多的测试用例，要求覆盖程序的基本路径集合中所有可能的路径。这种设计测试用例的方法称为基本路径覆盖。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620223012197.png" alt="image-20230620223012197"></p><p><strong>程序的控制流图</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621004819804.png" alt="image-20230621004819804"></p><p><strong>控制流图的环路复杂性</strong></p><p>​程序的<strong>环路复杂性</strong>即McCabe复杂性度量，在进行程序的基本路径测试时，从程序的环路复杂性可导出程序<strong>基本路径</strong>集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</p><p>独立路径是指包括一组以前没有处理过的语句或条件的一条路径。从控制流图来看，一条独立路径是至少包含有一条在其他独立路径中从未有过的边的路径。(b)所示的控制流图中,一组独立的路径如下:</p><p>path1：1-11</p><p>path2：1-2-3-4-5-10-1-11</p><p>path3：1-2-3-6-8-9-10-1-11</p><p>path4：1-2-3-6-7-9-10-1-11</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621005024704.png" alt="image-20230621005024704" style="zoom:50%;" /><p><strong>基本路径覆盖-测试用例设计步骤</strong></p><p>（1）以详细的设计或源代码为基础，导出程序的控制流程图</p><p>（2）计算控制流图G的环路复杂性V（G）</p><p>V（G）=区域数</p><p>V（G）=判断节点数+1</p><p>V（G）=边的个数-节点个数+2</p><p>（3）导出独立路径</p><p>（4）设计测试用例，确保每条路径都被执行</p><p><strong>基本路径覆盖-案例</strong></p><p>将一个正整数分解为质因数的Java程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line">String rs=n+<span class="string">&quot;=&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==n)&#123;</span><br><span class="line">rs=rs+n;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n%k==<span class="number">0</span>)&#123;</span><br><span class="line">rs=rs+k+<span class="string">&quot;*&quot;</span>;</span><br><span class="line">n=n/k;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（1）画出程序控制流图</strong></p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621005354340.png" alt="image-20230621005354340" style="zoom:50%;" /><p><strong>（2）计算环形复杂度：</strong></p><p>V(G)=9-8+2=2+1=3</p><blockquote><p>将V(G)定义为：</p><p>V(G)=e-n+2</p><p>这里，e是控制流图的边数，n是控制流图的节点数。我们还可以用如下两个方法计算环形复杂度：</p><p>V(G)=区域数</p><p>V(G)=判定节点数+1</p><p>这里，区域是指由边包围起来的形状，图中没有被边包围的部分也算一个区域。判定节点是有多个边以它作为起点的节点。</p></blockquote><p><strong>（3）找出一组独立路径（基本路径集合）：</strong></p><p>路径1：1-2-3-4</p><p>路径2：1-2-3-5-6-8-2-3-4</p><p>路径3：1-2-3-5-7-8-2-3-4</p><p><strong>（4）根据基本路径设计测试用例，覆盖基本路径集合中的所有路径</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621005710849.png" alt="image-20230621005710849"></p><h2 id="2-黑盒测试">2.黑盒测试</h2><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621010108798.png" alt="image-20230621010108798"></p><p>​黑盒测试是一种软件测试方法，它在不考虑软件内部结构和实现细节的情况下，通过输入和输出来评估软件的功能和性能。</p><p>​在黑盒测试中，测试人员只关注软件的外部行为和功能，而<strong>无需了解其内部实现</strong>。测试人员根据需求规格说明书、用户手册或软件规范来设计测试用例，并通过输入不同的数据和操作来触发软件的功能，然后检查输出结果是否符合预期。</p><blockquote><p>黑盒测试的目标是验证软件是否符合规格说明书、用户需求和预期功能。它关注以下几个方面：</p><ol><li>功能测试：测试人员验证软件的各项功能是否按照规格说明书和用户需求正常工作。他们设计测试用例，覆盖不同的功能路径，例如输入验证、功能操作、数据处理等。</li><li>界面测试：测试人员评估软件的用户界面，包括布局、样式、导航和用户交互。他们验证界面的易用性、一致性和响应性。</li><li>性能测试：在黑盒测试中也可以关注软件的性能方面，例如测试软件在各种负载条件下的响应时间、资源利用率和吞吐量等。</li><li>兼容性测试：测试人员验证软件在不同的操作系统、浏览器、设备或网络环境下的兼容性。他们检查软件是否在不同环境中正常运行和展现预期的行为。</li><li>安全性测试：测试人员评估软件的安全性，包括检查是否存在潜在的安全漏洞、验证用户身份验证和访问控制机制等。</li><li>错误处理测试：测试人员故意输入错误数据或异常情况，以测试软件的错误处理能力。他们验证软件是否能够正确识别、记录和处理错误，以及恢复到正常状态。</li></ol><p>黑盒测试侧重于从用户的角度评估软件的功能和性能，以确保软件的质量和用户满意度。它可以帮助发现功能缺陷、用户体验问题、兼容性和安全性漏洞等。黑盒测试通常由专门的测试人员执行，以独立于开发人员的视角来评估软件。</p></blockquote><h3 id="等价类">等价类</h3><p>背景：<strong>对系统进行穷尽测试是不可能的,使用有限的数据对系统进行测试是可能的</strong></p><p>我们可以选择少量测试用例来测试系统，并满足:</p><ul><li>测试是完备的</li><li>测试是没有冗余的</li></ul><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621010416678.png" alt="image-20230621010416678"></p><p><strong>分类：</strong></p><ul><li>有效等价类<ul><li>输入域中一组有意义的数据的集合</li><li>有效等价类被用于检验系统指定功能和性能能否正确实现</li></ul></li><li>无效等价类<ul><li>l输入域中一组无意义的数据的集合</li><li>无效等价类被用于检验系统的容错性</li></ul></li></ul><p><strong>划分等价类的规则</strong></p><p>•（1） 输入的数据是<strong>布尔值</strong>，这是一种特殊的情况，只有两个等价类：真（True）和假（False）。</p><p>•（2）在输入条件规定了<strong>取值范围</strong>的前提下，则可以确定一个有效等价类和两个无效等价类。例如，程序输入数据要求是两位正整数x，则有效等价类为10≤x≤99，两个无效等价类为x&lt;10和x&gt;99。</p><p>•（3）如果规定了输入数据的<strong>个数</strong>，则类似地可以划分出一个有效等价类和两个无效等价类。例如一个学生每学期只能选修1-3门课，则有效等价类是选修1-3门课，而无效等价类有“一门课都不选”或“选修超过3门”。</p><p>•（4）在输入条件规定了<strong>输入值的集合</strong>或者规定了“<strong>必须如何</strong>”的条件下，可以确定一个有效等价类和多个无效等价类。例如，邮政编码必须由6位数字构成有效的值，其有效集合是清楚的，对应存在一个无效的集合，包括多个无效等价类。</p><p>•（5）规定了<strong>一组列表形式</strong>（n个值）的输入数据，并且程序要对每一个输入值分别进行处理的情况下，可以确定n个有效等价类和一个无效等价类。例如将我国的直辖市作为程序的输入值，其有效等价类是一个固定的枚举类型{北京、上海、天津、重庆}，而且要针对每个城市分别取出相对应的数据，此时无效等价类为非直辖市的省、自治区等。</p><p>•（6）更复杂的情况是，输入数据只是要求符合某个规则，这时可能存在多个有效等价类和若干个无效等价类。</p><p><strong>等价类划分法-案例1</strong></p><p>假如某个系统的注册用户名要求由字母开头，后跟字母或数字的任意组合，有效字符数不超过6个。</p><p>等价类划分：</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011021039.png" alt="image-20230621011021039"></p><ul><li>弱覆盖<ul><li>测试用例应覆盖所有的有效等价类</li></ul></li><li>强覆盖<ul><li>测试用例应覆盖所有的有效等价类的组合</li></ul></li></ul><p><strong>等价类划分法-案例2</strong></p><p>在应用程序中经常要求输入电话号码，我国的固定电话号码一般由两部分组成：</p><p>地区码：以0开头的3位或者4位数字。</p><p>电话号码：以非0、非1开头的7位或者8位数字。</p><p>应用程序应接受一切符合上述规定的电话号码，但应拒绝不符合上述规定的号码。</p><p>等价类划分：</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011226908.png" alt="image-20230621011226908"></p><p>设计测试用例：</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011257920.png" alt="image-20230621011257920"></p><p>等价类测试流程：</p><ul><li>确定有几个输入条件</li><li>划分每个输入条件的等价类</li><li>选择合适的覆盖标准</li><li>设计测试用例</li></ul><h3 id="边界值分析">边界值分析</h3><p><strong>背景：</strong></p><ul><li>经过长期的测试工作经验表明，在输入域的边界或边界附近，常常会发现大量缺陷</li><li>边界值测试倾向于选择系统边界或边界附近的数据来设计测试用例</li></ul><p>试试根据以下业务的需求，设计边界值测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">某保险网站的前台计算保费的页面中要求输入被保险人的年龄，根据不同的年龄使用不同的保险费率计算标准。</span><br><span class="line">保费计算方式为：保费=投保额X保险费率。</span><br><span class="line">其中：</span><br><span class="line">1-15岁，保险费率为10%；</span><br><span class="line">16-20岁，保险费率为15%；</span><br><span class="line">21-50岁，保险费率为20%；</span><br><span class="line">51-70岁，保险费率为25%。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖于边界值的等价类划分:</p><table><thead><tr><th>年龄</th><th>保险费率</th><th>年龄</th><th>保险费率</th></tr></thead><tbody><tr><td>x&lt;0</td><td>无效输入</td><td>20&lt;x≤50</td><td>20%</td></tr><tr><td>1≤x≤15</td><td>10%</td><td>50&lt;x≤70</td><td>25%</td></tr><tr><td>15&lt;x≤20</td><td>15%</td><td>x&gt;70</td><td>无效输入</td></tr></tbody></table><p><strong>问题1：边界在哪里？</strong></p><p>边界点就是可能导致被测系统内部处理机制<strong>发生变化</strong>的点</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011758838.png" alt="image-20230621011758838"></p><p>需求中有利于识别边界点的文字：</p><p>位置，尺寸，数量，长度，速度，高度，距离，质量，时间…</p><p>可能的边界点：</p><p>第一个/最后一个，最小/最大，最少/最多，最短/最长，最快/最慢，最高/最低，最近/最远，最重/最轻，最早/最晚…</p><p>总结：<strong>找到每个输入条件的边界点即可确定系统的边界点。</strong></p><p><strong>问题2：如何确定邻域？</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011930539.png" alt="image-20230621011930539"></p><p><strong>问题3：如何选择测试数据？</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621011951271.png" alt="image-20230621011951271"></p><p><strong>问题4：如何设计测试用例？</strong></p><p>穷尽测试</p><p>在边界及边界附近的邻域内选择所有的测试数据，构成测试用例。</p><p>做一做：ind add(int x1,int x2)</p><p>​         1 ≤ x1 ≤ 100</p><p>​        10 ≤ x2 ≤ 50</p><p>使用边界值测试设计测试用例</p><h3 id="组合测试">组合测试</h3><p><strong>背景</strong>：等价类划分法和边界值分析法都假定程序的各个输入变量时完全独立的。在实际程序中，更多的情况时各个输入变量的组合共同导致了程序的输出。</p><p><strong>正交实验法</strong></p><p>在许多应用系统的测试工作中，输入条件的因素很多，而且每个因素也不能简单用“是”和“否”来回答。</p><p>例：为提高某化工产品的转化率，选择了三个有关因素进行条件试验：反应温度（A），反应时间（B），用碱量（C），这三个因素的试验范围如下：</p><p>A：80-90℃</p><p>B：90-150分钟</p><p>C：5-7％</p><p>对A、B、C三个因素分别取三个水平值，如下：</p><p>A：A1=80 ℃ ,A2=85 ℃,A3=90 ℃</p><p>B:B1=90分钟，B2=120分钟，B3=150分钟</p><p>C:C1=5%，C2=6%，C3=7%</p><p>对于3个因素、各因素3个水平的测试用例设计，完全组合需要3X3X3=27个测试用例。</p><p>依据Galois理论，从大量的（实验）数据（测试用例）中挑选适量的、有代表性的点（条件组合），从而合理地安排实验（测试）的一种科学实验设计方法。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621134351682.png" alt="image-20230621134351682" style="zoom:50%;" /><p>在测试实践中，可以直接使用现成的正交表进行测试用例的设计。正交表用Ln(tc)标识，其中L为正交表的代号，n为试验的次数（行数），t为水平数，c为因子数，常见的正交表有L4(23)、L8(27)、L9(34)、L16(45)等。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621134427794.png" alt="image-20230621134427794"></p><p>实例1</p><p>某所大学通信系共有2个班级，这两个班刚考完某一门课程，现在要通过教务系统查询学生成绩。假设有3个独立的查询条件，可以获得特定学生的个人成绩。</p><p>性别：{男，女}</p><p>班级：{1班，2班}</p><p>成绩：{及格，不及格}</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621134441819.png" alt="image-20230621134441819"></p><h3 id="场景法">场景法</h3><p>​    场景法就是<strong>模拟用户操作软件时</strong>的场景，主要用于测试系统的业务流程。当拿到一个测试任务时，一般并不是先关注某个控件的边界值、等价类能否满足要求，而是要先关注它的<strong>主要功能和业务流程能否正确实现</strong>，这就需要场景法来完成测试。</p><p>用例场景用来描述用例流经的路径，从开始到结束遍历整条路径上所有的基本流和备选流。</p><ul><li>l基本流：按照正确的业务流程实现的一条操作路径（模拟正确的操作流程）。</li><li>l备选流：导致程序出现错误的操作流程（模拟错误的操作流程）。</li></ul><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132411692.png" alt="image-20230621132411692"></p><p>在如图所示的操作流程中，可以确定以下场景：</p><p>场景1：基本流</p><p>场景2：基本流 备选流1</p><p>场景3：基本流 备选流1 备选流2</p><p>场景4：基本流 备选流3</p><p>场景5：基本流 备选流3 备选流1</p><p>场景6：基本流 备选流3 备选流1 备选流2</p><p>场景7：基本流 备选流4</p><p>场景8：基本流 备选流3 备选流4</p><p><strong>实例分析-ATM机取款的例子：</strong></p><table><thead><tr><th>步骤编号</th><th>基本流</th></tr></thead><tbody><tr><td>1</td><td>插入银行卡：客户将银行卡插入ATM机的读卡器</td></tr><tr><td>2</td><td>验证银行卡：ATM机从银行卡的芯片中读取账户代码，并检查它是否属于可以接受的银行卡</td></tr><tr><td>3</td><td>输入密码：ATM机要求客户输入密码</td></tr><tr><td>4</td><td>验证密码：确定该密码是否正确</td></tr><tr><td>5</td><td>进入ATM机主界面：ATM机显示各种操作选项</td></tr><tr><td>6</td><td>取款并选择金额：客户选择“取款”，并选择取款金额</td></tr><tr><td>7</td><td>ATM机验证：ATM机验证账户余额、当日总取款金额等是否满足要求，验证ATM机内现金是否够用</td></tr><tr><td>8</td><td>更新账户余额、出钞：验证成功，更新账户余额，输出现金，提示用户收取现金</td></tr><tr><td>9</td><td>返回操作主界面</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132509790.png" alt="image-20230621132509790"></p><table><thead><tr><th>场景描述</th><th>基本流</th><th>备选流</th></tr></thead><tbody><tr><td>场景1：成功取款</td><td>基本流</td><td></td></tr><tr><td>场景2：银行卡无效</td><td>基本流</td><td>备选流1</td></tr><tr><td>场景3：密码错误</td><td>基本流</td><td>备选流2</td></tr><tr><td>场景4：密码3次错误</td><td>基本流</td><td>备选流3</td></tr><tr><td>场景5：账户余额不足</td><td>基本流</td><td>备选流4</td></tr><tr><td>场景6：当日总取款金额超出可取限额</td><td>基本流</td><td>备选流5</td></tr><tr><td>场景7：ATM机余额不足</td><td>基本流</td><td>备选流6</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132526015.png" alt="image-20230621132526015"></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132535176.png" alt="image-20230621132535176"></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132540311.png" alt="image-20230621132540311"></p><h3 id="因果图测试法">因果图测试法</h3><p><strong>背景：</strong></p><p>​在一个功能或一个界面中，往往会有多个控件，这些控件一般会有一定的制约关系或组合关系，并且功能模块的输出会依赖于输入的条件。</p><p>​如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。</p><p><strong>原理：</strong></p><p>​    一些程序的功能可以用判定表（或称决策表）的形式来表示，并根据输入条件的组合情况规定相应的操作。。</p><p>定义：是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p><p><strong>因果图基本符号：</strong></p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132703518.png" alt="image-20230621132703518" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132715860.png" alt="image-20230621132715860" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132726664.png" alt="image-20230621132726664" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132810064.png" alt="image-20230621132810064" style="zoom:50%;" /><p>左结点ci表示输入状态（或称原因），右结点ei表示输出状态（或称结果）。</p><p>ci 与 ei 取值0或1，0表示某状态不出现，1则表示某状态出现。</p><p><strong>因果图4种关系:</strong></p><p>Ø恒等：若 c1 是1，则 e1 也为1，否则 e1 为0。</p><p>Ø非：若 c1 是1，则 e1 为0，否则e1为1。</p><p>Ø或：若 c1 或 c2 或 c3 是1，则 e1 为1，否则 e1 为0。</p><p>Ø与：若 c1 和 c2 都是1，则 e1 为1，否则 e1 为0。</p><p><strong>约束</strong></p><p>​    在实际问题中输入状态相互之间、输出状态相互之间可能存在某些依赖关系，称为“约束”或“制约”。对于输入条件的约束有E、I、O、R四种约束，对于输出条件的约束只有M约束。</p><p>ØE约束(异)：a和b中最多只有一个为1，即a和b不能同时 为1。（如3个a、b、c则a、b、c最多只有一个1，或全0）</p><p>ØI 约束(或)：a、b、c中至少有一个必须为1，即 a、b、c不能同时为0。</p><p>ØO约束(唯一)：a和b必须有一个且仅有一个为1。</p><p>ØR约束(要求)：a是1时，b必须是1，即a为1时，b不能为0。</p><p>ØM约束(强制)：若结果a为0，则结果b强制为0。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132925214.png" alt="image-20230621132925214" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132936586.png" alt="image-20230621132936586" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132942148.png" alt="image-20230621132942148" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132947615.png" alt="image-20230621132947615" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621132955263.png" alt="image-20230621132955263" style="zoom:50%;" /><p><strong>因果图测试流程</strong></p><p>1.根据程序规格说明书描述，分析并确定因（输入条件）和果（输出结果或程序状态的改变），画出因果图</p><p>2.将得到的因果图转换为判定表。</p><p>3.为判定表中每一列所表示的情况设计一个测试用例。</p><p><strong>因果图测试案例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">公交一卡通自动充值系统，其需求描述如下：</span><br><span class="line"></span><br><span class="line">Ø系统只接收50元或100元纸币，一次充值只能使用一张纸币，一次充值金额只能为50元或100元。</span><br><span class="line"></span><br><span class="line">Ø若输入50元纸币，并选择充值50元，完成充值后退卡，提示充值成功。</span><br><span class="line"></span><br><span class="line">Ø若输入50元纸币，并选择充值100元，提示输入金额不足，并退回50元。</span><br><span class="line"></span><br><span class="line">Ø若输入100元纸币，并选择充值50元，完成充值后退卡，提示充值成功，找零50元。</span><br><span class="line"></span><br><span class="line">Ø若输入100元纸币，并选择充值100元，完成充值后退卡，提示充值成功。</span><br><span class="line"></span><br><span class="line">Ø若输入纸币后在规定时间内不选择充值按钮，退回输入的纸币，并提示错误。</span><br><span class="line"></span><br><span class="line">Ø若选择充值按钮后不输入纸币，提示错误。</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133121581.png" alt="image-20230621133121581" style="zoom:50%;" /><p><strong>（1）条件之间的制约及组合关系</strong></p><p>根据上述描述，输入条件（原因）为：</p><p>① 投币50元</p><p>② 投币100元</p><p>③ 选择充值50元</p><p>④ 选择充值100元</p><p>输出（结果）有：</p><p>（a）完成充值、退卡</p><p>（b）提示充值成功</p><p>（c）找零</p><p>（d）提示错误</p><p><strong>（2）明确所有条件之间的制约关系以及组合关系</strong></p><p>条件之间的制约关系以及组合关系如图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133141963.png" alt="image-20230621133141963" style="zoom:50%;" /><p><strong>（3）画出因果图</strong></p><p>为了描述得更清楚，这里把每种情况单独画一个因果图出来。</p><p>条件①和条件③可以组合，输出a和b的组合，也就是投币50元，充值50元，会输出完成充值、退卡，提示充值成功的结果。其因果图如图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133155285.png" alt="image-20230621133155285" style="zoom:50%;" /><p>条件①和条件④可以组合，输出c和d的组合，也就是投币50元，充值100元，会输出找零、提示错误的结果。其因果图如图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133217452.png" alt="image-20230621133217452" style="zoom: 67%;" /><p>条件②和条件③可以组合，输出a、b、c的组合，也就是投币100元，充值50元，会输出找零、完成充值、提示充值成功的结果。其因果图如图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133232452.png" alt="image-20230621133232452" style="zoom:67%;" /><p>条件②和条件④可以组合，输出a和b的组合，也就是投币100元，充值100元，会输出完成充值、退卡，提示充值成功的结果。其因果图如图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133240846.png" alt="image-20230621133240846" style="zoom:67%;" /><p>条件①、②、③、④均可以单独出现，其因果图如图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133258923.png" alt="image-20230621133258923" style="zoom:50%;" /><p><strong>（4）根据因果图，写出判定表</strong></p><p>根据上面的因果图，写出对应的判定表。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133312023.png" alt="image-20230621133312023"></p><p><strong>（5）根据判定表，写出测试用例</strong></p><p>根据上面的判定图，写出对应的测试用例</p><table><thead><tr><th>编号</th><th>用例说明</th><th>预期结果</th></tr></thead><tbody><tr><td>1</td><td>投币50元 选择充值50元</td><td>正确充值50元，提示充值成功后退卡</td></tr><tr><td>2</td><td>投币50元 选择充值100元</td><td>系统提示错误并退回50元</td></tr><tr><td>3</td><td>投币100元 选择充值50元</td><td>正确充值50元，提示充值成功后退卡，并找回50元</td></tr><tr><td>4</td><td>投币100元 选择充值100元</td><td>正确充值100元，提示充值成功后退卡</td></tr><tr><td>5</td><td>投币50元</td><td>系统提示错误并退回50元</td></tr><tr><td>6</td><td>投币100元</td><td>系统提示错误并退回100元</td></tr><tr><td>7</td><td>选择充值50元</td><td>系统提示错误</td></tr><tr><td>8</td><td>选择充值100元</td><td>系统提示错误</td></tr></tbody></table><h3 id="决策表法">决策表法</h3><p><strong>背景</strong></p><p>Ø在所有的黑盒测试方法中，基于决策表（也称判定表）的测试是最为严格、最具有逻辑性的测试方法。</p><p>Ø决策表的概念：决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。</p><p><strong>优点：</strong></p><p>Ø能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用决策表能够设计出完整的测试用例集合。</p><p>Ø在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。决策表很适合于处理这类问题。</p><p>Ø了解五个概念——条件桩、动作桩、条件项、动作项和规则。</p><ul><li>l条件桩：列出问题的所有条件，如上述3个条件——功率大小、维修记录和运行时间。</li><li>l动作桩：列出针对问题所采取的操作，如优先维修。</li><li>l条件项：针对所列条件的具体赋值，即对每个条件可以取真值和假值。</li><li>l动作项：列出在条件项（各种取值）组合情况下应该采取的动作。</li><li>l规则：任何一个条件组合的特定取值及其相应要执行的操作。在决策表中贯穿条件项和动作项的一列就是一条规则。</li></ul><p><strong>构建步骤</strong></p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133608230.png" alt="image-20230621133608230" style="zoom: 50%;" /><p>Ø若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以合并。</p><p>Ø合并后的条件项用符号“-”表示，说明执行的动作与该条件的取值无关，称为无关条件。</p><p><strong>（1）使用决策表法为设备维修程序设计测试用例</strong></p><p>Ø仍以上述“设备维修”为例来说明如何制定决策表。首先，列出所有的条件桩和动作桩，本例的条件桩有3个，分别为：</p><p>Ø机器功率是否大于100马力？</p><p>Ø维修记录是否完整？</p><p>Ø运行时间是否超过6年？</p><p>l本例的动作桩有两个，分别为：</p><p>Ø优先维修。</p><p>Ø正常维修。</p><p>l接着确定条件项，即上述每个条件的值分别取“是（Y）”和“否（N）”。根据条件项的组合确定其对应的活动，如表所示。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133915660.png" alt="image-20230621133915660"></p><p>根据表6-23所示的4种组合可设计出以下4个测试用例：</p><p>l功率大于100马力（如，200马力），优先维修。</p><p>l功率不大于100马力（如，99马力），维修记录不全，优先维修。</p><p>l功率不大于100马力（如，99马力），维修记录全且运行时间超过6年（如，8年），优先维修。</p><p>l功率不大于100马力（如，99马力），维修记录全且运行时间不超过6年（如，3年），正常维修。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621133758806.png" alt="image-20230621133758806"></p><h1>三、测试策略</h1><p>根据是否运行程序，软件测试技术可分为：<strong>静态测试，动态测试</strong></p><p>静态测试与动态测试的区别。</p><ol><li>对象：静态测试关注软件系统的静态属性和文档，如代码、需求规格、设计文档等；动态测试关注软件系统的运行时行为和功能。</li><li>执行：静态测试在不执行程序的情况下进行评审、检查和分析；动态测试需要执行程序，通过输入测试数据和执行测试用例来验证软件系统的行为。</li><li>目的：静态测试的目的是发现潜在的问题和缺陷，改进软件系统的质量；动态测试的目的是评估软件系统的正确性、稳定性、性能等方面。</li><li>方法：静态测试方法包括代码走查、需求审查、设计审查、静态分析等；动态测试方法包括单元测试、集成测试、系统测试、性能测试等。</li></ol><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620225130388.png" alt="image-20230620225130388"></p><h2 id="1-静态测试">1.静态测试</h2><p>静态测试（Static Testing）是一种软件测试方法，它在<strong>执行程序时不涉及实际运行代码</strong>，而是<strong>通过对软件产品或文档进行分析和检查来评估其质量和正确性</strong>。它主要关注于检查代码、设计、文档和其他软件工件的正确性、合规性和一致性。</p><p>静态测试通常包括以下活动：</p><ol><li>代码审查（Code Review）：通过检查源代码来发现潜在的错误、漏洞和质量问题。代码审查可以是手动的，由开发人员或测试人员逐行检查代码，也可以是自动的，利用静态分析工具来检查代码的规范性、安全性和性能问题。</li><li>静态分析（Static Analysis）：使用自动化工具对源代码、配置文件或其他软件工件进行静态分析，以检测潜在的问题。静态分析工具可以检查代码的语法错误、代码规范违规、潜在的内存泄漏、不安全的编码实践等。</li><li>文档审查（Document Review）：对软件需求规格、设计文档、用户手册等进行审查，以确保其准确性、完整性和一致性。文档审查可以帮助发现潜在的逻辑错误、需求不一致、遗漏的功能等问题。</li><li>静态测试工具使用：使用专门的静态测试工具对软件工件进行分析和检查。这些工具可以帮助发现代码中的潜在问题，如未使用的变量、死代码、低效的算法等。</li></ol><p>静态测试的优点包括：</p><ul><li>提早发现问题：静态测试可以在运行代码之前发现潜在的问题，减少后期修复的成本和风险。</li><li>提高代码质量：通过代码审查和静态分析，可以发现和纠正代码中的错误和缺陷，提高代码的质量和可靠性。</li><li>改进文档质量：文档审查可以帮助发现需求和设计文档中的错误和遗漏，确保文档的准确性和可理解性。</li><li>自动化支持：静态测试工具可以自动化执行测试，减少人工工作量，提高效率和一致性。</li></ul><p>需要注意的是，静态测试并不能替代动态测试（如单元测试、集成测试和系统测试），因为静态测试无法覆盖代码的实际执行路径和运行时环境。静态测试主要用于提高软件质量和发现潜在问题，而动态测试则用于验证软件在实际运行时的功能和性能。</p><h3 id="代码走查">代码走查</h3><p>代码走查（Code Review）是一种软件开发过程中的质量保证活动，<strong>旨在通过审查和检查源代码，发现潜在的错误、缺陷和改进点</strong>，以提高代码的质量、可读性、可维护性和性能。</p><p>代码走查通常由开发团队中的其他成员（如技术主管、高级开发人员或同行开发人员）进行，他们独立地检查和评估源代码的各个方面，包括但不限于以下内容：</p><ol><li><p>代码规范：检查代码是否符合组织或项目的编码规范，包括命名规则、缩进、注释、代码结构等。</p></li><li><p>潜在错误：寻找代码中的错误、逻辑问题、边界情况和异常处理，确保代码在各种情况下都能正确运行。</p></li><li><p>可读性：评估代码的可读性和可理解性，包括变量和函数命名的清晰度、代码注释的质量和准确性，以及代码块的组织结构等。</p></li><li><p>性能优化：查找可能影响性能的代码段，并提出改进建议，如减少不必要的循环、优化算法等。</p></li><li><p>安全性：检查代码是否存在潜在的安全漏洞，如输入验证不充分、密码存储不安全等，并提供改进建议以增强系统的安全性。</p></li><li><p>最佳实践：评估代码是否遵循最佳实践和设计原则，如单一职责原则、开闭原则、依赖倒置原则等。</p></li></ol><p>代码走查的目的是提高代码质量、减少错误和缺陷，并促进知识共享和团队合作。它是一种有效的方法，可以在代码进入测试和部署阶段之前发现和解决问题，从而降低后期修复成本和改进工作的复杂性。通过代码走查，开发团队可以相互学习、提高技术水平，并共同努力构建高质量的软件系统。</p><h2 id="2-动态测试">2.动态测试</h2><p>动态测试（Dynamic Testing）是一种软件测试方法，它涉及<strong>在实际运行时执行软件代码，通过输入测试数据并观察输出结果</strong>来评估软件的功能、性能和可靠性。</p><p>动态测试主要包括以下活动：</p><ol><li>单元测试（Unit Testing）：针对软件中的最小可测试单元（如函数、方法或类）编写和执行测试用例。单元测试旨在验证单元的行为是否符合预期，以确保其功能正确性和代码覆盖率。</li><li>集成测试（Integration Testing）：测试多个模块或组件之间的接口和交互。集成测试的目标是验证这些模块或组件在协同工作时是否能够正确地传递和处理数据，以及是否满足系统的功能需求。</li><li>系统测试（System Testing）：对整个系统进行完整的测试，以验证系统是否满足用户需求和规格要求。系统测试通常包括功能测试、性能测试、安全测试、兼容性测试等。</li><li>验收测试（Acceptance Testing）：由最终用户或客户执行的测试，以验证软件是否满足其期望和需求。验收测试通常涉及对实际使用场景进行测试，以确保软件在真实环境中的功能和性能。</li></ol><p>动态测试的优点包括：</p><ul><li>验证软件功能：通过输入测试数据并观察输出结果，可以验证软件的功能是否按照预期工作。</li><li>发现缺陷和错误：动态测试可以揭示代码中的错误、缺陷和异常情况，帮助开发团队改进和修复问题。</li><li>提高软件质量：通过系统化和全面的动态测试，可以提高软件的质量、可靠性和性能。</li><li>验证需求和规格：动态测试可确保软件满足用户需求和规格要求，帮助减少需求和设计方面的错误。</li></ul><p>需要注意的是，动态测试的有效性取决于测试用例的设计和执行质量。设计充分、覆盖全面的测试用例可以提高测试的效果和准确性。同时，动态测试也需要结合其他测试方法（如静态测试、自动化测试等）来实现全面的软件测试覆盖。</p><h1>四、测试级别</h1><p>测试级别与项目的职责相关联。 从测试阶段或对象的角度， 可以分为单元测试、集成测试、 系统测试和验收测试；</p><h2 id="1-单元测试">1.单元测试</h2><p>​**单元测试是在软件开发过程中要进行的最低级别的测试活动，**或者说是针对软件设计的最小单位——程序模块，进行正确性检验</p><p>的测试工作。其目的在于发现每个程序模块内部可能存在的差错。</p><p>​</p><p><strong>测试对象:</strong></p><p>​结构化编程-函数、过程</p><p>​面向对象编程-类</p><p><strong>测试目的:</strong></p><p>​发现设计或视线中的逻辑错误，及早暴露代码中的缺陷，便于问题的定义和解决</p><p><strong>测试方法</strong>:</p><p>​一般以白盒测试为主、结合黑盒测试的方法，允许多个测试单元的测试并行展开。</p><p><strong>内容</strong>：</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620234037996.png" alt="image-20230620234037996"></p><p><strong>1.模块接口测试</strong></p><p>对通过被测模块的数据流进行测试，检查进出模块的数据是否正确。</p><p>主要涉及以下几方面的内容：</p><blockquote><ol><li>模块接收输入的实际参数个数与模块的形式参数个数是否一致。</li><li>输入的实际参数与模块的形式参数的类型是否匹配。</li><li>输入的实际参数与模块的形式参数所使用单位是否一致。</li><li>调用其他模块时，所传送的实际参数个数与被调用模块的形式参数的个数是否相同。</li><li>调用其他模块时，所传送的实际参数与被调用模块的形式参数的类型是否匹配。</li><li>调用其他模块时，所传送的实际参数与被调用模块的形式参数的单位一致。</li><li>调用内部函数时，参数的个数、属性和次序是否正确。</li><li>在模块有多个入口的情况下，是否有引用与当前入口无关的参数。</li><li>是否会修改了只读型参数。</li><li>出现全局变量时，这些变量是否在所有引用它们的模块中都有相同的定义。</li><li>有没有把某些约束当做参数来传送。</li></ol></blockquote><p><strong>2.模块局部数据结构测试</strong></p><p>检查局部数据结构能否保持完整性.</p><p>主要涉及以下几方面的内容：</p><blockquote><ul><li>不正确或不一致的数据类型说明</li><li>变量没有初始化</li><li>变量名拼写错或书写错</li><li>数组越界</li><li>非法指针</li><li>全局数据对模块的影响</li></ul></blockquote><p><strong>3.模块独立执行路径测试</strong></p><p>对模块中重要的执行路径进行测试。检查由于计算错误、判定错误、控制流错误导致的程序错误。</p><p>Checklist：</p><blockquote><p>死代码</p><p>错误的计算优先级</p><p>精度错误（比较运算错误、赋值错误）</p><p>表达式的不正确符号</p><p>循环变量的使用错误</p></blockquote><p><strong>4.模块内部错误处理测试</strong></p><p>检查内部错误处理设施是否有效.</p><p>Checklist：</p><blockquote><p>是否检查错误出现</p><p>出现错误，是否进行错误处理</p><p>抛出错误、通知用户、进行记录</p><p>错误处理是否有效</p></blockquote><p><strong>5.模块边界条件测试</strong></p><p>检查临界数据是否正确处理</p><p>Checklist：</p><blockquote><p>普通合法数据是否正确处理</p><p>普通非法数据是否正确处理</p><p>边界内最接近边界的(合法)数据是否正确处理</p><p>边界外最接近边界的(非法)数据是否正确处理</p></blockquote><p>基本单元本身不是一个独立的程序，自己不能运行，要靠其它部分来调用和驱动。</p><p><strong>驱动模块 (Driver)</strong></p><p>被测基本单元的主程序，它接收测试数据，并把数据传送给被测单元，最后输出实测结果。</p><p><strong>桩模块 (Stub)</strong></p><p>用来代替被测基本单元调用的其他基本单元。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620234412084.png" alt="image-20230620234412084"></p><h2 id="2-集成测试">2.集成测试</h2><p>集成（Integration）是指把多个单元组合起来形成更大的单元.</p><p>一种旨在暴露单元接口之间、组件/系统间交互或协同工作时所存在的缺陷的测试。</p><p><strong>自底向上</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620235905695.png" alt="image-20230620235905695"></p><p><strong>自顶向下</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620235847225.png" alt="image-20230620235847225"></p><p><strong>大棒式</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230620235924529.png" alt="image-20230620235924529"></p><p><strong>三明治</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621000013683.png" alt="image-20230621000013683"></p><p><strong>持续集成</strong></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621000027913.png" alt="image-20230621000027913"></p><p><strong>桩程序</strong></p><p>桩程序（Stub Program）是软件开发和测试中的一种技术，用于<strong>模拟或替代系统的某些组件或功能</strong>。它是一个简化版的程序或模块，用于提供预定义的响应和行为，以满足被测试系统或组件的需求。</p><p>桩程序通常用于以下情况：</p><ol><li>替代外部依赖：当被测试系统或组件依赖于外部系统、服务或模块时，桩程序可以模拟这些外部依赖的行为，以便进行独立的测试。例如，如果被测试系统需要与数据库进行交互，但在测试环境中无法访问实际的数据库，可以使用桩程序模拟数据库的响应。</li><li>模拟复杂场景：在某些情况下，测试特定的功能或场景可能非常复杂或困难。使用桩程序可以简化测试环境，模拟所需的条件和事件，以验证系统在不同情况下的行为。这有助于提高测试的可控性和可预测性。</li><li>并行开发：在软件开发过程中，不同的团队可能同时进行工作，并且某些模块或组件可能尚未完成或可用。使用桩程序可以替代尚未完成的组件，以便其他团队可以继续开发和测试其依赖项。</li></ol><p>桩程序可以根据需要提供不同的实现方式。它们可以是简单的占位符代码，只返回预定义的值或执行基本的操作，也可以是更复杂的模拟程序，具有特定的行为和逻辑。桩程序通常在测试环境中使用，并且与实际的系统或组件相互作用。</p><p>使用桩程序的好处包括：</p><ul><li>解耦测试环境：通过使用桩程序，测试环境可以与外部依赖解耦，减少测试的复杂性和依赖性。</li><li>提高测试效率：桩程序可以模拟特定的场景和条件，使测试更加可控和可重复，从而提高测试的效率。</li><li>并行开发：通过使用桩程序，可以使开发和测试团队可以并行工作，而不受尚未完成的组件的影响。</li></ul><p><strong>驱动程序</strong><br>驱动程序（Driver）是一种计算机程序或模块，用于<strong>与硬件设备或操作系统进行通信和控制</strong>。它充当了软件与硬件之间的接口，使得应用程序能够与硬件设备交互并利用其功能。</p><p>驱动程序的主要功能包括：</p><ol><li>设备通信：驱动程序负责与硬件设备进行通信，发送指令和接收数据。它使用硬件接口和协议，以确保应用程序与设备之间的正确和可靠的通信。</li><li>硬件控制：驱动程序控制硬件设备的各种操作和功能。它可以发送配置参数、控制设备状态、执行特定的硬件操作等。</li><li>数据传输：驱动程序处理数据在应用程序和设备之间的传输。它可以负责数据的缓冲、转换和传输协议的实现。</li><li>错误处理：驱动程序处理硬件设备或通信错误。它可以检测和处理错误情况，并提供错误报告和恢复机制。</li></ol><p>驱动程序通常是特定硬件设备或操作系统的一部分，或者由硬件制造商提供。它们可以是操作系统内核的一部分，也可以作为独立的软件模块加载到操作系统中。驱动程序与操作系统紧密相关，需要与操作系统的版本和硬件架构相匹配。</p><p>在操作系统中，驱动程序的安装和配置通常由操作系统自动处理。当插入新的硬件设备时，操作系统会自动加载相应的驱动程序，并与设备建立连接和通信。在某些情况下，用户可能需要手动安装或更新驱动程序，以确保硬件设备的正常工作和兼容性。</p><h2 id="3-系统测试">3.系统测试</h2><p><strong>什么是系统测试？</strong></p><p>​系统测试（System Testing）是软件测试的一种<code>阶段</code>，它旨在<strong>验证</strong>整个软件系统在符合需求和规格说明书的情况下的功能、性能、稳定性和可靠性。</p><p><strong>典型系统测试对象：</strong></p><p>l系统管理手册和用户操作手册；</p><p>l系统功能和非功能需求；</p><p>l系统中使用的数据。</p><p><strong>系统测试主要内容：</strong></p><ul><li><p>l用户界面测试</p></li><li><p>l安装/卸载测试</p></li><li><p>l文档测试</p></li><li><p>l 回归测试</p></li><li><p>l压力测试</p></li><li><p>l容量测试</p></li><li><p>l安全测试</p></li><li><p>l功能测试；</p></li><li><p>l性能测试；</p></li><li><p>l安全性测试。</p></li></ul><p><strong>系统测试策略</strong></p><ul><li>l手工测试；</li><li>l自动化测试。</li></ul><p><strong>系统测试的方法：</strong></p><ul><li>l黑盒测试方法</li></ul><p><strong>系统测试是在集成测试完成之后进行的，它对整个系统进行端到端的测试</strong>，以确保系统在各种情况下都能正常运行。系统测试主要关注以下方面：</p><ol><li>功能测试：验证系统的功能是否符合需求和规格说明书。测试人员会根据系统的功能规范和用例，逐个测试系统的各个功能模块，并检查其是否按照预期进行操作和产生正确的输出。</li><li>性能测试：评估系统在各种负载和压力下的性能表现。这包括测试系统的响应时间、吞吐量、并发性能、资源利用率等，并确保系统能够在预期的性能指标范围内运行。</li><li>安全性测试：检查系统的安全性，验证系统是否受到潜在的安全威胁，如身份验证、访问控制、数据加密等，并进行漏洞扫描和渗透测试，以确保系统的安全性和防护能力。</li><li>兼容性测试：验证系统在不同的操作系统、浏览器、设备和网络环境下的兼容性。测试人员会测试系统在各种平台上的运行情况，确保系统能够在不同环境下正常工作。</li><li>可靠性测试：评估系统的稳定性和可靠性。测试人员会模拟各种故障和异常情况，如断电、网络中断、数据丢失等，以确保系统能够正确处理和恢复。</li><li>用户界面测试：测试系统的用户界面是否友好、易用，并符合用户体验的设计原则。测试人员会检查界面的布局、交互性和响应性，并确保用户可以轻松地完成各项任务。</li><li>回归测试：在系统进行修改或更新后，重新运行之前的测试用例，以确保修改没有引入新的错误或导致现有功能的退化。</li></ol><h1>五、测试类型</h1><p>​从测试目标的角度， 可以分为更多的测试类型，包括回归测试、 功能测试、 性能测试、 Alpha测试、Beta测试、 压力测试、 负载测试、 安全性测试、 配置测试、 安装测试、 可用性测试、 可恢复性测试等。</p><h2 id="1-接口测试">1.接口测试</h2><p>测试系统间接口的一种测试，测试的对象主要是接口，主要是测试外部系统与所测系统之间以及内部系统之间的交互点。</p><p><strong>原理:</strong></p><p>是通过<strong>测试程序模拟客户端向服务器发送请求报文</strong>，服务器接收请求报文后对相应的报文做出处理然后再把应答报文发送给客户端，客户端接收应答报文这一个过程。</p><p><strong>目的：</strong></p><p>测试接口的正确性和稳定性（持续集成是接口测试的核心）。</p><p><strong>内容：</strong></p><p><strong>单一接口测试</strong>主要测试的是输入输出值，一些具有业务意义的值需要特别测试（例如，1和2分别代表两个测试场景，那么就不能够把他们看成是等价类，需要分开测试</p><p><strong>组合接口测试</strong>主要是通过组合多个单一接口，来测试一个业务场景</p><p>Example：测试购物网站的一个下单的功能，那么因为在下单之前还有一些流程，所以要测试一个场景。</p><p>测试：搜索商品 --&gt; 选中商品 --&gt; 添加进购物车 --&gt; 提交订单 --&gt;支付（提交订单时还涉及到地址的选取等）</p><p>[注：涉及到如果使用从cookie或者session在本例中的区别：如果使用cookie加入购物车，那么换一台电脑购物车里的商品就不存在了，但如果使用的是session，购物车里面的东西就一直存在，即：cookie是本机作用的，session不止于本机作用</p><p><strong>结构检查</strong></p><p>（1）检查返回值的结构是否正确，如是json类型还是xml类型的数据</p><p>（2）字段名称是否正确等</p><p><strong>HTTP</strong>：</p><p><strong>HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。</strong></p><p>HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003305627.png" alt="image-20230621003305627"></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003417932.png" alt="image-20230621003417932"></p><table><thead><tr><th>序号</th><th>方法</th><th>描  述</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td>请求读取一个Web页面</td></tr><tr><td>2</td><td>HEAD</td><td>请求读取一个Web页面的首部</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>4</td><td>PUT</td><td>请求存储一个Web页面</td></tr><tr><td>5</td><td>DELETE</td><td>删除Web页面</td></tr><tr><td>6</td><td>CONNECT</td><td>HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003512949.png" alt="image-20230621003512949"></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003529343.png" alt="image-20230621003529343"></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230621003550668.png" alt="image-20230621003550668"></p><h2 id="2-性能测试">2.性能测试</h2><p>虽然强度测试、压力测试和负载测试在软件测试领域都与系统性能相关，但它们的重点和目标略有不同。下面是它们的区别：</p><ol><li><strong>强度测试（Stress Testing）</strong>：<ul><li>目标：评估系统在超出正常工作负载条件下的性能和稳定性。</li><li>重点：测试系统在负载超出设计限制时的表现和反应。</li><li>方法：将系统暴露在高负载、极限条件下，并持续施加压力。</li><li>目的：识别系统在高负载条件下的性能瓶颈、资源耗尽、内存泄漏等问题。</li></ul></li><li><strong>压力测试（Load Testing）</strong>：<ul><li>目标：评估系统在正常工作负载下的性能和稳定性。</li><li>重点：测试系统在正常负载下的性能指标，如响应时间、吞吐量等。</li><li>方法：模拟实际用户的并发访问，并逐渐增加负载，观察系统的性能表现。</li><li>目的：确定系统的瓶颈、性能指标，并保证系统在正常负载下的可靠性和性能要求。</li></ul></li><li><strong>负载测试（Load Testing）：</strong><ul><li>目标：评估系统在不同工作负载条件下的性能和稳定性。</li><li>重点：测试系统在不同负载级别下的性能表现和资源消耗情况。</li><li>方法：通过模拟多个并发用户或大量数据处理等操作，施加不同的负载。</li><li>目的：确定系统在不同负载情况下的性能瓶颈、资源需求和系统行为。</li></ul></li></ol><p>总结来说，强度测试主要关注系统在超出设计限制的极限负载下的表现，压力测试关注系统在正常工作负载下的性能指标，而负载测试则在不同负载级别下评估系统的性能和资源消耗情况。这些测试方法的目的都是为了确保系统在不同负载条件下的可靠性、稳定性和性能要求。</p><hr><p><strong>性能测试</strong>是一种软件测试方法，用于评估系统、应用程序或组件在不同负载条件下的性能表现。其目的是测量系统的响应时间、吞吐量、并发性能和稳定性，以确定系统在实际使用情况下的性能是否符合预期。</p><p>性能测试涉及模拟和测量系统在不同负载条件下的行为，并收集相关指标以评估系统性能。以下是一些常见的性能测试指标：</p><ol><li><p><strong>响应时间（Response Time）：</strong> 衡量系统对请求作出响应的时间。它是从发送请求到接收到响应所经过的时间。较短的响应时间表示系统快速响应用户请求。</p></li><li><p><strong>吞吐量（Throughput）：</strong> 衡量系统在单位时间内能够处理的请求数量。它表示系统的处理能力和效率。较高的吞吐量表示系统可以处理更多的请求。</p></li><li><p><strong>并发用户数（Concurrency）：</strong> 表示同时使用系统的用户数量。它用于评估系统在高并发情况下的性能表现。</p></li><li><p><strong>负载测试（Load Testing）：</strong> 在正常或预期的工作负载条件下，测试系统的性能表现。负载测试通常模拟实际用户数量，并观察系统在此负载下的响应时间和吞吐量。</p></li><li><p><strong>压力测试（Stress Testing）：</strong> 将系统推至其负载极限，并观察系统在此负载下的性能表现。压力测试旨在评估系统在高负载条件下的稳定性和性能。</p></li><li><p><strong>稳定性测试（Stability Testing）：</strong> 在长时间运行的情况下，测试系统的性能和稳定性。它可以检测系统是否存在内存泄漏、资源耗尽等问题。</p></li><li><p><strong>资源利用率（Resource Utilization）：</strong> 测量系统在运行过程中使用的资源，如 CPU、内存、网络带宽等。资源利用率指标可以帮助评估系统的效率和性能。</p></li><li><p><strong>容量规划（Capacity Planning）：</strong> 根据系统的性能测试结果和预期的用户需求，规划系统所需的硬件、网络和资源配置，以确保系统能够满足未来的用户需求。</p></li></ol><p>这些指标和概念在性能测试中起着重要的作用，帮助评估系统的性能表现、发现性能瓶颈和优化系统性能。根据具体的测试目标和需求，可以选择适当的指标进行性能测试，并根据测试结果进行系统优化和调整。</p><hr><p><strong>压力测试：</strong></p><p>​压力测试（Stress Testing）是一种软件测试方法，旨在<strong>评估系统在负载增加的情况下的稳定性、性能和可靠性</strong>。压力测试通过模拟大量用户并在系统处于高负载状态下执行各种操作，以确定系统的性能极限、响应时间和资源利用情况。</p><p>在进行压力测试时，通常会使用以下方法和技术：</p><ol><li>定义测试场景：确定测试的目标、范围和关注点，制定测试计划和测试策略。</li><li>设置负载：创建并模拟大量用户，并在系统上执行各种操作，如并发访问、大量数据处理、频繁的请求等，以增加系统的负载。</li><li>监测系统指标：监测系统的性能指标，如响应时间、吞吐量、并发用户数、CPU和内存使用情况等。</li><li>分析和评估结果：根据监测到的指标和性能数据，分析系统在不同负载下的表现，确定性能瓶颈和潜在问题。</li></ol><p>压力测试的目标包括：</p><ul><li>确定系统的性能极限：通过逐渐增加负载，测试系统在负载达到极限时的性能表现，以确定系统的容量和稳定性。</li><li>发现性能瓶颈：通过分析系统在高负载下的性能指标，确定系统中的瓶颈点和性能瓶颈，以便进行优化和改进。</li><li>评估系统的可靠性：测试系统在高负载和压力下的稳定性和可靠性，发现潜在的问题和风险，并确保系统能够正常运行。</li><li>验证系统的扩展性：通过测试系统在不同负载下的性能，评估系统在未来的扩展和增长中的可行性和可扩展性。</li></ul><p>压力测试可以帮助发现系统在高负载下的性能瓶颈、资源消耗过度、响应时间延迟等问题，并提供有关系统容量规划和优化改进的重要信息。它对于确保系统在真实使用情况下的稳定性和可靠性非常重要。</p><p><strong>负载测试：</strong></p><p>​负载测试（Load Testing）是一种测试方法，旨在评估系统在正常和峰值负载条件下的性能和稳定性。它主要关注<strong>系统在高负载情况下</strong>的<strong>响应时间、吞吐量、并发用户数以及系统资源的利用情况</strong>。</p><p>负载测试的目标是确定系统在预期工作负载下的性能限制和瓶颈，并验证系统是否能够满足预期的性能要求。通过负载测试，可以识别和解决性能问题，提高系统的可靠性、稳定性和可扩展性。</p><p>在进行负载测试时，通常会模拟真实的用户行为和交互，并通过生成虚拟用户或并发请求来模拟负载条件。测试工具和框架可用于自动化执行负载测试，并提供性能指标和报告，以帮助评估系统的性能表现。</p><p>以下是负载测试的一些关键方面：</p><ol><li><p>负载模型：定义和创建合适的负载模型，以模拟真实世界中的用户行为和交互。这包括模拟用户数量、并发请求、事务处理量等。</p></li><li><p>性能指标：定义和监测关键性能指标，如响应时间、吞吐量、并发用户数、错误率等。这些指标可以帮助评估系统的性能表现，并与预期的性能要求进行比较。</p></li><li><p>测试环境：准备适当的测试环境，包括硬件、网络、数据库和应用程序配置。测试环境应尽可能接近生产环境，以确保准确的性能评估。</p></li><li><p>负载生成工具：使用适当的负载生成工具来模拟并发请求和用户行为。这些工具可以帮助生成大量的虚拟用户，以模拟真实的负载条件。</p></li><li><p>分析和优化：分析负载测试结果，识别性能瓶颈和问题，并提出相应的优化建议。这可以包括系统配置调整、代码优化、资源调整等措施。</p></li></ol><p>通过负载测试，可以发现系统在高负载条件下的性能瓶颈和问题，帮助团队制定性能改进计划，并确保系统在真实环境中的稳定性和可靠性。</p><p><strong>强度测试：</strong></p><p>​强度测试（Stress Testing）是一种测试方法，旨在评估系统在<strong>超出正常工作负载条件下的性能和稳定性</strong>。它主要关注系统在极限负载和资源耗尽的情况下的行为和反应。</p><p>强度测试的目标是确定系统在负载超出其设计限制时的表现，验证系统的可靠性、稳定性和恢复能力。通过强度测试，可以识别系统在高负载条件下的性能瓶颈、资源耗尽、内存泄漏等问题，并采取相应的措施进行优化和改进。</p><p>在进行强度测试时，会将系统暴露在高负载、极限条件下，并持续施加压力，以测试系统的极限和边界情况。这可能包括同时启动大量的并发请求、增加数据量、模拟网络延迟等。</p><p>以下是强度测试的一些关键方面：</p><ol><li><p>负载模型：定义和创建具有极限负载的负载模型，以模拟系统在超出正常工作负载的情况下的行为。这包括模拟大量的并发用户、大量的数据处理、高频率的请求等。</p></li><li><p>资源监测：监测系统资源的使用情况，包括内存、CPU、磁盘、网络等。通过监测资源的消耗情况，可以确定系统在高负载条件下是否存在资源耗尽的问题。</p></li><li><p>容错和恢复能力：测试系统在遇到异常情况或资源耗尽时的容错和恢复能力。这包括测试系统的崩溃恢复、错误处理机制、故障转移等能力。</p></li><li><p>性能指标：定义和监测关键性能指标，如响应时间、吞吐量、错误率等。这些指标可以帮助评估系统在极限负载下的性能表现，并与预期的性能要求进行比较。</p></li><li><p>容量规划：根据强度测试的结果，评估系统的容量和扩展需求。这可以帮助团队确定系统的极限容量，以及在面临更高负载时需要采取的扩展措施。</p></li></ol><p>通过强度测试，可以评估系统在负载极限情况下的表现，发现潜在的性能瓶颈和问题，并采取相应的优化和改进措施，以确保系统在极限条件下的可靠性和稳定性。</p><hr><ol><li><strong>链接测试（Link Testing）：</strong> 链接测试主要关注软件内部各个模块之间的链接和交互。它确保软件在模块集成时，各个模块之间的接口和依赖关系正常工作。链接测试通常是软件开发过程中的一部分，以验证模块之间的正确连接和通信。</li><li><strong>兼容性测试（Compatibility Testing）：</strong> 兼容性测试是验证软件在不同环境、平台或配置下的兼容性和互操作性。它确保软件能够在不同的操作系统、浏览器、设备或网络条件下正常运行，并且与其他软件或硬件组件协同工作。兼容性测试有助于确保软件具有广泛的适用性和稳定性。</li><li><strong>性能测试（Performance Testing）：</strong> 性能测试评估软件在特定负载和压力条件下的性能表现。它包括测量响应时间、吞吐量、并发用户数和资源利用率等指标，以确定系统的性能瓶颈、瓶颈原因和优化需求。性能测试旨在确保软件在实际使用情况下具有良好的性能和可伸缩性。</li><li><strong>安全测试（Security Testing）：</strong> 安全测试旨在评估软件的安全性和防护能力。它涉及识别和验证软件中的潜在安全漏洞、弱点和威胁。安全测试可以包括网络漏洞扫描、身份验证和授权测试、数据加密和防御测试等。通过安全测试，可以发现和修复潜在的安全风险，保护软件和用户的数据安全。</li></ol><h2 id="3-渗透测试"><strong>3.渗透测试</strong></h2><p>​渗透测试，也被称为漏洞评估或白帽黑客测试，是一种旨在评估计算机系统、网络或应用程序的安全性的测试方法。</p><p>​渗透测试的目标是<strong>模拟真实的黑客攻击</strong>，以发现系统中的漏洞、弱点和安全风险，并提供有关如何修复这些问题的建议。</p><blockquote><p>渗透测试的目标是模拟真实的黑客攻击，以发现系统中的漏洞、弱点和安全风险，并提供有关如何修复这些问题的建议。渗透测试通常包括以下步骤：</p><ol><li>信息收集：收集有关目标系统的信息，例如网络拓扑、IP地址范围、域名、系统版本和服务等。这可以通过公开可用的信息、网络扫描工具和漏洞数据库等来完成。</li><li>漏洞扫描：使用自动化工具进行漏洞扫描，以发现目标系统中存在的已知漏洞。这些工具会检查系统中的常见漏洞、配置错误和安全弱点。</li><li>漏洞利用：通过利用已知漏洞或弱点，尝试进一步渗透目标系统。这可能涉及使用特定的工具或编写自定义脚本来利用系统中的漏洞。</li><li>权限提升：在成功进入目标系统后，试图提升权限以获得更高级别的访问权限。这可以通过提取密码、利用系统配置错误或操纵用户权限等方式来实现。</li><li>横向移动：如果目标系统是一个网络环境，渗透测试人员可能试图在网络中横向移动，获取对其他系统和资源的访问权限。</li><li>数据获取：在渗透测试过程中，收集有关系统和应用程序的详细信息，包括发现的漏洞、弱点和可能的攻击路径。</li><li>报告编写：根据渗透测试的结果，编写详细的报告，包括发现的漏洞、成功渗透的路径、潜在的风险和建议的修复措施。</li></ol><p>渗透测试需要具备深入的计算机和网络知识，以及对常见漏洞和攻击技术的理解。它有助于组织和企业评估其系统的安全性，并采取适当的措施来保护其敏感数据和资产免受潜在的黑客攻击。渗透测试通常由专门的安全团队或第三方安全公司执行，以提供客观和独立的评估结果。</p></blockquote><h2 id="4-回归测试">4.<strong>回归测试</strong></h2><p>​回归测试（Regression Testing）是在<strong>对软件进行更改或修复后</strong>，<strong>重新运行既有测试用例</strong>以确保已有功能没有受到影响的过程。其目的是验证修改后的软件在进行更改的同时仍然保持原有功能的正确性。</p><blockquote><p>回归测试的主要目标是检测已有功能是否被破坏或受到不良影响，并帮助保证软件在修改后仍然能够按照预期进行工作。以下是回归测试的一些关键特点和目的：</p><ol><li>验证修改的影响：当进行软件修改、增加新功能或修复缺陷时，回归测试旨在验证这些修改对现有功能的影响。通过重新运行既有的测试用例，可以确定是否引入了新的问题或导致现有功能的故障。</li><li>防止功能退化：回归测试可以帮助检测功能退化的情况。功能退化是指在进行软件修改时，原本正常工作的功能因修改而变得不可用或产生错误。通过回归测试，可以确保软件的核心功能在修改后仍然正常运行。</li><li>确保软件稳定性：回归测试对于确保软件的稳定性和可靠性非常重要。通过重新运行测试用例，可以及时发现和解决引入的错误，从而提高软件的质量和可靠性。</li><li>提高软件维护效率：通过回归测试，可以快速定位和解决修改引起的问题。它可以帮助缩短故障修复的时间，减少维护成本，并提高团队的工作效率。</li></ol><p>回归测试可以采用不同的方法和技术，包括自动化测试和手工测试。自动化回归测试可以利用测试工具和脚本来执行测试用例，并快速发现问题。手工回归测试则需要测试人员手动运行测试用例并检查结果。</p><p>回归测试的频率和范围取决于项目的具体情况和变更的规模。一般来说，较小的变更可能只需要执行部分回归测试，而较大的变更可能需要执行全面的回归测试。</p><p>总之，回归测试是软件开发过程中不可或缺的一部分，它有助于保证软件质量、稳定性和可靠性，同时提高团队的工作效率和客户满意度。</p></blockquote><h2 id="5-α测试">5.<strong>α测试</strong></h2><p>​α测试（Alpha Testing）是软件开发过程中的一种测试方法，旨在在软件开发的早期阶段，由<strong>开发团队内部或有限的用户群体</strong>进行测试。它通常在软件开发的内部环境中进行，以发现和解决潜在的问题和缺陷。</p><blockquote><p>​α测试的主要目标是评估软件在功能、性能和稳定性等方面的整体质量，并提供反馈和建议以改进软件。以下是α测试的一些关键特点和目的：</p><ol><li>内部测试：α测试是由开发团队内部或特定的用户群体进行的测试，而不是广泛发布给所有最终用户。这使得测试团队能够在一个受控的环境中进行测试，并快速获取用户的反馈。</li><li>功能测试：α测试主要关注软件的功能性。测试团队会根据软件的规格说明和设计文档执行测试用例，以验证软件的功能是否按照预期工作。</li><li>性能测试：除了功能性测试，α测试也可以涉及对软件性能的初步评估。测试团队可以检查软件的响应时间、资源利用情况和容错性能等方面，以确保软件在预期的负载和环境条件下正常运行。</li><li>缺陷发现：α测试旨在发现潜在的问题和缺陷。测试团队会记录并报告发现的问题，并与开发团队合作解决这些问题。这有助于提高软件的质量和稳定性。</li><li>用户反馈：α测试也为测试团队提供了与用户进行直接交流和反馈的机会。用户可以提供对软件的使用体验、界面设计、功能需求等方面的意见和建议，以帮助改进软件。</li></ol><p>尽管α测试是在软件开发的早期阶段进行的，但它并不代表最终的软件质量。它是一个重要的测试阶段，旨在帮助发现和解决问题，并为软件的后续测试和改进提供反馈。</p><p>需要注意的是，α测试通常与β测试相互补充。α测试是在内部环境中进行的，而β测试是在真实用户环境中进行的，以获取更广泛的用户反馈。</p></blockquote><h2 id="6-s测试"><strong>6.ß测试</strong></h2><p>​β测试（Beta Testing）是软件开发过程中的一种测试方法，它是在软件开发的后期阶段，将软件<strong>提供给真实用户</strong>进行测试和评估。β测试的目的是验证软件在真实环境中的功能、性能、兼容性和稳定性，并收集用户的反馈意见。</p><blockquote><p>以下是β测试的一些关键特点和目的：</p><ol><li>外部测试：β测试是在真实用户群体中进行的测试，将软件提供给最终用户使用并收集他们的反馈。这种测试方法可以帮助开发团队了解用户的真实需求和使用体验。</li><li>真实环境测试：β测试将软件放置在真实的操作环境中进行测试，以确保软件能够适应不同的硬件、操作系统和网络条件。这有助于发现和解决与特定环境相关的问题。</li><li>多样性测试：β测试涉及多种类型的测试，包括功能测试、性能测试、兼容性测试和用户体验测试等。测试团队会执行一系列测试用例，以验证软件在各个方面的表现。</li><li>用户反馈：β测试的一个重要目标是收集用户的反馈意见和建议。用户可以报告发现的问题、提出改进建议，甚至分享他们的使用体验和感受。这些反馈对于改进软件并满足用户需求至关重要。</li><li>验证功能：β测试还用于验证软件是否满足规格说明和用户需求。测试团队会核对软件的功能是否按照预期工作，并确保软件的稳定性和可靠性。</li></ol><p>β测试通常是在软件开发的最后一个阶段进行的，当软件已经具备一定的功能和稳定性时，才将其提供给用户进行测试。通过β测试，开发团队可以收集大量真实用户的反馈意见，从而改进软件，并确保它的质量和用户满意度。</p><p>需要注意的是，β测试不是软件发布的最终阶段。在β测试之后，可能还会进行修复和改进，以解决发现的问题，并进一步提高软件的质量。</p></blockquote><p><strong>性能测试概念，性能测试指标</strong></p><p>性能测试的指标用于<strong>评估系统在特定负载条件下的性能表现</strong>。下面是一些常见的性能测试指标：</p><ol><li><p>响应时间（Response Time）：系统处理请求所花费的时间，通常以毫秒为单位。响应时间是衡量系统性能的重要指标，较短的响应时间表示系统响应速度快。</p></li><li><p>吞吐量（Throughput）：系统单位时间内处理的请求数量。吞吐量反映了系统在一定时间内处理能力的大小，较高的吞吐量表示系统能够处理更多的请求。</p></li><li><p>并发用户数（Concurrent Users）：系统同时处理的用户数量。并发用户数反映了系统在同时处理多个用户请求时的性能表现，较高的并发用户数表示系统具有更好的并发处理能力。</p></li><li><p>服务器资源利用率（Server Resource Utilization）：系统在负载条件下的服务器资源利用情况，包括 CPU 使用率、内存占用、网络带宽利用率等。服务器资源利用率反映了系统在高负载情况下的资源消耗情况，可以帮助确定系统的扩展需求。</p></li><li><p>错误率（Error Rate）：系统在处理请求过程中出现错误的比例。错误率反映了系统在高负载条件下的稳定性和可靠性，较低的错误率表示系统的稳定性较高。</p></li><li><p>平均并发时间（Mean Time to Concurrency）：系统从接收请求到开始处理请求的平均时间。平均并发时间反映了系统在高负载条件下的响应速度，较短的平均并发时间表示系统可以迅速处理请求。</p></li><li><p>可扩展性（Scalability）：系统在增加负载时能否保持稳定的性能表现。可扩展性反映了系统在负载增加时的性能表现和资源利用情况，较好的可扩展性意味着系统能够有效地应对负载增加。</p></li></ol><p>以上是一些常见的性能测试指标，具体选择和关注哪些指标应根据系统特点、用户需求和测试目的进行确定。不同的应用场景可能会有不同的重点指标，因此在进行性能测试时需要结合实际情况进行评估和分析。</p><h1>六、测试手段</h1><p>从测试执行方式的角度， 可以分为手动测试、 自动化测试和半自动化测试。</p><p><strong>自动化测试与手工测试的区别：</strong></p><ol><li><strong>执行方式：</strong> 自动化测试是通过编写脚本、使用自动化工具或框架来执行测试过程，而手工测试是由测试人员手动执行测试步骤。</li><li><strong>效率和速度：</strong> 自动化测试相对于手工测试可以更快地执行测试用例，因为测试脚本可以自动化地重复执行，节省了大量的时间和人力资源。</li><li><strong>重复性：</strong> 自动化测试可以重复执行相同的测试用例，确保每次测试的一致性，而手工测试容易受到人为因素的影响，每次执行结果可能不同。</li><li><strong>覆盖范围：</strong> 自动化测试通常用于执行大规模的测试用例集合，可以覆盖更广泛的功能和场景，而手工测试更适用于少量、复杂或需要人工判断的测试用例。</li><li><strong>可靠性：</strong> 自动化测试执行的结果更可靠，因为测试脚本不会受到人为错误的影响，而手工测试可能存在人为疏漏或误操作的风险。</li><li><strong>适用性：</strong> 自动化测试适用于稳定的功能和场景，例如回归测试；而手工测试适用于新功能的探索、用户体验测试和复杂的场景模拟。</li><li><strong>成本和投入：</strong> 自动化测试需要一定的时间和资源来编写和维护测试脚本，因此在初期投入较高；而手工测试相对较低成本，但在长期和重复的测试过程中，手工测试的成本会逐渐增加。</li></ol><h2 id="1-手工测试"><strong>1.手工测试</strong></h2><p>手工测试（Manual Testing）是一种软件测试方法，通过<strong>人工执行测试用例</strong>来验证软件系统的功能、性能、用户界面和其他方面的正确性和质量。与自动化测试相对，手工测试不依赖于自动化工具或脚本，而是由测试人员直接进行操作和观察。</p><blockquote><p>手工测试通常包括以下步骤：</p><ol><li>需求分析：测试人员仔细阅读软件需求文档、设计文档或用户故事，了解系统的功能和预期行为。</li><li>测试计划编制：测试人员根据需求和项目要求，制定测试策略和测试计划。测试计划包括测试范围、测试目标、测试资源和时间安排等内容。</li><li>测试用例设计：根据需求和设计文档，测试人员编写测试用例，描述测试步骤、输入数据和预期结果。测试用例应覆盖系统的各个功能和场景。</li><li>环境准备：测试人员设置测试环境，包括安装软件、配置系统和准备测试数据等。</li><li>执行测试用例：测试人员按照测试计划和测试用例的要求，手动执行测试用例。他们将输入测试数据、操作用户界面、触发系统功能，并观察系统的响应和结果。</li><li>缺陷报告：如果测试中发现了问题、错误或缺陷，测试人员会编写缺陷报告，详细描述缺陷的现象、重现步骤和影响程度。他们可能还会提供截图或录屏作为证据。</li><li>缺陷跟踪和验证：测试人员与开发团队或质量保障团队合作，跟踪缺陷的修复进度，并进行验证测试，确保缺陷得到正确修复。</li><li>回归测试：当缺陷修复后，测试人员可能需要执行回归测试，验证修复后的系统是否仍然正常工作，并确保修复过程没有引入新的问题。</li></ol><p>手工测试的优点包括灵活性、适应性和直观性。测试人员可以根据实际情况进行测试，并直接观察和评估软件的行为和用户体验。然而，手工测试可能比较耗时和繁琐，特别是对于大型和复杂的软件系统。因此，在某些情况下，自动化测试可以提供更高效和可重复的测试方法。</p><p>手工测试和自动化测试通常是结合使用的，根据具体的测试需求和资源限制，选择合适的测试方法和工具进行软件测试，以确保软件的质量和稳定性。</p></blockquote><h2 id="2-自动化测试"><strong>2.自动化测试</strong></h2><p>​自动化测试（Automated Testing）是一种使用<strong>自动化工具或脚本来执行</strong>测试任务和验证软件系统的方法。与手工测试相比，自动化测试使用编写的脚本或测试工具来代替人工操作，从而提高测试效率、减少人为错误，并支持反复执行测试用例。</p><p>​自动化测试可以应用于不同层次和类型的软件测试，包括单元测试、集成测试、系统测试和回归测试等。它可以涵盖功能测试、性能测试、安全测试和界面测试等不同方面的测试需求。</p><blockquote><p>以下是自动化测试的一些关键特点和优势：</p><ol><li>提高测试效率：自动化测试可以快速执行大量的测试用例，比手工测试更高效。测试人员可以节省大量的时间和精力，特别是在需要频繁执行回归测试的场景下。</li><li>降低人为错误：自动化测试消除了人为操作中的错误和遗漏。脚本和工具可以准确地模拟用户操作，避免了手工测试中可能出现的疏忽和错误。</li><li>可重复性和一致性：自动化测试可以确保测试过程的一致性和可重复性。相同的测试用例可以在不同的环境中重复执行，确保测试结果的一致性。</li><li>提高覆盖率：自动化测试可以实现更广泛的测试覆盖，包括各种边界条件、异常情况和不同的测试场景。通过编写多样化的测试脚本，可以更全面地覆盖软件系统的功能和特性。</li><li>提高质量和稳定性：自动化测试可以更早地发现和报告问题、错误和缺陷。它可以帮助团队更快速地进行修复和验证，提高软件系统的质量和稳定性。</li></ol><p>自动化测试也有一些考虑因素和限制：</p><ol><li>技术要求：自动化测试通常需要具备一定的编程和脚本编写能力。测试人员需要熟悉测试工具和相关技术，以便有效地编写和维护测试脚本。</li><li>初始投入和维护成本：自动化测试需要一定的初始投入和开发时间。编写和维护测试脚本可能需要额外的资源和成本，特别是在项目早期或需求频繁变更的情况下。</li><li>无法涵盖所有测试情况：自动化测试不能涵盖所有可能的测试情况和使用场景。某些测试任务可能需要手工测试来进行人工观察和评估。</li><li>界面和用户体验测试：某些测试类型，如用户界面测试和用户体验测试，可能需要人工操作和主观评估，无法完全自动化。</li></ol><p>综上所述，自动化测试在软件测试中具有重要的作用，并且可以带来许多优势。然而，在实施自动化测试之前，需要仔细评估测试需求、项目资源和技术能力，以确定何时和如何使用自动化测试工具和方法。</p></blockquote><hr><p><strong>自动化测试的模型、数据驱动的原理</strong>：</p><ol><li><p><strong>自动化测试的模型：</strong><br>自动化测试的模型是指在进行自动化测试时所采用的框架或模式，用于<strong>组织和管理测试用例、执行测试、生成测试报告等</strong>。常见的自动化测试模型包括线性模型、模块化模型和关键字驱动模型。</p><ul><li>线性模型：按照线性的顺序执行测试用例，适用于简单的测试场景。</li><li>模块化模型：将测试用例拆分为模块或功能，并组织成模块化的结构，便于维护和复用。</li><li>关键字驱动模型：将测试用例和测试步骤定义为关键字，并通过关键字的组合和参数化实现测试执行，提高测试的灵活性和可维护性。</li></ul><p>不同的自动化测试模型适用于不同的测试需求和项目特点，选择合适的模型可以提高自动化测试的效率和可靠性。</p></li><li><p><strong>数据驱动的原理：</strong><br>数据驱动测试是一种测试方法，它基于<strong>不同的测试数据对系统进行测试</strong>，以验证系统在<strong>不同数据输入下的行为和结果</strong>。数据驱动测试的原理是将测试用例和测试数据分离，将测试数据从测试用例中独立出来，以实现更广泛的测试覆盖和更高的可维护性。</p><p>数据驱动测试的关键是将测试数据从测试逻辑中抽离，通常使用外部数据源（如Excel、CSV文件、数据库等）来存储测试数据。测试用例通过读取数据源中的测试数据，进行参数化的测试执行。这样做的好处是可以通过修改数据源中的测试数据，实现快速修改和扩展测试用例，而无需修改测试逻辑。</p><p>数据驱动测试的优势在于可以更全面地覆盖不同的测试场景，减少了测试用例的重复编写，提高了测试效率和可维护性。同时，数据驱动测试也使得测试数据的管理更加灵活，方便进行数据的维护和更新。</p></li></ol><p>总结起来，自动化测试的模型是指用于组织和管理测试用例的框架或模式，而数据驱动的原理是将测试数据与测试用例分离，通过外部数据源实现参数化的测试执行。这两个概念在自动化测试中常常结合使用，以提高测试的效率、灵活性和可维护性。</p><hr><h1>五、应用题</h1><h2 id="1-路径测试">1.路径测试</h2><p>（根据流程图画出控制流图，计算环形复杂度，写出基本路径即合，设计测试用例）。</p><h2 id="2-逻辑覆盖测试">2.逻辑覆盖测试</h2><p>（根据程序逻辑结构，设计满足覆盖要求的测试用例（代码发覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖））。</p><h2 id="3-黑盒测试">3.黑盒测试</h2><p>（因果图测试法、决策表法、场景法、等价类划分）</p><h2 id="4-系统测试">4.系统测试</h2><p>（链接测试、兼容性测试、性能测试、安全测试）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、软件测试相关概念&lt;/h1&gt;
&lt;p&gt;不同角度的测试分类&lt;/p&gt;
&lt;p&gt;（1） 从测试阶段或对象的角度， 可以分为&lt;code&gt;单元测试&lt;/code&gt;、&lt;code&gt;集成测试&lt;/code&gt;、 &lt;code&gt;系统测试&lt;/code&gt;和&lt;code&gt;验收测试&lt;/code&gt;；&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="软件工程" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件测试" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件开发" scheme="http://giyayonlib.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="http://giyayonlib.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常用网络协议整理</title>
    <link href="http://giyayonlib.com/2023/05/15/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%A4%A7%E5%85%A8%E6%95%B4%E7%90%86/"/>
    <id>http://giyayonlib.com/2023/05/15/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%A4%A7%E5%85%A8%E6%95%B4%E7%90%86/</id>
    <published>2023-05-15T05:22:03.469Z</published>
    <updated>2023-05-15T05:44:56.344Z</updated>
    
    <content type="html"><![CDATA[<h1>一、协议综述</h1><p><strong>1.七层模型：</strong></p><p>7、应用层   处理网络应用</p><p>6、表示层   数据表示，数据压缩</p><p>5、会话层   互联主机通信</p><p>4、传输层    端到端应带，分组排序，流量控制</p><p>3、网络层    分组传输和路由选择</p><p>2、链路层   传送以帧为单位的信息</p><p>1、物理层   二进制数据传输</p><p><strong>四层模型：</strong></p><table><thead><tr><th>应用层</th><th>HTTP、FTP、telnet、SMTP</th><th>SNMP、DNS、DHCP</th></tr></thead><tbody><tr><td></td><td>POP、DNS</td><td>TFTP</td></tr><tr><td></td><td></td><td></td></tr><tr><td>传输层</td><td>TCP</td><td>UDP</td></tr><tr><td>网络层</td><td>IP、ICMP、ARP、RARP</td><td></td></tr><tr><td>通信子网层</td><td>电话网，局域网，无线网</td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230513113044508.png" alt="image-20230513113044508"></p><p>参考文章：</p><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/index.html">IP知识百科 - 华为 (huawei.com)</a></p><p><a href="https://blog.csdn.net/reachwang/article/details/90553960">https://blog.csdn.net/reachwang/article/details/90553960</a></p><hr><h1>二、物理层</h1><h2 id="WLAN标准">WLAN标准</h2><table><thead><tr><th>EE802.11</th><th>标准</th><th>速度</th><th>技术</th></tr></thead><tbody><tr><td>802.11</td><td>2.4GHZ，ISM频段</td><td>1mb/s，2mb/s</td><td>扩频通信技术</td></tr><tr><td>802.11b</td><td>2.4GHZ，ISM频段</td><td>11mb/s</td><td>Cck技术</td></tr><tr><td>802.11a</td><td>5GHZ，U-NII频段</td><td>54mb/s</td><td>OFDM调制技术</td></tr><tr><td>802.11g</td><td>2.4GHZ,ISM频段</td><td>54mb/s</td><td>OFDM调制技术</td></tr><tr><td>802.11n</td><td>智能无线技术</td><td>300－600mb/s</td><td>MIMO与OFDM术</td></tr><tr><td>802.11ac</td><td>5GHZ</td><td>1Gb/s</td><td>MIMO与OFDM术</td></tr></tbody></table><h2 id="MAN标准">MAN标准</h2><p><strong>IEEE802.3ae 10Gb/s以太网</strong></p><table><thead><tr><th>10GBase-S</th><th>多模光纤</th><th>300m</th></tr></thead><tbody><tr><td>10GBase-L</td><td>单模光纤</td><td>10km</td></tr><tr><td>10GBase-E</td><td>单模光纤</td><td>40km</td></tr><tr><td>10GBase-LX4</td><td>单模光纤</td><td>10km</td></tr></tbody></table><p><strong>IEEE802.3an 10Gb/s以太网</strong></p><table><thead><tr><th>10GBase-T</th><th>双绞线</th><th>100m</th></tr></thead></table><p><strong>IEEE802.3ba 100Gb/s以太网</strong></p><table><thead><tr><th>IEEE802.3ba</th><th>100G</th><th>光纤</th></tr></thead></table><h2 id="LAN标准">LAN标准</h2><p><strong>IEEE 802.3u 100M</strong></p><table><thead><tr><th>100BASE-TX</th><th>5类非屏蔽双绞线</th><th>2对跳线</th><th>距离100m</th></tr></thead><tbody><tr><td>100BASE-FX</td><td>62.5/125多模光纤</td><td>2对用于收发</td><td>距离2000m</td></tr><tr><td>100BASE-T4</td><td>3类非屏蔽双绞线</td><td>4对用于收发</td><td>距离100m</td></tr></tbody></table><p><strong>多模光纤与单模光纤的特殊区别：</strong></p><blockquote><p>多模光纤使用发光二极管，单模光纤使用激光二极管。</p><p>多模光纤允许多束光纤穿过光纤，单模光纤比多模光纤采用的波长长。</p><p>单模光纤只允许一束光线穿过光纤，单模光纤传输频带宽，多模光纤传输频带窄。</p></blockquote><p><strong>局域网中双绞线可分为非屏蔽双绞线(UTP)和屏蔽双绞线(STP)两类</strong>:</p><blockquote><p>STP有金属包层，辐射小，价格高。</p><p>UTP分为3类，4类，5类和超5类4种。</p><p>3类UTP适应以太网(10mb/s)对传输介质的要求。(4类与3类差不多)</p><p>5类UTP因价廉质优为快速以太网(100Mb/s)首选。</p><p>超5类UTP为千兆以太网(1000Mb/s)</p></blockquote><p><strong>双绞线-568A和568B</strong></p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/clip_image002.jpg" style="zoom:80%;" /><p><strong>光纤覆盖分类（FTTX）：</strong></p><blockquote><p>FTTN，光纤到节点即光纤到弱电箱。【node节点】</p><p>FTTC，光纤到路边。【curb】路边</p><p>FTTZ，光纤到小区。【zone】地区</p><p>FTTH，光纤到户。【home】户</p><p>光纤布线系统测试指标包括：最大衰减值，波长窗口参数，回波损耗限值，与近端串扰无关，近端串扰用于测试双绞线。</p><p>通常请了下，信息插座安装在距离地面30→50CM高。</p></blockquote><p><strong>ADSL接入方式分为虚拟拨号和准专线两种:</strong></p><blockquote><p>采用虚拟拨号的用户需安装PPPOE或PPPOA客户端软件，以及类似于MODEM的拨号程序，输入用户名称和用户密码即可接到宽带接入点。</p><p>采用准专线方式的用户使用电信部门静态或动态分配的IP地址，开机即可接入internet。</p><p>家庭内，PC通过ADSLMODEM→分离器→入户接线盒→电话线→DSL接入复用器(DSLAM)连接ATM或IP网络。</p><p>话音线路通过：分离器→入户接线盒→电话线→DSL接入复用器，接入电话交换机。</p><p>局域网管理站轮询问题：最大支持设备=轮询时间（秒）÷一次查询时间（秒）</p><p>例如：假设某局域网，管理站每15min轮询管理设备一次，一次查询时间是200MS。则管理站最多可支持 15*60/0.2=4500个。</p></blockquote><h2 id="接入网">接入网</h2><p><strong>E1与T1问题</strong></p><blockquote><p>E1载波基本帧由32个子信道组成，其中30个子信道用于传送话音数据，2个子信道CH0和CH16用于传送控制命令，该基本帧的传送时间为125us。</p><p>在E1载波中，每个子信道的数据速率是64Kb/s，E1载波的控制开销占6.25%</p><p>E1信道的数据速率是2.048Mb/s</p><p>T1载波的每个信道的数据速率为64kb/s，T1信道的总数据速率是1.544Mb/s</p><p>E3的数据速率是34.368Mb/s ，T3信道的数据速率为44.736Mb/s</p></blockquote><p><strong>网络设备</strong></p><blockquote><p>中断器：工作物理层，起放大比特流作用</p><p>网桥：工作链路层，按要求选择MAC地址</p><p>路由器：工作网络层，路由选择，数据分组，计费等</p><p>网关：工作高层，执行不同的协议，将不同协义转换。</p><p>机械特性：接口的型状，尺寸的大小，引脚的数目和排列方式等。</p><p>电气特性：接口规定信号的电压、电流、阻抗、波形、速率及平衡特性等。</p><p>功能特性：接口引脚的意义、特性、标准。电压表示范围的含义。</p><p>过程特性：确定数据位流的传输方式，事件发生顺序。如：单工、半双工或全双工。</p><p>物理层协议有：</p><p>美国电子工业协会(EIA)的RS232，RS422，RS423，RS485等； 际电报电话咨询委员会(CCITT)的X.25、X.21等；</p><p>物理层的数据单位是位比特(BIT)，典型设备是集线器HUB。</p></blockquote><h1>三、数据链路层</h1><h2 id="CSMA-CD-载波监听多路访问-冲突检测">CSMA/CD(载波监听多路访问/冲突检测)</h2><p>CSMA/CD 含义：载波监听多点接入 / 碰撞检测 (Carrier Sense Multiple Access with Collision Detection) 。</p><p>1️⃣ 载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>2️⃣ 多点接入：表示许多计算机以多点接入的方式连接在一根总线上。<br>3️⃣ 碰撞检测：就是计算机边发送数据边检测信道上的信号电压大小。</p><blockquote><p>CSMA/CD采用二进制后退算法，保证系统的稳定性，有效分解冲突。</p><p>CSMA/CD，不适于所有802.3以太网，在10千兆位忽略了CSMA/CD。</p><p>非坚持：忙等待再侦听；不忙立即发送；减少冲突，信道利用率低：</p><p>I坚持：忙继续侦听；不忙立即发送；提高信道利用率，增大冲突：</p><p>p坚持：线路忙继续侦听；不忙时，根据p概率进行发送，</p><p>另外的1-p概率为继续侦听；有效平衡，但复杂：</p></blockquote><p><strong>CSMA/CA</strong></p><p><code>CSMA/CA（Carrier Sense Multiple Access with Collision Avoidance，载波侦听多路访问/冲突避免）</code>是一种随机接入机制，用于避免多个节点同时访问网络所带来的冲突问题。它主要用于无线局域网中。在发送数据之前，每个节点都会先监听信道是否空闲，如果信道空闲则发送数据，否则就等待</p><blockquote><p>CSMA/CA 协议适用于突发性业务。</p><p>各个发送站在两次帧间间隔（IFS）之间进行竞争发送。</p></blockquote><p><strong>CSMA/CD 以太帧最小帧长计算问题</strong></p><blockquote><p>最小帧长与数据速率的比值必须大于等于传输距离与传输速率的比值</p><p>设L为最小帧长，R为数据速率，S为两端距离，V为传输速度，则</p><p>L/R≥2（S/V）</p><p>例，一个运行CSMA/CD的协议的以太网，数据速率为1GB/S，网段长1KM，</p><p>信号速度为200000KM/S，则最小帧长度为？</p><p>解，L/R≥2(S/V)</p><p>即 L/1(gb/s)=2x(1km/20000(m/s))<br>即 L=10000b</p><p>注意单位换算问题</p><p>1GB/S=1000 000 000b/s</p></blockquote><p><strong>交换机</strong></p><p>交换机有三种交换方式：存储转发交换，直通交换，碎片过滤式交换。</p><h2 id="STP-生成树协议">STP(生成树协议)</h2><p><code>STP(spanning tree protocol) 生成树协议</code></p><p><strong>主要用途：</strong></p><p>1、STP 通过阻塞冗余链路，来消除桥接网络中可能存在的路径回环；</p><p>2、当前活动路径发生故障时，STP 激活冗余链路恢复网络连通性 ,故障可能有交换网络存在环路时引起：广播环路（广播风暴）桥表损坏;</p><p>3.形成一个最佳的树型拓扑</p><p><strong>工作原理:</strong></p><p>STP 将一个环形网络生成无环拓朴的步骤：</p><ol><li>选择根网桥（Root Bridge）</li><li>选择根端口（Root Ports）</li><li>选择指定端口（Designated Ports）</li></ol><p><strong>状态功能：</strong></p><ol><li>阻塞(blocking)不转发器，不学习</li><li>监听(listening)识别根桥，可区分根端口，指定端口，和非指定端口，不能学习接收帧的地址。</li><li>学习(learning)MAC端口能够学习接收帧的MAC地址，但不能转发。</li><li>转发(forwarding)MAC端口可以学习接收帧的源地址，并可以根据目的地址将其转发到适当的端口。</li><li>禁用(disabled)MAC端口不参与生成树算法。</li></ol><p><strong>STP vs RSTP vs MSTP</strong></p><ul><li><p>STP是基础的数据链路层的管理协议，用于二层网络的环路检测和预防。但是，STP拓扑收敛速度慢。</p></li><li><p>RSTP在STP基础上进行了改进，实现了网络拓扑快速收敛。但RSTP和STP还存在同一个缺陷：局域网内所有的<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/VLAN.html">VLAN</a>共享一棵生成树，不能按VLAN阻塞冗余链路，所有VLAN的报文都沿着一棵生成树进行转发。</p></li><li><p>MSTP通过设置VLAN映射表（即VLAN和生成树实例的对应关系表），把VLAN和生成树实例联系起来。同时它把一个交换网络划分成多个域，每个域内形成多棵生成树实例，生成树实例之间彼此独立。MSTP提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</p></li></ul><p>生成树协议中，MSTP兼容RSTP、STP，RSTP兼容STP。三种生成树协议的比较如<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html#table1027518291293">表1-1</a>所示。</p><p><strong>表1-1</strong> 三种生成树协议的比较</p><table><thead><tr><th>生成树协议</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td>STP</td><td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度较慢。</td><td>无需区分用户或业务流量，所有VLAN共享一棵生成树。</td></tr><tr><td>RSTP</td><td>形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。</td><td></td></tr><tr><td>MSTP</td><td>形成多棵无环路的树，解决广播风暴并实现冗余备份。收敛速度快。多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。</td><td>需要区分用户或业务流量，并实现负载分担。不同的VLAN通过不同的生成树转发流量，每棵生成树之间相互独立。</td></tr></tbody></table><h2 id="VRRP-虚拟路由冗余协议">VRRP(虚拟路由冗余协议)</h2><p><code>VRRP(virtual Router Redundancy Protocol 虚拟路由冗余协议)</code></p><p><strong>主要用途：</strong></p><p>解决局域网中配置静态网关出现单点失效现象的路由协议，可以配置一个一个交换机集群，允许两台或多台交换机使用同一个虚拟的MAC地址和IP地址。看起来多台交换机就想是一台大交换机，其实是多台互为备份的交换机。</p><p>​网络中部署 VRRP 负载分担时，多台设备同时承担业务，每个虚拟设备都包括一个 Master 设备和若 干个 Backup 设备。如果为了接入备份需要同时部署冗余链路，则需要部署 MSTP 消除网络中的环路，保证流量的负载分担。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download.png" alt="VRRP备份组示意图"></p><p>VRRP协议中定义了三种状态机：初始状态（Initialize）、活动状态（Master）、备份状态（Backup）。其中，只有处于Master状态的设备才可以转发那些发送到虚拟IP地址的报文。下表详细描述了三种状态。</p><p><strong>表1-1</strong> VRRP协议状态</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Initialize</td><td>该状态为VRRP不可用状态，在此状态时设备不会对VRRP通告报文做任何处理。通常设备启动时或设备检测到故障时会进入Initialize状态。</td></tr><tr><td>Master</td><td>当VRRP设备处于Master状态时，它将会承担虚拟路由设备的所有转发工作，并定期向整个虚拟内发送VRRP通告报文。</td></tr><tr><td>Backup</td><td>当VRRP设备处于Backup状态时，它不会承担虚拟路由设备的转发工作，并定期接受Master设备的VRRP通告报文，判断Master的工作状态是否正常。</td></tr></tbody></table><hr><p><strong>BFD(双向转发检测)</strong></p><p><code>BFD(Bidirectional Forwarding Detection 双向转发检测)</code>是一种基于RFC 5880标准的高速故障检测机制，两个系统建立BFD会话后，在它们之间的通道上周期性地发送BFD报文，如果一方在协商的检测时间内没有接收到BFD报文，则认为这条双向通道上发生了故障。上层协议通过BFD感知到链路故障后可以及时采取措施，进行故障恢复。</p><p>​<strong>主要作用：</strong></p><p>​为了减小设备故障对业务的影响，提高网络的可靠性，网络设备需要能够尽快检测到与相邻设备间的通信故障，以便及时采取措施，保证业务继续进行。</p><p>在现有网络中，有些链路通过硬件检测信号检测链路故障，如SDH（Synchronous Digital Hierarchy，同步数字体系）告警，但并不是所有的介质都能提供硬件检测。此时，应用就要依靠上层协议自身的Hello报文机制来进行故障检测。上层协议的检测时间通常在秒级，当数据传输速率达到GB级时，秒级检测时间内，大量数据将会丢失。在三层网络中，Hello报文检测机制无法针对所有路由来检测故障，如静态路由。这对系统间互联互通定位故障造成困难。</p><p>BFD协议就是在这种背景下产生的，BFD提供了一个通用的标准化的介质无关和协议无关的快速故障检测机制，它具有以下优点：</p><ul><li>提供轻负荷、短周期的故障检测，故障检测时间可达到毫秒级，可靠性更高。</li><li>支持多种故障检测，如接口故障、数据链路故障、转发引擎本身故障等。</li><li>不依赖硬件，能够对任何介质、任何协议层进行实时检测。</li></ul><p>​<strong>工作原理：</strong></p><p>​BFD的检测机制是两个系统建立BFD会话，并沿它们之间的路径周期性发送BFD报文，如果一方在既定的时间内没有收到BFD报文，BFD会话状态变为Down，则认为路径上发生了故障。</p><h2 id="PPPoE-以太网上的PPP协议">PPPoE(以太网上的PPP协议)</h2><p><code>PPPoE（Point-to-Point Protocol over Ethernet 以太网上的PPP协议） </code></p><pre><code>点到点协议（Point to Point Protocol，PPP）是为在同等单元之间传输数据包（简单链路） 设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</code></pre><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230513164355861.png" alt="image-20230513164355861" style="zoom: 80%;" /><p>​应用在链路层。它通过在以太网上提供点到点的连接，建立PPP会话，封装PPP报文为PPPoE报文。PPPoE技术可以将用户连接到远程接入设备上，并提供良好访问控制功能，提供了一种经济的用户接入技术，并实现了对用户的控制。<br>PPPoE利用以太网络，提供远程的多个用户主机接入功能，并且能够提供数据传输的计费数据，解决用户上网收费等实际应用问题，因而被广泛应用于接入运营商网络。</p><p><strong>PPPoE解决了哪些问题？</strong></p><p><code>PPP协议</code>是一种点对点协议，点对点的含义即为一个节点只能访问另一个指定的节点。PPP协议处于OSI（Open Systems Interconnection）参考模型的第二层，即TCP/IP数据链路层，主要用于全双工的异步链路上进行点到点的数据传输。PPP协议的一个重要功能便是提供了身份验证功能。但是PPP协议虽然提供了通信双方身份验证的功能，其协议中没有提供地址信息，而以太网是一个广播类型的多路访问网络，因而PPP协议是无法直接应用在以太网链路上的。</p><p>以太网技术虽然具有简单易用，成本低等特点，但是以太网广播网络的属性，使得其通信双方无法相互验证对方的身份，因而通信是不安全的。</p><p>如何解决以上问题，同时又在现有的网络结构基础上，保证网络的低成本运营？答案便是：PPPoE技术。PPPoE结合了PPP协议通信双方身份验证的功能，在PPP组网结构的基础上，将PPP报文封装成PPPoE报文，从而实现以太网上的点对点通信，使得以太网中的客户端能够连接到远端的宽带接入设备上。</p><p><strong>PPPoE与IPoE相比有哪些不同？</strong></p><p>目前，PPPoE和IPoE作为用户接入两大最常见的接入方式，已经实现了广泛的应用。虽然两者都属于用户接入的方式，但PPPoE和IPoE之间有很大的区别。接下来对PPPoE和IPoE进行对比。</p><p>IPoE是一种在以太网络上直接封装传输IP报文的用户接入方式。IPoE技术依赖<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/DHCP.html">DHCP</a>协议提供IP地址，但是DHCP协议本身并不具备建立链路、认证用户以及链路监测的功能。因而IPoE技术将DHCP协议和可扩展身份验证协议，例如Web协议，<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/802.1X.html">802.1x</a>协议等，结合在一起，提供了与PPPoE相同的功能。详细对比如下图所示。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-16839592608804.png" alt="PPPoE和IPoE对比图" style="zoom:80%;" />*PPPoE和IPoE对比图*<p>PPPoE的认证方式，可管理性强，本身安全性很高，其代价是限制了网络的使用范围和<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html">组播</a>业务的开展，因此在HSI（High Speed Internet）高速上网业务和光纤宽带拨号上网业务应用比较广泛，给学校、企业、家庭用户带来了快速、方便的宽带接入方式。IPoE可以自主管理IP地址的使用期限，可以在局域网范围内进行设置，无需客户端软件，操作简单，但是需要配合其他协议来进行认证，在IPTV/VoIP业务上应用比较广泛。</p><p>IPoE的安全性方面需要家庭网关，网络接入设备，宽带网络网关协同工作。其保证策略包括：反地址欺骗，用户终端数限制，防 Dos 攻击，业务隔离，非法组播源抑制，端口隔离。IPoE在组播业务场景下，可以将组播复制下移到靠近用户的设备，因此在互联网电视和语音方面得到了广泛应用。</p><hr><p><strong>PoE(Power over Ethernet）</strong></p><p><code>PoE（Power over Ethernet）</code>是指通过网线传输电力的一种技术，借助现有以太网通过网线同时为IP终端设备（如：IP电话、AP、IP摄像头等）进行数据传输和供电。<br>PoE又被称为基于局域网的供电系统(Power over LAN，简称PoL)或有源以太网( Active Ethernet)，有时也被简称为以太网供电。<br>为了规范和促进PoE供电技术的发展，解决不同厂家供电和受电设备之间的适配性问题，IEEE标准委员会先后发布了三个PoE标准：IEEE 802.3af标准、IEEE 802.3at标准、IEEE 802.3bt标准。</p><h2 id="ARP-地址解析协议">ARP(地址解析协议)</h2><p><code>ARP（Address Resolution Protocol，地址解析协议）</code>是用来将IP地址解析为MAC地址的协议。主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项。</p><p><strong>为什么需要ARP?</strong></p><p>​在局域网中，当主机或其它三层网络设备有数据要发送给另一台主机或三层网络设备时，需要知道对方的网络层地址（即IP地址）。但是仅有IP地址是不够的，因为IP报文必须封装成帧才能通过物理网络发送，因此发送方还需要知道接收方的物理地址（即MAC地址），这就需要一个通过IP地址获取物理地址的协议，以完成从IP地址到MAC地址的映射。地址解析协议ARP即可实现将IP地址解析为MAC地址。</p><p><strong>RARP反向地址解析协议</strong></p><p>RARP是反向地址解析协议，通过MAC地址确定IP地址。比如无盘工作站和DHCP服务。</p><h2 id="VPN-虚拟私有网络">VPN(虚拟私有网络)</h2><p><code>VPN（Virtual Private Network，虚拟专用网）</code>是一种在公用网络上建立专用网络的技术。它之所以称之为虚拟网，主要是因为VPN的两个节点之间并没有像传统专用网那样使用端到端的物理链路，而是架构在公用网络如Internet之上的逻辑网络，用户数据通过逻辑链路传输。</p><p>按照VPN协议分，常见的VPN种类有：</p><p>IPsec、SSL、GRE、L2TP，PPTP，L2F等。</p><p>其中IPsec是通用性较强的一种VPN技术，适用于多种网络互访的场景。</p><hr><p><code>IPsec VPN</code>是指采用IPsec实现远程接入的一种VPN技术，通过在公网上为两个或多个私有网络之间建立IPsec隧道，并通过加密和验证算法保证VPN连接的安全。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master//download-16839609136169.png" alt="IPsec VPN"></p><p>IPsec VPN保护的是点对点之间的通信，通过IPsec VPN可以在主机和主机之间、主机和网络安全网关之间或网络安全网关（如路由器、防火墙）之间建立安全的隧道连接。其协议主要工作在IP层，在IP层对数据包进行加密和验证。</p><p>相对于其他VPN技术，IPsec VPN安全性更高，数据在IPsec隧道中都是加密传输，但相应的IPsec VPN在配置和组网部署上更复杂。</p><p><strong>IPsec的3个重要协议- IKE/AH/ESP</strong></p><p>IKE（Internet Key Exchange，因特网密钥交换）</p><p>IKE协议是一种基于UDP的应用层协议，它主要用于SA协商和密钥管理。</p><p>IKE协议分IKEv1和IKEv2两个版本，IKEv2与IKEv1相比，修复了多处公认的密码学方面的安全漏洞，提高了安全性能，同时简化了安全联盟的协商过程，提高了协商效率。</p><p>IKE协议属于一种混合型协议，它综合了ISAKMP（Internet Security Association and Key Management Protocol）、Oakley协议和SKEME协议这三个协议。其中，ISAKMP定义了IKE SA的建立过程，Oakley和SKEME协议的核心是DH（Diffie-Hellman）算法，主要用于在Internet上安全地分发密钥、验证身份，以保证数据传输的安全性。IKE SA和IPSec SA需要的加密密钥和验证密钥都是通过DH算法生成的，它还支持密钥动态刷新。</p><p><strong>AH（Authentication Header，认证头）</strong></p><p>AH协议用来对IP报文进行数据源认证和完整性校验，即用来保证传输的IP报文的来源可信和数据不被篡改，但它并不提供加密功能。AH协议在每个数据包的标准IP报文头后面添加一个AH报文头，AH协议对报文的完整性校验的范围是整个IP报文。</p><p><strong>ESP（Encapsulating Security Payload，封装安全载荷）</strong></p><p>ESP协议除了对IP报文进行数据源认证和完整性校验以外，还能对数据进行加密。ESP协议在每一个数据包的标准IP报头后方添加一个ESP报文头，并在数据包后方追加一个ESP尾（ESP Trailer和ESP Auth data）。ESP协议在传输模式下的数据完整性校验范围不包括IP头，因此它不能保证IP报文头不被篡改。</p><p>AH和ESP可以单独使用，也可以同时使用。AH和ESP同时使用时，报文会先进行ESP封装，再进行AH封装；IPsec解封装时，先进行AH解封装，再进行ESP解封装。</p><p><strong>IPsec VPN和SSL VPN对比</strong></p><p>IPsec和SSL是部署VPN时最常用的两种技术，它们都有加密和验证机制保证用户远程接入的安全性。从以下几个方面对IPsec VPN和SSL VPN进行对比：</p><ul><li><p>OSI参考模型工作层级</p><p>OSI定义了网络互连的七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。IPsec工作在网络层，它直接运行在IP（Internet Protocol，互联网协议）之上。而SSL工作在应用层，是一种应用层协议，它加密的是HTTP流量，而不是直接加密IP数据包。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396119555912.png" alt="IPsec和SSL的工作层级"><br><em>IPsec和SSL的工作层级</em></p></li><li><p>配置部署</p><p>IPsec VPN通常适用于Site to Site（站点到站点）的组网，要求站点分别部署VPN网关或远程用户安装专用的VPN客户端，因此配置部署复杂度和维护成本都比较高。但SSL VPN通常适用于Client to Site（客户端到站点）的组网，只要求远程用户使用支持SSL的标准浏览器安装指定插件即可进行访问，通过数据中心部署VPN网关进行集中管理和维护，因此配置部署更简单，维护成本相对较低。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396119556013.png" alt="IPsec VPN"><br><em>IPsec VPN</em></p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396119556014.png" alt="SSL VPN"><br><em>SSL VPN</em></p></li><li><p>安全性</p><p>IPSec工作在网络层，对站点间传输的所有数据进行保护。IPSec VPN要求远程用户安装专用的VPN客户端或在站点部署VPN网关设备，用户访问会受到客户端或网关在用户认证规则、<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5.html">安全策略</a>规则或内容安全过滤方面的检查，因此安全性更高。而SSL VPN不要求安装专用客户端或接入站点部署网关设备，更容易受到安全威胁的影响。</p></li><li><p>访问控制</p><p>IPsec工作在网络层，不能基于应用进行细粒度的访问控制。而SSL VPN在精细化访问控制上更灵活，网络管理员可以将网络资源根据不同的应用类型划分为不同的资源类型，每一类资源的访问权限不同。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230513164652143.png" alt="image-20230513164652143"></p></li></ul><hr><p><code>SSL VPN</code>是采用SSL（Security Socket Layer）/TLS（Transport Layer Security）协议来实现远程接入的一种轻量级VPN技术。<br>SSL VPN充分利用了SSL协议提供的基于证书的身份认证、数据加密和消息完整性验证机制，可以为应用层之间的通信建立安全连接。因为SSL协议内置于浏览器中，使用SSL协议进行认证和数据加密的SSL VPN可以免于安装客户端。<br>移动办公用户使用终端（如便携机、PAD或智能手机）与企业内部的SSL VPN服务器建立SSL VPN隧道以后，就能通过SSL VPN隧道远程访问企业内网的Web服务器、文件服务器、邮件服务器等资源。</p><p><strong>SSL VPN是如何工作的？</strong></p><p>移动办公用户访问企业内网的服务器时，首先与SSL VPN服务器之间建立起安全连接（SSL VPN隧道），采用标准的SSL协议对传输的数据包进行加密。登录SSL VPN服务器时，用户访问SSL VPN服务器登录界面，SSL VPN服务器会对用户身份进行认证。SSL VPN服务器往往支持多种用户认证方式，来保证访问的安全性、合法性。</p><p>然后SSL VPN服务器将报文转发给特定的内部服务器，从而使得移动办公用户在通过验证后，可访问企业内网中管理员分配指定的服务器资源。SSL VPN可以借助Web浏览器覆盖所有的远程访问需求。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396132142021.jpeg" alt="SSL VPN应用场景"></p><p><strong>为什么选择SSL VPN？</strong></p><p>企业出差员工和居家办公员工，需要在外地远程办公，并期望能够通过Internet随时随地的远程访问企业内部资源。同时，企业为了保证内网资源的安全性，希望能对移动办公用户进行多种形式的身份认证，并对移动办公用户可访问内网资源的权限做精细化控制。<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/IPsec.html">IPSec VPN</a>和SSL VPN技术都可以支持远程接入这个应用场景。</p><p>作为一种轻量级VPN 技术，SSL VPN安全性不输于IPsec VPN，且能实现更为精细的资源控制和用户隔离。不需要安装客户端，浏览器登录的便捷性也让SSL VPN在企业和机构员工中更易于推广使用。SSL VPN工作在传输层和应用层之间，不会改变IP报文头和TCP报文头，不会影响原有网络拓扑，也不需要安装客户端。因此部署，配置和维护SSL VPN都比较简便和低成本。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396142229724.png" alt="SSL VPN vs. IPsec VPN"></p><h1>四、网络层</h1><h2 id="RIP-路由信息协议">RIP(路由信息协议)</h2><p><code>RIP（Routing Information Protocol）</code>采用距离向量算法，即路由器根据距离选择路由，所以也称为<code>距离向量协议</code>。</p><p>路由器收集所有可到达目的地的不同路径，并且保存有关到达每个目的地的最少站点数的路 径信息，除到达目的地的最佳路径外，任何其它信息均予以丢弃。同时路由器也把所收集的 路由信息用 RIP 协议通知相邻的其它路由器。这样，正确的路由信息逐渐扩散到了全网。</p><p>​RIP 使用非常广泛，它简单、可靠，便于配置。但是 RIP 只适用于小型的同构网络，因 为它允许的最大站点数为 15，任何超过 15 个站点的目的地均被标记为不可达。而且 RIP 每 隔 30s 一次的路由信息广播也是造成网络的广播风暴的重要原因之一。</p><p><strong>RIPV1与RIPV2</strong></p><p>RIPV2是一个距离矢量路由协议，相比RIPV1具有三处改进：</p><p>1，使用组播而不是RIPV1的广播来传播路由更新。</p><p>2，采用触发更新机制来加速路由收敛，即出现变化时向邻居发送更新报文，可以不必等待更新周期。</p><p>3，支持无类域间路由CIDR，使网络设计更加具有伸缩性。</p><p>RIPV1与V2具有共同点是，以跳步数来度量路由费用，允许最大跳步数为15跳。</p><h2 id="OSPF-开放式最短路径优先">OSPF(开放式最短路径优先)</h2><p>​<code>开放式最短路径优先OSPF（Open Shortest Path First）</code>是IETF组织开发的一个基于链路状态的内部网关协议（Interior Gateway Protocol）。利用 OSPF 的路由器首先必须收集有关的链路状态信息，并根据一定的算法 计算出到每个节点的最短路径。而基于距离向量的路由协议仅向其邻接路由器发送有关路由 更新信息。</p><p>在OSPF出现前，网络上广泛使用<code>RIP（Routing Information Protocol）</code>作为内部网关协议。</p><p>由于RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题，所以逐渐被OSPF取代。</p><p>**OSPF作为基于链路状态的协议，**能够解决RIP所面临的诸多问题。此外，OSPF还有以下优点：</p><ul><li>OSPF采用<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E7%BB%84%E6%92%AD.html">组播</a>形式收发报文，这样可以减少对其它不运行OSPF路由器的影响。</li><li>OSPF支持无类型域间选路（CIDR）。</li><li>OSPF支持对等价路由进行负载分担。</li><li>OSPF支持报文加密。</li></ul><p>由于OSPF具有以上优势，使得OSPF作为优秀的内部网关协议被快速接收并广泛使用。</p><p><strong>OSPF协议路由的计算过程可简单描述如下：</strong></p><ol><li><p>建立邻接关系</p><p>，过程如下：</p><ol><li><p>本端设备通过接口向外发送Hello报文与对端设备建立邻居关系。</p></li><li><p>两端设备进行主/从关系协商和DD报文交换。</p></li><li><p>两端设备通过更新LSA完成链路数据库LSDB的同步。</p><p>此时，邻接关系建立成功。</p></li></ol></li><li><p>路由计算</p><p>OSPF采用SPF（Shortest Path First）算法计算路由，可以达到路由快速收敛的目的。</p></li></ol><h2 id="IS-IS-中间系统到中间系统">IS-IS(中间系统到中间系统)</h2><p><code>IS-IS（Intermediate System-to-Intermediate System，中间系统到中间系统）路由协议</code>最初是ISO（国际标准化组织）为CLNP（Connection Less Network Protocol，无连接网络协议）设计的一种动态路由协议。它是一种基于链路状态并使用最短路径优先算法（SPF）进行路由计算的一种IGP协议。</p><p>随着TCP/IP协议的流行，为了提供对IP路由的支持，IETF在相关标准中对IS-IS进行了扩充和修改，使它能够同时应用在TCP/IP和OSI环境中，称为集成IS-IS（Integrated IS-IS或Dual IS-IS）。IS-IS使用最短路径优先SPF（Shortest Path First）算法进行路由计算，收敛速度快，拓展性强，运行在数据链路层，抗攻击能力强，可以实现大规模网络的互通。</p><p><strong>基本概念</strong></p><p>为了支持大规模的路由网络，IS-IS在路由域内采用两级的分层结构，即一个大的Domain（域）可以被分为多个Areas（区域）。IS-IS网络中三种不同级别的路由设备：一般来说，将Level-1路由设备部署在区域内，Level-2路由设备部署在区域间，Level-1-2路由设备部署在Level-1和Level-2路由设备的中间。如下图所示，一个运行IS-IS协议的网络，整个骨干区域（backbone）不仅包括Area1中的所有Level-2路由设备，还包括其他区域的Level-1-2路由设备。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396703622845.png" alt="IS-IS拓扑示意图"><br><em>IS-IS拓扑示意图</em></p><ul><li><p>Level-1路由器</p><p>Level-1路由器负责区域内的路由，它只与属于同一区域的Level-1和Level-1-2路由器形成邻居关系。一个Level-1路由器只负责维护本区域内的LSDB（Link State Database，链路状态数据库），对于目的地不在本区域内的路由，Level-1路由器会将该路由的目的地标识为最近的Level-1-2路由器。</p></li><li><p>Level-2路由器</p><p>Level-2路由器负责区域间的路由，可以与Level-2或其它区域的Level-1-2路由器形成邻居关系，维护一个Level-2的LSDB，该LSDB包含区域间的路由信息。</p><p>所有Level-2级别的路由器组成路由域的骨干网，负责在不同区域间通信，路由域中Level-2级别的路由器必须是连续的，以保证骨干网的连续性。只有Level-2级别的路由器才能直接与区域外的路由器交换数据报文或路由信息。</p></li><li><p>Level-1-2路由器</p><p>同时属于Level-1和Level-2的路由器称为Level-1-2路由器，可以与同一区域的Level-1和Level-1-2路由器形成Level-1邻居关系，也可以与其他区域的Level-2和Level-1-2路由器形成Level-2的邻居关系。Level-1路由器必须通过Level-1-2路由器才能连接至其他区域。</p><p>Level-1-2路由器维护两个LSDB，Level-1的LSDB用于区域内路由，Level-2的LSDB用于区域间路由。</p></li></ul><p><strong>IS-IS与<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/OSPF.html">OSPF</a>的区别如下：</strong></p><ul><li>协议类型：OSPF使用IP层协议。IS-IS使用链路层协议。</li><li>协议扩展性：OSPF通过扩展LSA type应对新的需求，扩展性一般。比如对<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/IPv6%2B.html">IPv6</a>的支持，需要新的OSPFv3协议来支持。IS-IS由于本身TLV的报文结构，决定了其超强的扩展性。比如对IPv6的支持，仅需扩展TLV。</li><li>适用范围：OSPF应用于规模适中的网络中，最多可支持几百台设备。例如，中小型企业网络。IS-IS应用于规模较大的网络中。例如，大型ISP（Internet Service Provider）中。</li><li>路由算法：OSPF采用最短路径SPF（Shortest Path First）算法。通过链路状态通告LSA（Link State Advertisement）描述网络拓扑，依据网络拓扑生成一棵最短路径树SPT（Shortest Path Tree），计算出到网络中所有目的地的最短路径。IS-IS采用最短路径SPF算法。依据网络拓扑生成一棵最短路径树SPT，计算出到网络中所有目的地的最短路径。在IS-IS中，SPF算法分别独立的在Level-1和Level-2数据库中运行。</li><li>收敛速度：OSPF与IS-IS收敛速度都比较快，小于1s。</li><li>区域划分：OSPF是基于接口划分区域的，IS-IS是基于路由器划分区域的。</li></ul><h2 id="BGP-边界网关协议">BGP(边界网关协议)</h2><p><code>边界网关协议（Border Gateway Protocol，BGP）</code>是一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议。由于不同的管理机构分别控制着他们各自的路由选择域，因此，路由选择域经常被称为自治系统<code>AS（Autonomous System）</code>。现在的Internet是一个由多个自治系统相互连接构成的大网络，BGP作为事实上的Internet外部路由协议标准，被广泛应用于<code>ISP（Internet Service Provider）</code>之间。</p><p><strong>主要用途：</strong></p><p>IGP（Interior Gateway Protocol，内部网关协议）被设计用来在单一的路由选择域内提供可达性信息并不适合提供域间路由选择功能，BGP（Border Gateway Protocol，域间路由协议）作为优秀的域间路由协议得以产生并发展。</p><p>当今的网络通常使用以下类型的IGP：</p><ul><li>距离矢量协议，例如路由信息协议（Routing Information Protocol, RIP）。</li><li>链路状态协议，例如开放式最短路径优先（Open Shortest Path First, <a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/OSPF.html">OSPF</a>）协议和中间系统到中间系统（Intermediate System to Intermediate System, <a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/IS-IS.html">IS-IS</a>）协议。</li></ul><p>虽然这些协议是为不同目的设计的，并且具有不同的行为特征，但是它们的共同目标是解决在一个路由选择域内的路径最优化问题。IGP并不适合提供域间路由选择功能。比如说，一种域间路由选择协议应该能够提供广泛的策略控制，因为不同的域通常需要不同的路由选择策略和管理策略。</p><p>从一开始，BGP就被设计成一种域间路由选择协议，其设计目标就是策略控制能力和可扩展性。但是，BGP也不适合替代IGP，因为它们适用的场景不同。</p><p>BGP有两种运行方式，当BGP运行于同一AS内部时，被称为IBGP（Internel BGP，内部边界网关协议）；当BGP运行于不同AS之间时，称为EBGP（Externel BGP，外部边界网关协议）。如图1 BGP的运行方式所示：</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396307858527.png" alt="BGP的运行方式"></p><p><strong>BGP报文中的角色</strong></p><p>Speaker：发送BGP报文的路由设备称为BGP发言者（Speaker），它接收或产生新的路由信息，并发布（Advertise）给其它BGP Speaker。当BGP Speaker收到来自其它AS的新路由时，如果该路由比当前已知路由更优、或者当前还没有该路由，它就把这条路由发布给所有其他BGP Speaker（发布该路由的BGP Speaker除外）。</p><p>Peer：相互交换报文的BGP Speaker之间互称对等体（Peer）。</p><p><strong>BGP的报文</strong></p><p>BGP的运行是通过报文驱动的，共有Open、Update、Notification、Keepalive和Route-refresh五种报文类型。</p><ul><li>Open报文：是TCP连接建立后发送的第一个报文，用于建立BGP对等体之间的连接关系。对等体在接收到Open报文并协商成功后，将发送Keepalive报文确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-refresh报文的交换。</li><li>Update报文：用于在对等体之间交换路由信息。Update报文可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息。</li><li>Notification报文：当BGP检测到错误状态时，就向对等体发出Notification报文，之后BGP连接会立即中断。</li><li>Keepalive报文：BGP会周期性地向对等体发出Keepalive报文，用来保持连接的有效性。</li><li>Route-refresh报文：Route-refresh报文用来请求对等体重新发送所有的可达路由信息。</li></ul><h2 id="NAT-网络地址转换">NAT(网络地址转换)</h2><p><code>NAT(Network Address Translation)</code>是一种地址转换技术，它可以将IP数据报文头中的IP地址转换为另一个IP地址，并通过转换端口号达到地址重用的目的。NAT作为一种缓解IPv4公网地址枯竭的过渡技术，由于实现简单，得到了广泛应用。</p><h2 id="ICMP-因特网控制报文协议">ICMP(因特网控制报文协议)</h2><p>因特网控制报文协议ICMP（Internet Control Message Protocol）是一个差错报告机制</p><p>通常被IP层或更高层协议（TCP或UDP）使用，属于网络层协议，主要用于在IP主机和路由器之间传递控制消息，用于报告主机是否可达、路由是否可用等。这些控制消息虽然并不传输用户数据，但是对于收集各种网络信息、诊断和排除各种网络故障以及用户数据的传递具有至关重要的作用。</p><p><strong>应用：</strong></p><p>IP数据报及其他应用程序通过ICMP报文可以实现多种应用，其中Ping程序和Tracert（Traceroute）程序最为常见。此外，在网络管理和监测中，网络质量分析<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/NQA.html">NQA</a>（Network Quality Analysis）技术更加充分应用了ICMP。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230513164459771.png" alt="image-20230513164459771"></p><h2 id="ACL-访问控制列表">ACL(访问控制列表)</h2><p>​<code>访问控制列表ACL（Access Control List）</code>是由一条或多条规则组成的集合。所谓规则，是指描述报文匹配条件的判断语句，这些条件可以是报文的源地址、目的地址、端口号等。ACL本质上是一种报文过滤器，规则是过滤器的滤芯。设备基于这些规则进行报文匹配，可以过滤出特定的报文，并根据应用ACL的业务模块的处理策略来允许或阻止该报文通过。</p><p>​<strong>主要用途：</strong></p><p>ACL作为一个过滤器，设备通过应用ACL来阻止和允许特定流量的流入和流出，如果没有它，任何流量都会自由流入和流出，使得网络容易受到攻击。</p><p>如下图所示，为保证财务数据安全，企业在路由设备上应用ACL可以阻止内网内部研发部门主机对财务服务器的访问，同时允许总裁办公室访问财务服务器。为了保护企业内网的安全，在路由设备上应用ACL可以封堵网络<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92.html">病毒</a>常用的端口，防止Internet上的恶意流量入侵。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396404603333.png" alt="ACL可以做什么？"><br><em>ACL可以做什么？</em></p><p>借助ACL，可以实现以下功能：</p><ul><li>提供安全访问：企业重要服务器资源被随意访问，企业机密信息容易泄露，造成安全隐患。使用ACL可以指定用户访问特定的服务器、网络与服务，从而避免随意访问的情况。</li><li>防止网络攻击：Internet病毒肆意侵略企业内网，内网环境的安全性堪忧。使用ACL可以封堵高危端口，从而达成为外网流量的阻塞。</li><li>提高网络带宽利用率：网络带宽被各类业务随意挤占，服务质量要求最高的语音、视频业务的带宽得不到保障，造成用户体验差。使用ACL实现对网络流量的精确识别和控制，限制部分网络流量从而保障主要业务的质量。</li></ul><h2 id="IP-互联协议">IP(互联协议)</h2><p><code>IP协议（Internet Protocol，互联网协议）</code>是TCP/IP协议栈中最核心的协议之一，通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p><p><strong>1、IP头的结构</strong></p><table><thead><tr><th>版本（4位）</th><th>头长度（4位）</th><th>服务类型（8位）</th><th>封包总长度（16位）</th></tr></thead><tbody><tr><td>封包标识（16位）</td><td>标志（3位）</td><td>片断偏移地址（13位）</td><td></td></tr><tr><td>存活时间（8位）</td><td>协议（8位）</td><td>校验和（16位）</td><td></td></tr><tr><td>来源IP地址（32位）</td><td></td><td></td><td></td></tr><tr><td>目的IP地址（32位）</td><td></td><td></td><td></td></tr><tr><td>选项（可选）</td><td>填充（可选）</td><td></td><td></td></tr><tr><td>数据</td><td></td><td></td><td></td></tr></tbody></table><p>（1）字节和数字的存储顺序是从右到左，依次是从低位到高位，而网络存储顺序是从左到右，依次从低位到高位。</p><p>（2）版本：占第一个字节的高四位。头长度：占第一个字节的低四位。</p><p>（3）服务类型：前3位为优先字段权，现在已经被忽略。接着4位用来表示最小延迟、最大吞吐量、最高可靠性和最小费用。</p><p>（4）封包总长度：整个IP报的长度，单位为字节。</p><p>（5）存活时间：就是封包的生存时间。通常用通过的路由器的个数来衡量，比如初始值设置为32，则每通过一个路由器处理就会被减一，当这个值为0的时候就会丢掉这个包，并用ICMP消息通知源主机。</p><p>（6）协议：定义了数据的协议，分别为：TCP、UDP、ICMP和IGMP。定义为：</p><p>＃define PROTOCOL_TCP  0x06</p><p>＃define PROTOCOL_UDP  0x11</p><p>＃define PROTOCOL_ICMP  0x06</p><p>＃define PROTOCOL_IGMP  0x06</p><p>（7）检验和：校验的首先将该字段设置为0，然后将IP头的每16位进行二进制取反求和，将结果保存在校验和字段。</p><p>（8）来源IP地址：将IP地址看作是32位数值则需要将网络字节顺序转化位主机字节顺序。转化的方法是：将每4个字节首尾互换，将2、3字节互换。</p><p>（9）目的IP地址：转换方法和来源IP地址一样。</p><p>在网络协议中，IP是面向非连接的，所谓的非连接就是传递数据的时候，不检测网络是否连通。所以是不可靠的数据报协议，IP协议主要负责在主机之间寻址和选择数据包路由。</p><p><strong>2、ICMP协议的头结构</strong></p><table><thead><tr><th>类型（8位）</th><th>代码（8位）</th><th>校验和（8位）</th></tr></thead><tbody><tr><td>类型或者代码</td><td></td><td></td></tr></tbody></table><p>（1）类型：一个8位类型字段，表示ICMP数据包类型。</p><p>（2）代码：一个8位代码域，表示指定类型中的一个功能。如果一个类型中只有一种功能，代码域置为0。</p><p>（3）检验和：数据包中ICMP部分上的一个16位检验和。</p><p><strong>3.子网划分 VLSM</strong></p><p>IP 地址计算</p><p>一个 B 类网络的子网掩码为 255.255.224.0，则这个网络被划分成了多少个子网?</p><blockquote><p>B 类地址掩码  255.255.0.0</p><p>二进制表示：11111111 . 11111111 . 00000000 . 00000000</p><p>子网掩码： 255 . 255 . 224 . 0</p><p>二进制表示：11111111 . 11111111 . <mark>111</mark>00000 . 00000000</p><p>3bit 位为 8 个子网，子网规模为 32。</p></blockquote><p>一个 B 类地址网络要划分为 10 个子网，则这个网络对应的 子网掩码是什么？</p><blockquote><p>B 类地址掩码  255.255.0.0</p><p>二进制表示：11111111 . 11111111 . 00000000 . 00000000</p><p>B 类地址掩码 11111111 . 11111111 .<mark>1111</mark>0000.  00000000</p><p>二进制表示： 255. 255 .240 .0</p><p>4bit 位，被分为 16 个子网，10&lt;=16。</p></blockquote><p>某连锁店需要设计一种编址来支持全国各个门店销售网络，门店有 300 家左右，每个门店一个子网，每个子网中的终端最多 50 台，该连锁店从 ISP 处得到一个 B 类地址，应该采用的子网掩码是什么？</p><blockquote><p>前提一：要大于 300 个子网，取大于 300 的最小 2 的 N 次方， 也就是 512=2 9（占 9bit 位）</p><p>前提二：子网规模大于 50，取大于 50 的最小 2 的 N 次方，也就 是 64=2 6（占 6bit 位）</p><p>B 类地址子网掩码：255.255.0.0 11111111 . 11111111 . <code>11111111 . 1</code> 0000000</p><p>​9bit 位               7bit 位</p><p>用前提一来规划，划 2 9=512 个子网，子网规模 7bit 位=2 7=128&gt;50， 符合前提二。</p><p>11111111 . 11111111 . <code>11111111 . 11</code> 000000</p><p>​10bit 位       6bit 位</p><p>用前提二来规划，子网规模占 6bit 为，可以划 10bit 位个子网， 10bit 位=1024&gt;300 符合条件。 以上两种规划方式都符合题目条件，</p><p>子网掩码分别是：</p><p>255.255.255.128 该划分方案适合子网规模冗余。</p><p>255.255.255.192 该划分方案适合子网个数冗余。</p></blockquote><p>网络地址为 200.16.192.0/18，划分 16 个子网，16 个子网网络地址是？</p><blockquote><p>二进制表示：200 . 16 . 11000000 . 00000000</p><p>掩码： 255.255. 11000000 . 00000000</p><p>子网掩码： 255.255. 11<mark>1111</mark>00 . 00000000</p><p>​4bit 位，刚好 16 个子网</p><p>所以 16 个子网的网络地址分别为：</p><p>200.16.192.0/22 200.16.11000000.00000000 /22</p><p>200.16.196.0/22 200.16.11000100.00000000 /22</p><p>200.16.200.0/22 200.16.11001000.00000000 /22</p><p>200.16.204.0/22 200.16.11001100.00000000 /22</p><p>200.16.208.0/22 200.16.11010000.00000000 /22</p><p>200.16.212.0/22 200.16.11010100.00000000 /22</p><p>200.16.216.0/22 200.16.11011000.00000000 /22</p><p>200.16.220.0/22 200.16.11011100.00000000 /22</p><p>200.16.224.0/22 200.16.11100000.00000000 /22</p><p>200.16.228.0/22 200.16.11100100.00000000 /22</p><p>200.16.232.0/22 200.16.11101000.00000000 /22</p><p>200.16.236.0/22 200.16.11101100.00000000 /22</p><p>200.16.240.0/22 200.16.11110000.00000000 /22</p><p>200.16.244.0/22 200.16.11110100.00000000 /22</p><p>200.16.248.0/22 200.16.11111000.00000000 /22</p><p>200.16.252.0/22 200.16.11111100.00000000 /22</p></blockquote><p><strong>4.路由汇聚 CIDR</strong></p><p>CIDR前缀<br>CIDR全称为无类别域间路由，和子网掩码不同的是，子网掩码只是局限于在某一个子网内或一个站点内使用，而CIDR是对全球路由系统都是可见的。与子网掩码相对应，CIDR也有一个网络前缀，它消除了IP地址中网络号和主机好的预定义分隔（A类、B类等地址）。</p><p>说白了，CIDR聚合就是利用一个数字来规定了网络号所占的位数，而不是像A类、B类地址那样，有一定的标准，例如：</p><table><thead><tr><th>前缀</th><th style="text-align:center">前缀（二进制）</th><th>地址范围</th></tr></thead><tbody><tr><td>0.0.0.0/0</td><td style="text-align:center">00000000 00000000 00000000 00000000</td><td>0.0.0.0 ～ 255.255.255.255</td></tr><tr><td>128.0.0.0/1</td><td style="text-align:center">10000000 00000000 00000000 00000000</td><td>128.0.0.0 ～ 255.255.255.255</td></tr><tr><td>128.0.0.0/24</td><td style="text-align:center">10000000 00000000 00000000 00000000</td><td>128.0.0.0 ～ 128.0.0.255</td></tr><tr><td>198.128.128.192/27</td><td style="text-align:center">11000110 10000000 10000000 11000000</td><td>198.128.128.192 ～ 198.128.128.223</td></tr></tbody></table><p>其中可以看到第二个和第三个的区别，第二个因为后缀为1，所以网络号只占了1位，主机号为31位；而第三个后缀位24，网络号占了24位，主机号只占了8位，所以这个网络中只有后八位能够分配。</p><p>聚合<br>首先要明白聚合的目的，聚合的目的就是要消除路由器中的路由表条目数，一个路由表条目告诉一个路由器向哪里发送流量。聚合就是将相邻的多个IP前缀合并成一个短前缀，使其覆盖更多的地址空间。因为短前缀意味着主机地址所占的位数更多，因而能覆盖更多的地址空间，那看一下聚合的过程是怎样的：<br>假设有两个前缀为190.154.27.0/26 和 190.154.27.64/26，这其实是看不出什么的，只有变为二进制时才能看到两者的联系：</p><table><thead><tr><th>前缀</th><th>前缀（二进制）</th></tr></thead><tbody><tr><td>190.154.27.0/26</td><td>10111110 10011010 00011011 0<strong>0</strong><mark>000000</mark></td></tr><tr><td>190.154.27.64/26</td><td>10111110 10011010 00011011 0<strong>1</strong><mark>000000</mark></td></tr></tbody></table><p>能够发现，两者的网络号只有最后一位不同，将其隔离出来即是两者差值为1，也即相邻。所以此时两者可以进行聚合，聚合结果为：</p><table><thead><tr><th>前缀</th><th>前缀（二进制）</th></tr></thead><tbody><tr><td>190.154.27.0/26</td><td>10111110 10011010 00011011 00000000</td></tr><tr><td>190.154.27.0/26</td><td>10111110 10011010 00011011 01000000</td></tr><tr><td>190.154.27.0/25</td><td>10111110 10011010 00011011 <strong>0</strong>0000000</td></tr></tbody></table><p>注意前缀已经变为了25，这时候相当于将两个子网进行了聚合。那聚合后呢，有什么效果呢？这也就是这个名字无类别域间路由的由来。原来需要传递到第一个网络或第二个网络的数据包现在逗只需要传到第三个网络中，再由这个网络进行分配决定到底是传到第一个还是第二个，这样就减少了一个路由器中的条目数，转而分担到了各个“子网”中去。</p><h1>五、传输层</h1><h2 id="TCP-传输控制协议">TCP(传输控制协议)</h2><p><strong>1、TCP协议的头结构</strong></p><table><thead><tr><th>来源端口（2字节）</th><th>目的端口（2字节）</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>序号（4字节）</td><td>确认序号（4字节）</td><td></td><td></td><td></td><td></td></tr><tr><td>头长度（4位）</td><td>保留（6位）</td><td></td><td></td><td></td><td></td></tr><tr><td>URG</td><td>ACK</td><td>PSH</td><td>RST</td><td>SYN</td><td>PIN</td></tr><tr><td>窗口大小（2字节）</td><td>校验和（16位）</td><td></td><td></td><td></td><td></td></tr><tr><td>紧急指针（16位）</td><td>选项（可选）</td><td></td><td></td><td></td><td></td></tr><tr><td>数据</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>（1）TCP源端口（Source Port）：16位的源端口包含初始化通信的端口号。源端口和IP地址的作用是标识报文的返回地址。（2）TCP目的端口（Destination Port）：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。</p><p>（3）序列号（Sequence Number）：TCP连线发送方向接收方的封包顺序号。</p><p>（4）确认序号（Acknowledge Number）：接收方回发的应答顺序号。</p><p>（5）头长度（Header Length）：表示TCP头的双四字节数，如果转化为字节个数需要乘以4。</p><p>（6）URG：是否使用紧急指针，0为不使用，1为使用。</p><p>（7）ACK：请求/应答状态。0为请求，1为应答。</p><p>（8）PSH：以最快的速度传输数据。</p><p>（9）RST：连线复位，首先断开连接，然后重建。</p><p>（10）SYN：同步连线序号，用来建立连线。</p><p>（11）FIN：结束连线。如果FIN为0是结束连线请求，FIN为1表示结束连线。</p><p>（12）窗口大小（Window）：目的机使用16位的域告诉源主机，它想收到的每个TCP数据段大小。</p><p>（13）校验和（Check Sum）：这个校验和和IP的校验和有所不同，不仅对头数据进行校验还对封包内容校验。</p><p>（14）紧急指针（Urgent Pointer）：当URG为1的时候才有效。TCP的紧急方式是发送紧急数据的一种方式。</p><p><strong>2、三次握手</strong></p><p><strong>3、四次挥手</strong></p><p><strong>5、拥塞控制</strong></p><h2 id="UDP-用户数据报协议">UDP(用户数据报协议)</h2><p><strong>4、UDP协议的头结构</strong></p><table><thead><tr><th>源端口（2字节）</th><th>目的端口（2字节）</th></tr></thead><tbody><tr><td>封报长度（2字节）</td><td>校验和（2字节）</td></tr><tr><td>数据</td><td></td></tr></tbody></table><p>（1）源端口（Source Port）：16位的源端口域包含初始化通信的端口号。源端口和IP地址的作用是标识报文的返回地址。</p><p>（2）目的端口（Destination Port）：6位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。</p><p>（3）封包长度（Length）：UDP头和数据的总长度。</p><p>（4）校验和（Check Sum）：和TCP和校验和一样，不仅对头数据进行校验，还对包的内容进行校验。</p><h1>六、应用层</h1><h2 id="DNS-域名系统">DNS(域名系统)</h2><p>TCP/IP提供了通过IP地址来连接到设备的功能，但对用户来讲，记住某台设备的IP地址是相当困难的，因此专门设计了一种字符串形式的主机命名机制，这些主机名与IP地址相对应。在IP地址与主机名之间需要有一种转换和查询机制，提供这种机制的系统就是<code>域名系统DNS（Domain Name System）</code></p><p><strong>为什么要有DNS？</strong></p><p>互联网中，一台计算机与其他计算机通信时，通过IP地址唯一的标志自己。此时的IP地址就类似于我们日常生活中的电话号码。但是，这种纯数字的标识是比较难记忆的，而且数量也比较庞大。例如，每个IPv4地址是一个32位长的二进制数字，或者采用点分十进制展示成192.168.1.1这种格式，有接近43亿个的IPv4地址。DNS的作用就是将人类可读的名称转换为机器识别的IP地址，供计算机相互连接。DNS的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。就像我们日常打电话，一般使用人名查找，很少直接输入电话号码一样。当我们上网打开某个网页、视频时，也很少直接使用IP地址，而是在浏览器里输入的URL地址，例如：<a href="https://www.huawei.com">https://www.huawei.com</a>，这其实使用的就是计算机的名字，一般称为域名。</p><p><strong>域名的构成</strong></p><p>最初设备的域名由字符序列组成、所有设备的域名组成一个未分级的域名结构。未分级的域名结构存在命名冲突、管理维护复杂的缺点。因此，TCP/IP把DNS的域名设计成了分级的树状结构。每个申请加入Internet的国家都要向NIC注册一个顶级域名，顶级域采用组织模式和地理模式的划分模式，如cn代表中国、us代表美国等。常见的顶级域名如下表所示。NIC将顶级域的管理权分派给由其指定的管理机构，由这些管理机构再对被授权管理的域继续进行划分，从而形成了二级域。负责划分二级域的管理机构可以授权其下属的管理结构，由它们继续划分域。由此下去，便形成了层次型的Internet域名体系结构。</p><p><strong>表1-1</strong> 顶级Internet域名及其含义</p><table><thead><tr><th>顶级Internet域名</th><th>含义</th></tr></thead><tbody><tr><td>com</td><td>商业组织</td></tr><tr><td>edu</td><td>教育机构</td></tr><tr><td>gov</td><td>政府机构</td></tr><tr><td>mil</td><td>军事部门</td></tr><tr><td>net</td><td>主要网络支持中心</td></tr><tr><td>int</td><td>国际组织</td></tr><tr><td>org</td><td>其他组织</td></tr><tr><td>国家代码</td><td>国家（按照地理模式划分）</td></tr></tbody></table><p>从语法上讲，每一个域名都是有标号序列组成，而各标号之间用点（小数点）隔开。以www.huawei.com域名为例，从右到左依次是：</p><ul><li>com：顶级域名。代表商业组织。</li><li>huawei：二级域名，归属于某个公司自己的域名。</li><li>www：三级域名，表明某个公司提供的是什么服务，www代表普通网页。</li></ul><h2 id="DHCP-动态主机配置协议">DHCP(动态主机配置协议)</h2><p><code>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）</code>是一种网络管理协议，用于集中对用户IP地址进行动态管理和配置。<br>DHCP于1993年10月成为标准协议，其前身是BOOTP协议。DHCP协议由RFC 2131定义，采用客户端/服务器通信模式，由客户端（DHCP Client）向服务器（DHCP Server）提出配置申请，DHCP Server为网络上的每个设备动态分配IP地址、子网掩码、默认网关地址，域名服务器（DNS）地址和其他相关配置参数，以便可以与其他IP网络通信。</p><p><strong>主要用途:</strong></p><p>在IP网络中，每个连接Internet的设备都需要分配唯一的IP地址。DHCP使网络管理员能从中心结点监控和分配IP地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP地址。DHCP实现的自动化分配IP地址不仅降低了配置和部署设备的时间，同时也降低了发生配置错误的可能性。另外DHCP服务器可以管理多个网段的配置信息，当某个网段的配置发生变化时，管理员只需要更新DHCP服务器上的相关配置即可，实现了集中化管理。</p><p>总体来看，DHCP带来了如下优势：</p><ul><li>准确的IP配置：IP地址配置参数必须准确，并且在处理“ <a href="http://192.168.XXX.XXX">192.168.XXX.XXX</a>”之类的输入时，很容易出错。另外印刷错误通常很难解决，使用DHCP服务器可以最大程度地降低这种风险。</li><li>减少IP地址冲突：每个连接的设备都必须有一个IP地址。但是，每个地址只能使用一次，重复的地址将导致无法连接一个或两个设备的冲突。当手动分配地址时，尤其是在存在大量仅定期连接的端点（例如移动设备）时，可能会发生这种情况。DHCP的使用可确保每个地址仅使用一次。</li><li>IP地址管理的自动化：如果没有DHCP，网络管理员将需要手动分配和撤消地址。跟踪哪个设备具有什么地址可能是徒劳的，因为几乎无法理解设备何时需要访问网络以及何时需要离开网络。DHCP允许将其自动化和集中化，因此网络专业人员可以从一个位置管理所有位置。</li><li>高效的变更管理：DHCP的使用使更改地址，范围或端点变得非常简单。例如，组织可能希望将其IP寻址方案从一个范围更改为另一个范围。DHCP服务器配置有新信息，该信息将传播到新端点。同样，如果升级并更换了网络设备，则不需要网络配置。</li></ul><p><strong>工作原理：</strong></p><p>DHCP协议采用UDP作为传输协议，DHCP客户端发送请求消息到DHCP服务器的68号端口，DHCP服务器回应应答消息给DHCP客户端的67号端口。</p><p>只有跟DHCP客户端在同一个网段的DHCP服务器才能收到DHCP客户端广播的DHCP DISCOVER报文。当DHCP客户端与DHCP服务器不在同一个网段时，必须部署DHCP中继来转发DHCP客户端和DHCP服务器之间的DHCP报文。在DHCP客户端看来，DHCP中继就像DHCP服务器；在DHCP服务器看来，DHCP中继就像DHCP客户端。</p><p><strong>无中继场景时DHCP客户端首次接入网络的工作原理</strong></p><p>如下图所示，在没有部署DHCP中继的场景下，首次接入网络DHCP客户端与DHCP服务器的报文交互过程，该过程称为DHCP报文四步交互。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396575390539.png" alt="无中继场景时DHCP客户端首次接入网络的报文交互示意图"><br><em>无中继场景时DHCP客户端首次接入网络的报文交互示意图</em></p><p><strong>第一步：发现阶段</strong></p><blockquote><p>首次接入网络的DHCP客户端不知道DHCP服务器的IP地址，为了学习到DHCP服务器的IP地址，DHCP客户端以广播方式发送DHCP DISCOVER报文（目的IP地址为255.255.255.255）给同一网段内的所有设备（包括DHCP服务器或中继）。DHCP DISCOVER报文中携带了客户端的MAC地址（<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__c1">chaddr字段</a>）、需要请求的参数列表选项（<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op55">Option55</a>）、广播标志位（<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__f1">flags字段</a>）等信息。</p></blockquote><p><strong>第二步：提供阶段</strong></p><blockquote><p>与DHCP客户端位于同一网段的DHCP服务器都会接收到DHCP DISCOVER报文，DHCP服务器选择跟接收DHCP DISCOVER报文接口的IP地址处于同一网段的地址池，并且从中选择一个可用的IP地址，然后通过DHCP OFFER报文发送给DHCP客户端。</p><p>通常，DHCP服务器的地址池中会指定IP地址的<a href="https://support.huawei.com/hedex/hdx.do?docid=EDOC1100087046&amp;id=ZH-CN_CONCEPT_0176371534&amp;lang=zh">租期</a>，如果DHCP客户端发送的DHCP DISCOVER报文中携带了期望租期，服务器会将客户端请求的期望租期与其指定的租期进行比较，选择其中时间较短的租期分配给客户端。</p><p>DHCP服务器在地址池中为客户端分配IP地址的顺序如下：</p><ol><li>DHCP服务器上已配置的与客户端MAC地址静态绑定的IP地址。</li><li>客户端发送的DHCP DISCOVER报文中<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op50">Option50</a>（请求IP地址选项）指定的地址。</li><li>地址池内查找“Expired”状态的IP地址，即曾经分配给客户端的超过租期的IP地址。</li><li>在地址池内随机查找一个“Idle”状态的IP地址。</li><li>如果未找到可供分配的IP地址，则地址池依次自动回收超过租期的（“Expired”状态）和处于冲突状态（“Conflict”状态）的IP地址。回收后如果找到可用的IP地址，则进行分配；否则，DHCP客户端等待应答超时后，重新发送DHCP DISCOVER报文来申请IP地址。</li></ol><p>设备支持在地址池中排除某些不能通过DHCP机制进行分配的IP地址。例如，客户端所在网段已经手工配置了地址为192.168.1.100/24的DNS服务器，DHCP服务器上配置的网段为192.168.1.0/24的地址池中需要将192.168.1.100的IP地址排除，不能通过DHCP分配此地址，否则，会造成地址冲突。</p><p>为了防止分配出去的IP地址跟网络中其他客户端的IP地址冲突，DHCP服务器在发送DHCP OFFER报文前通过发送源地址为DHCP服务器IP地址、目的地址为预分配出去IP地址的<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html">ICMP</a> ECHO REQUEST报文对分配的IP地址进行地址冲突探测。如果在指定的时间内没有收到应答报文，表示网络中没有客户端使用这个IP地址，可以分配给客户端；如果指定时间内收到应答报文，表示网络中已经存在使用此IP地址的客户端，则把此地址列为冲突地址，然后等待重新接收到DHCP DISCOVER报文后按照前面介绍的选择IP地址的优先顺序重新选择可用的IP地址。</p><p>此阶段DHCP服务器分配给客户端的IP地址不一定是最终确定使用的IP地址，因为DHCP OFFER报文发送给客户端等待16秒后如果没有收到客户端的响应，此地址就可以继续分配给其他客户端。通过下面的选择阶段和确认阶段后才能最终确定客户端可以使用的IP地址。</p></blockquote><p><strong>第三步：选择阶段</strong></p><blockquote><p>如果有多个DHCP服务器向DHCP客户端回应DHCP OFFER报文，则DHCP客户端一般只接收第一个收到的DHCP OFFER报文，然后以广播方式发送DHCP REQUEST报文，该报文中包含客户端想选择的DHCP服务器标识符（即<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op54">Option54</a>）和客户端IP地址（即<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op50">Option50</a>，填充了接收的DHCP OFFER报文中yiaddr字段的IP地址）。</p><p>DHCP客户端广播发送DHCP REQUEST报文通知所有的DHCP服务器，它将选择某个DHCP服务器提供的IP地址，其他DHCP服务器可以重新将曾经分配给客户端的IP地址分配给其他客户端。</p></blockquote><p><strong>第四步：确认阶段</strong></p><blockquote><p>当DHCP服务器收到DHCP客户端发送的DHCP REQUEST报文后，DHCP服务器回应DHCP ACK报文，表示DHCP REQUEST报文中请求的IP地址（<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op50">Option50</a>填充的）分配给客户端使用。</p><p>DHCP客户端收到DHCP ACK报文，会广播发送免费ARP报文，探测本网段是否有其他终端使用服务器分配的IP地址，如果在指定时间内没有收到回应，表示客户端可以使用此地址。如果收到了回应，说明有其他终端使用了此地址，客户端会向服务器发送DHCP DECLINE报文，并重新向服务器请求IP地址，同时，服务器会将此地址列为冲突地址。当服务器没有空闲地址可分配时，再选择冲突地址进行分配，尽量减少分配出去的地址冲突。</p><p>当DHCP服务器收到DHCP客户端发送的DHCP REQUEST报文后，如果DHCP服务器由于某些原因（例如协商出错或者由于发送REQUEST过慢导致服务器已经把此地址分配给其他客户端）无法分配DHCP REQUEST报文中<a href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op50">Option50</a>填充的IP地址，则发送DHCP NAK报文作为应答，通知DHCP客户端无法分配此IP地址。DHCP客户端需要重新发送DHCP DISCOVER报文来申请新的IP地址。</p></blockquote><h2 id="HTTP-超文本传输协议">HTTP(超文本传输协议)</h2><h2 id="FTP-文件传输协议">FTP(文件传输协议)</h2><h2 id="E-MAIL-电子邮箱">E-MAIL(电子邮箱)</h2><p><strong>1、SMTP</strong></p><p><strong>2、POP3</strong></p><p><strong>3、IMAP</strong></p><h2 id="SNMP-简单网络管理协议">SNMP(简单网络管理协议)</h2><p>​SNMP是广泛应用于TCP/IP网络的网络管理标准协议，该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。SNMP采用轮询机制，提供最基本的功能集，适合小型、快速、低价格的环境使用，而且SNMP以用户数据报协议（UDP）报文为承载，因而受到绝大多数设备的支持，同时保证管理信息在任意两点传送，便于管理员在网络上的任何节点检索信息，进行故障排查。</p><p><strong>主要作用：</strong></p><p>随着网络技术的飞速发展，在网络不断普及的同时也给网络管理带来了一些问题：</p><ul><li>网络设备数量成几何级数增加，使得网络管理员对设备的管理变得越来越困难；同时，网络作为一个复杂的分布式系统，其覆盖地域不断扩大，也使得对这些设备进行实时监控和故障排查变得极为困难。</li><li>网络设备种类多种多样，不同设备厂商提供的管理接口（如命令行接口）各不相同，这使得网络管理变得愈发复杂。</li></ul><p>在这种背景下，SNMP应运而生，SNMP是广泛应用于TCP/IP网络的网络管理标准协议，该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。通过“利用网络管理网络”的方式：</p><ul><li>网络管理员可以利用SNMP平台在网络上的任意节点完成信息查询、信息修改和故障排查等工作，工作效率得以提高。</li><li>屏蔽了设备间的物理差异，SNMP仅提供最基本的功能集，使得管理任务与被管理设备的物理特性、网络类型相互独立，因而可以实现对不同设备的统一管理，管理成本低。</li><li>设计简单、运行代价低，SNMP采用“尽可能简单”的设计思想，其在设备上添加的软件/硬件、报文的种类和报文的格式都力求简单，因而运行SNMP给设备造成的影响和代价都被最小化。</li></ul><p><strong>主要组件：</strong></p><p>SNMP基本组件包括<code>网络管理系统NMS（Network Management System）</code>、<code>代理进程（Agent）</code>、<code>被管对象（Managed Object）</code>和<code>管理信息库MIB（Management Information Base）</code>。如图所示他们共同构成SNMP的管理模型，在SNMP的体系结构中都起着至关重要的作用。</p><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/download-168396596284842.png" alt="SNMP管理模型"><br><em>SNMP管理模型</em></p><p><strong>SNMP端口</strong></p><p>SNMP端口是SNMP通信端点，SNMP消息传输通过UDP进行，通常使用UDP端口号161/162。有时也使用传输层安全性（TLS）或数据报传输层安全性（DTLS）协议，端口使用情况如下表所示。</p><p><strong>表1-1</strong> SNMP端口使用介绍</p><table><thead><tr><th>过程</th><th>协议</th><th>端口号</th></tr></thead><tbody><tr><td>代理进程接收请求信息</td><td>UDP协议</td><td>161</td></tr><tr><td>NMS与代理进程之间的通信</td><td>UDP协议</td><td>161</td></tr><tr><td>NMS接收通知信息</td><td>UDP协议</td><td>162</td></tr><tr><td>代理进程生成通知信息</td><td>-</td><td>任何可用的端口</td></tr><tr><td>接收请求信息</td><td>TLS/DTLS</td><td>10161</td></tr><tr><td>接收通知信息</td><td>TLS/DTLS</td><td>10162</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/image-20230513164516617.png" alt="image-20230513164516617"></p><p><strong>SNMP Traps</strong></p><p>SNMP Traps是指SNMP Agent主动将设备产生的告警或事件上报给NMS，以便网络管理员及时了解设备当前运行的状态。</p><p>SNMP Agent上报SNMP Traps有两种方式：Trap和Inform。Trap和Inform的区别在于，SNMP Agent通过Inform向NMS发送告警或事件后，NMS需要回复InformResponse进行确认。</p><h2 id="Telnet-远程登陆">Telnet(远程登陆)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、协议综述&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1.七层模型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7、应用层   处理网络应用&lt;/p&gt;
&lt;p&gt;6、表示层   数据表示，数据压缩&lt;/p&gt;
&lt;p&gt;5、会话层   互联主机通信&lt;/p&gt;
&lt;p&gt;4、传输层    端到端应带，分组排序，</summary>
      
    
    
    
    <category term="网络工程" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="网络基础" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="网络协议" scheme="http://giyayonlib.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术实践-使用Java搭建简单的区块链系统</title>
    <link href="http://giyayonlib.com/2023/05/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/"/>
    <id>http://giyayonlib.com/2023/05/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/</id>
    <published>2023-05-05T15:33:50.293Z</published>
    <updated>2023-04-26T12:02:07.626Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>本文欲实现的需求：</p><ol><li><p><strong>设计区块和链结构</strong>：你可以创建一个<code>Block</code>类来表示区块，其中包含属性：如时间戳、交易数据、前一个区块的哈希值、当前区块的哈希值等。然后创建一个<code>Blockchain</code>类来表示整个区块链，其中包含一个<code>Block</code>对象的列表来存储所有的区块。</p></li><li><p><strong>挖矿</strong>：你可以在<code>Blockchain</code>类中添加一个挖矿方法，该方法接收一组交易数据作为参数，并创建一个新的区块。在这个过程中，你需要执行工作量证明算法来寻找满足特定条件的哈希值。</p><p>挖矿是区块链中的一个重要过程，它指的是通过解决复杂的计算问题来创建新区块并获得奖励的过程。在一个基于工作量证明算法（Proof of Work，PoW）的区块链系统中，挖矿通常包括以下几个步骤：</p><ol><li><s><strong>收集交易数据</strong>：首先，挖矿节点需要收集一组未经确认的交易数据，并将其打包到一个新区块中。</s></li><li><strong>计算区块哈希值</strong>：其次，挖矿节点需要对新区块进行哈希运算，以计算出它的哈希值。这一步通常需要使用特定的哈希算法（如SHA-256）。</li><li><strong>执行工作量证明算法</strong>：然后，挖矿节点需要执行工作量证明算法来寻找满足特定条件的哈希值。具体来说，它需要不断改变新区块中的某个字段（如随机数），并重新计算哈希值，直到找到一个以特定数量的零开头的哈希值。</li><li><strong>广播新区块</strong>：最后，当挖矿节点成功找到满足条件的哈希值时，它就可以将新区块广播到整个网络中，并获得相应的奖励。</li></ol><p>以上就是一个简单的挖矿过程。不同的区块链系统可能会有所不同，请根据实际情况进行调整。</p></li><li><p><strong>设计P2P网络</strong>：你可以使用Java中的网络编程技术（如Socket）来实现P2P网络。每个节点都可以监听特定端口，并与其他节点建立连接。</p></li><li><p><strong>新产生的区块同步到其它结点</strong>：当一个节点成功挖出一个新区块时，它应该将这个新区块广播到整个网络中，让其他节点都能接收到这个新区块。</p></li><li><p><strong>验证其它结点广播的区块</strong>：当一个节点接收到其他节点广播的新区块时，它应该对这个新区块进行验证（例如检查哈希值是否满足特定条件）。如果验证通过，则将这个新区块加入本地的区块链中。</p><p>当一个节点接收到其他节点广播的新区块时，它应该对这个新区块进行验证。验证过程通常包括以下几个步骤：</p><ol><li><strong>检查区块结构</strong>：首先，你需要检查新区块的结构是否符合预期，例如它是否包含所有必要的字段（如时间戳、交易数据、前一个区块的哈希值等）。</li><li><strong>检查前一个区块的哈希值</strong>：其次，你需要检查新区块中存储的前一个区块的哈希值是否与本地区块链中最后一个区块的哈希值相同。</li><li><strong>检查工作量证明</strong>：然后，你需要检查新区块是否满足工作量证明算法的要求。具体来说，你需要计算新区块的哈希值，并检查它是否满足特定条件（例如以特定数量的零开头）。</li><li><s><strong>验证交易数据</strong>：最后，你需要验证新区块中包含的所有交易数据。这一步通常涉及到对每笔交易进行签名验证、双花检测等操作。</s></li></ol><p>如果新区快通过了以上所有验证步骤，则说明它是有效的，并可以被加入到本地区块链中。否则，应该将其忽略并继续监听网络中其他节点广播的新区快。</p></li><li><p><strong>设计提供API服务</strong>：你可以使用Java Web技术（如Servlet）来实现API服务。例如，你可以创建一个Servlet来处理获取所有区块数据的请求，并返回JSON格式的数据。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.png" style="zoom: 80%;" /><center>本篇使用JAVA语言开发区块链系统</center><p>在基础层方面，构建基本区块结构，进行哈希处理，矿工挖矿的功能，后续将交易模块嵌入区块结构里面，而区块以区块组成的链作为账本记录。</p></li></ol><h1>1.定义区块结构</h1><h2 id="基础区块Block-java">基础区块Block.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.giyaYon.arithmetic.StringUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Block</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区块的序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希值，作为唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String hash;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一个区块哈希值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String previousHash;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交易数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;TransactionData&gt; data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeStamp;</span><br><span class="line"><span class="comment">//工作量证明</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nonce;</span><br><span class="line"><span class="comment">// 矿工挖矿控制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Block Constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> previousHash</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">(<span class="type">int</span> index, ArrayList&lt;TransactionData&gt; data, String previousHash )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.previousHash = previousHash;</span><br><span class="line">        <span class="built_in">this</span>.timeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Making sure we do this after we set the other values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.hash = calculateHash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">calculateHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">calculatedhash</span> <span class="operator">=</span> StringUtil.applySha256(</span><br><span class="line">                previousHash +</span><br><span class="line">                        Long.toString(timeStamp) +</span><br><span class="line">                        Integer.toString(nonce) +</span><br><span class="line">                        data</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> calculatedhash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">mineBlock</span> <span class="params">(<span class="type">int</span> difficulty)</span>&#123;</span><br><span class="line">        <span class="comment">// Create a string with difficulty * &quot;0&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[difficulty]).replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!hash.substring( <span class="number">0</span>, difficulty).equals(target)) &#123;</span><br><span class="line">            nonce ++;</span><br><span class="line">            hash = calculateHash();</span><br><span class="line">            <span class="keyword">if</span>(!running)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Block Mined despected!!! &quot;</span> );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Block Mined!!! : &quot;</span> + hash);</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopMining</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Block&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;index=&quot;</span> + index +</span><br><span class="line">                <span class="string">&quot;, hash=&#x27;&quot;</span> + hash + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, previousHash=&#x27;&quot;</span> + previousHash + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, timeStamp=&quot;</span> + timeStamp +</span><br><span class="line">                <span class="string">&quot;, nonce=&quot;</span> + nonce +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里，先对基础属性赋值，通过SHA256算法对数据进行<code>数字摘要加密</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">calculateHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">calculatedhash</span> <span class="operator">=</span> StringUtil.applySha256(</span><br><span class="line">            previousHash +</span><br><span class="line">                    Long.toString(timeStamp) +</span><br><span class="line">                    Integer.toString(nonce) +</span><br><span class="line">                    data</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> calculatedhash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矿工挖矿使用到的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mineBlock</span> <span class="params">(<span class="type">int</span> difficulty)</span>&#123;</span><br><span class="line">    <span class="comment">// Create a string with difficulty * &quot;0&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[difficulty]).replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!hash.substring( <span class="number">0</span>, difficulty).equals(target)) &#123;</span><br><span class="line">        nonce ++;</span><br><span class="line">        hash = calculateHash();</span><br><span class="line">        <span class="keyword">if</span>(!running)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Block Mined despected!!! &quot;</span> );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Block Mined!!! : &quot;</span> + hash);</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopMining</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类StringUtil-java">工具类StringUtil.java</h2><p>这里给出SHA256算法使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密摘要</span></span><br><span class="line"><span class="comment">     * Applies Sha256 to a string and returns the result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">applySha256</span><span class="params">(String input)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            <span class="comment">//Applies sha256 to our input,</span></span><br><span class="line">            <span class="type">byte</span>[] hash = digest.digest(input.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * This will contain hash as hexidecimal</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">hexString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hash.length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(<span class="number">0xff</span> &amp; hash[i]);</span><br><span class="line">                <span class="keyword">if</span>(hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                    hexString.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                hexString.append(hex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hexString.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Block</span> <span class="variable">genesisBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hash for block 1 : &quot;</span> + genesisBlock.hash);</span><br><span class="line"></span><br><span class="line">        <span class="type">Block</span> <span class="variable">secondBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),genesisBlock.hash);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hash for block 2 : &quot;</span> + secondBlock.hash);</span><br><span class="line"></span><br><span class="line">        <span class="type">Block</span> <span class="variable">thirdBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),secondBlock.hash);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hash for block 3 : &quot;</span> + thirdBlock.hash);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash for block 1 : 73e659c6ee17b83f0d3209097facb1fe32ba3f2f857a03329be5cac533c5b362</span><br><span class="line">Hash for block 2 : b608321771936423e99eeb93c74c524937131689f2a3d437891e2ecbd14ff404</span><br><span class="line">Hash for block 3 : 02dc6bd5f9e1e11058fd5622e8e1150cf7085ae32c7de879982bf3381a3ce8b7</span><br></pre></td></tr></table></figure><h2 id="使用Gson类输出json格式信息">使用Gson类输出json格式信息</h2><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我们用ArrayList 将区块串起来，组成区块链</p><p>测试代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Block&gt; blockchain = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Block&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add our blocks to the blockchain ArrayList:</span></span><br><span class="line">    blockchain.add(<span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    blockchain.add(<span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),blockchain.get(blockchain.size()-<span class="number">1</span>).hash));</span><br><span class="line">    blockchain.add(<span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),blockchain.get(blockchain.size()-<span class="number">1</span>).hash));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">blockchainJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().setPrettyPrinting().create().toJson(blockchain);</span><br><span class="line">    System.out.println(blockchainJson);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: 0,</span><br><span class="line">    &quot;hash&quot;: &quot;da5b9fb425a489c460488aeb4f7a0de0c8b81d4e87d0199af57932cc3cccb005&quot;,</span><br><span class="line">    &quot;previousHash&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;data&quot;: [],</span><br><span class="line">    &quot;timeStamp&quot;: 1679820296791,</span><br><span class="line">    &quot;nonce&quot;: 0,</span><br><span class="line">    &quot;running&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: 1,</span><br><span class="line">    &quot;hash&quot;: &quot;1d4c0d0b25376d660e51d4a1cd3a5380a5e76bce0827fcf204bff9f4c0a53e10&quot;,</span><br><span class="line">    &quot;previousHash&quot;: &quot;da5b9fb425a489c460488aeb4f7a0de0c8b81d4e87d0199af57932cc3cccb005&quot;,</span><br><span class="line">    &quot;data&quot;: [],</span><br><span class="line">    &quot;timeStamp&quot;: 1679820296823,</span><br><span class="line">    &quot;nonce&quot;: 0,</span><br><span class="line">    &quot;running&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: 2,</span><br><span class="line">    &quot;hash&quot;: &quot;14dac1b905439bb19d639e094ea5858b26c7b186394194f542411314d877a0ad&quot;,</span><br><span class="line">    &quot;previousHash&quot;: &quot;1d4c0d0b25376d660e51d4a1cd3a5380a5e76bce0827fcf204bff9f4c0a53e10&quot;,</span><br><span class="line">    &quot;data&quot;: [],</span><br><span class="line">    &quot;timeStamp&quot;: 1679820296823,</span><br><span class="line">    &quot;nonce&quot;: 0,</span><br><span class="line">    &quot;running&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>2.挖矿与验证</h1><p>首先遍历链条中每个区块与它上一个的区块，验证：</p><ol><li>验证当前区块是不是被修改过数据后上传，上传者可能只修改了当前的区块的数据而不会去重新生成哈希。</li><li>对比先前的区块哈希与当前区块里面链接的上一个区块的哈希是否一致</li><li>对比这个区块是不是达成工作量要求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证这个区块的合法性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  Boolean <span class="title function_">isChainValid</span><span class="params">()</span> &#123;</span><br><span class="line">    Block currentBlock;</span><br><span class="line">    Block previousBlock;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hashTarget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[ difficulty]).replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop through blockchain to check hashes:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt;  serviceClient.blockchain.size(); i++) &#123;</span><br><span class="line">        currentBlock = serviceClient.blockchain.get(i);</span><br><span class="line">        previousBlock = serviceClient.blockchain.get(i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//compare registered hash and calculated hash:</span></span><br><span class="line">        <span class="keyword">if</span>(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Current Hashes not equal&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//compare previous hash and registered previous hash</span></span><br><span class="line">        <span class="keyword">if</span>(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Previous Hashes not equal&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check if hash is solved</span></span><br><span class="line">        <span class="keyword">if</span>(!currentBlock.hash.substring( <span class="number">0</span>, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This block hasn&#x27;t been mined&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Block&gt; blockchain = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Block&gt;();</span><br><span class="line">    <span class="comment">//难度系数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">difficulty</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        blockchain.add(<span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="string">&quot;0&quot;</span>));</span><br><span class="line">          System.out.println(<span class="string">&quot;Trying to Mine block 1... &quot;</span>);</span><br><span class="line">          blockchain.get(<span class="number">0</span>).mineBlock(difficulty);</span><br><span class="line"></span><br><span class="line">        blockchain.add(<span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),blockchain.get(blockchain.size()-<span class="number">1</span>).hash));</span><br><span class="line">          System.out.println(<span class="string">&quot;Trying to Mine block 2... &quot;</span>);</span><br><span class="line">          blockchain.get(<span class="number">1</span>).mineBlock(difficulty);</span><br><span class="line"></span><br><span class="line">        blockchain.add(<span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),blockchain.get(blockchain.size()-<span class="number">1</span>).hash));</span><br><span class="line">          System.out.println(<span class="string">&quot;Trying to Mine block 3... &quot;</span>);</span><br><span class="line">          blockchain.get(<span class="number">2</span>).mineBlock(difficulty);</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">&quot;\nBlockchain is Valid: &quot;</span> + isChainValid());</span><br><span class="line"></span><br><span class="line">          <span class="type">String</span> <span class="variable">blockchainJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().setPrettyPrinting().create().toJson(blockchain);</span><br><span class="line">          System.out.println(<span class="string">&quot;\nThe block chain: &quot;</span>);</span><br><span class="line">          System.out.println(blockchainJson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证这个区块的合法性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  Boolean <span class="title function_">isChainValid</span><span class="params">()</span> &#123;</span><br><span class="line">        Block currentBlock;</span><br><span class="line">        Block previousBlock;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hashTarget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[ difficulty]).replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//loop through blockchain to check hashes:</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt;  blockchain.size(); i++) &#123;</span><br><span class="line">            currentBlock = blockchain.get(i);</span><br><span class="line">            previousBlock = blockchain.get(i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//compare registered hash and calculated hash:</span></span><br><span class="line">            <span class="keyword">if</span>(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Current Hashes not equal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//compare previous hash and registered previous hash</span></span><br><span class="line">            <span class="keyword">if</span>(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Previous Hashes not equal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check if hash is solved</span></span><br><span class="line">            <span class="keyword">if</span>(!currentBlock.hash.substring( <span class="number">0</span>, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This block hasn&#x27;t been mined&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Trying to Mine block 1... </span><br><span class="line">Block Mined!!! : 000cebc823ab29477def440c42e40cc8f2d6c95e9a70acaa194118b805fd3af0</span><br><span class="line">Trying to Mine block 2... </span><br><span class="line">Block Mined!!! : 000078bd7a30e9062e47040a0c2e41132e8d7f0cfbc7aca8bbc7dd402d0a7490</span><br><span class="line">Trying to Mine block 3... </span><br><span class="line">Block Mined!!! : 000f8c109c985348c4ed51f78405e2ddba8d365c14caf399cdd9e62f99566830</span><br><span class="line"></span><br><span class="line">Blockchain is Valid: true</span><br><span class="line"></span><br><span class="line">The block chain: </span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: 0,</span><br><span class="line">    &quot;hash&quot;: &quot;000cebc823ab29477def440c42e40cc8f2d6c95e9a70acaa194118b805fd3af0&quot;,</span><br><span class="line">    &quot;previousHash&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;data&quot;: [],</span><br><span class="line">    &quot;timeStamp&quot;: 1679821998773,</span><br><span class="line">    &quot;nonce&quot;: 2695,</span><br><span class="line">    &quot;running&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: 1,</span><br><span class="line">    &quot;hash&quot;: &quot;000078bd7a30e9062e47040a0c2e41132e8d7f0cfbc7aca8bbc7dd402d0a7490&quot;,</span><br><span class="line">    &quot;previousHash&quot;: &quot;000cebc823ab29477def440c42e40cc8f2d6c95e9a70acaa194118b805fd3af0&quot;,</span><br><span class="line">    &quot;data&quot;: [],</span><br><span class="line">    &quot;timeStamp&quot;: 1679821998850,</span><br><span class="line">    &quot;nonce&quot;: 1692,</span><br><span class="line">    &quot;running&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: 2,</span><br><span class="line">    &quot;hash&quot;: &quot;000f8c109c985348c4ed51f78405e2ddba8d365c14caf399cdd9e62f99566830&quot;,</span><br><span class="line">    &quot;previousHash&quot;: &quot;000078bd7a30e9062e47040a0c2e41132e8d7f0cfbc7aca8bbc7dd402d0a7490&quot;,</span><br><span class="line">    &quot;data&quot;: [],</span><br><span class="line">    &quot;timeStamp&quot;: 1679821998871,</span><br><span class="line">    &quot;nonce&quot;: 3385,</span><br><span class="line">    &quot;running&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3.通信实现</h1><p>在网络的设计上，这里采用传统的CS模式来模拟两个点之间的网络行为，即特定客户端发送请求服务端，服务端回复。事实上P2P每个节点即是服务器也是客户端，而且后续改进可以从这里修改。</p><h2 id="1-使用WebSocket实现服务器和客户端的网络通信基础模块，引入依赖">1.使用WebSocket实现服务器和客户端的网络通信基础模块，引入依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-SocketServer-java">2.SocketServer.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.java_websocket.WebSocket;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.handshake.ClientHandshake;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.server.WebSocketServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@code</span> 网络模块 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> <span class="keyword">extends</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;WebSocket&gt; list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketServer</span><span class="params">(InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(WebSocket conn, ClientHandshake handshake)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This method sends a message to the new client</span></span><br><span class="line">        conn.send(<span class="string">&quot;Welcome to the server!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// This method sends a message to all clients connected</span></span><br><span class="line">        broadcast(conn.getRemoteSocketAddress().getAddress().getHostAddress() + <span class="string">&quot; entered the room!&quot;</span>);</span><br><span class="line">        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + <span class="string">&quot; entered the room!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        list.add(conn);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(WebSocket conn, <span class="type">int</span> code, String reason, <span class="type">boolean</span> remote)</span> &#123;</span><br><span class="line">        broadcast(conn + <span class="string">&quot; has left the room!&quot;</span>);</span><br><span class="line">        System.out.println(conn + <span class="string">&quot; has left the room!&quot;</span>);</span><br><span class="line">        list.remove(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(WebSocket conn, String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        broadcast(conn + <span class="string">&quot;:&quot;</span> + message);</span><br><span class="line">        System.out.println(conn + <span class="string">&quot;: &quot;</span> + message + <span class="string">&quot;，修改前。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(WebSocket conn, Exception ex)</span> &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// some errors like port binding failed may not be assignable to a specific</span></span><br><span class="line">            <span class="comment">// websocket</span></span><br><span class="line">            broadcast(conn + <span class="string">&quot;has a error! it will be quit!&quot;</span>);</span><br><span class="line">            list.remove(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server started!&quot;</span>);</span><br><span class="line">        setConnectionLostTimeout(<span class="number">0</span>);</span><br><span class="line">        setConnectionLostTimeout(<span class="number">100</span>);</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MsgBroadcast</span><span class="params">(String msg)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg != <span class="literal">null</span> &amp;&amp; list.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            broadcast(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-socketClient-java">3.socketClient.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.java_websocket.WebSocket;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.client.WebSocketClient;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.drafts.Draft;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.handshake.ServerHandshake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@code</span> 网络模块，客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> <span class="keyword">extends</span> <span class="title class_">WebSocketClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;WebSocket&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;WebSocket&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;WebSocket&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketClient</span><span class="params">(URI serverUri)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(serverUri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketClient</span><span class="params">(URI serverUri, Draft protocolDraft)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(serverUri, protocolDraft);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(ServerHandshake serverHandshake)</span> &#123;</span><br><span class="line">        list.add(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(<span class="type">int</span> i, String s, <span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        list.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        list.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String msg)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SocketServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketServer</span>(port);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">wait</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ws://localhost:8888</span></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SocketClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = <span class="keyword">new</span> <span class="title class_">SocketClient</span>(<span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;ws://localhost:8888&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        client.connect();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用<a href="http://coolaf.com/tool/chattest">http://coolaf.com/tool/chattest</a> 测试服务端是否开启成功 <code>ws://localhost:8888</code></p><p>打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server started!</span><br><span class="line">0:0:0:0:0:0:0:1 entered the room!</span><br><span class="line">127.0.0.1 entered the room!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the server!</span><br><span class="line">127.0.0.1 entered the room!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">连接成功，现在你可以发送信息啦！！！</span><br><span class="line">服务端回应 2023-03-26 17:30:31</span><br><span class="line">Welcome to the server!</span><br><span class="line">服务端回应 2023-03-26 17:30:31</span><br><span class="line">0:0:0:0:0:0:0:1 entered the room!</span><br><span class="line">服务端回应 2023-03-26 17:33:25</span><br><span class="line">127.0.0.1 entered the room!</span><br><span class="line">websocket连接已断开!!!</span><br></pre></td></tr></table></figure><h1>4.网络服务实现</h1><h2 id="1-消息实现">1.消息实现</h2><p>首先需要对消息进行定义处理，例如A节点对B节点发送区块链更新请求消息，或者是C节点挖到一个矿，想要对其进行广播，其他节点收到消息会对其进行处理。</p><p>定义消息模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> type, String data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义消息类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Network: BLOCK_PROTOCOL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">QUERY_LATEST_BLOCK</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">QUERY_BLOCKCHAIN</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">QUERY_LATEST_TRANSACTION</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">UPLOAD_MINED_BLOCK</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RETURN_LATEST_BLOCK</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RETURN_BLOCKCHAIN</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; T <span class="title function_">simpleJsonToObj</span><span class="params">(String json, Class&lt;T&gt; cls)</span> &#123;</span><br><span class="line">        <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(json)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> gson.fromJson(json, cls);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">simpleObjToJson</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(obj)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">            <span class="keyword">return</span> gson.toJson(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-定义接口">2.定义接口</h2><p>节点通用的方法</p><p>定义节点接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传增加一个或一条链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBroadcastBlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个区块</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> added result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">broadcastBlock</span><span class="params">(String msg)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IQueryBlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询区块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">queryBlockFromOthers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Block <span class="title function_">queryBlockFromLocal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">queryChainFromLocal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">queryChainFromOthers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证一个或一条链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVerifyBlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证该区块是否有问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> block 需要验证的区块</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 0:该块通过，</span></span><br><span class="line"><span class="comment">     *          1:该链有结构问题</span></span><br><span class="line"><span class="comment">     *          2:该链数字摘要修改过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">verifyBlock</span><span class="params">(String block)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证该区块链是否有问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 需要验证的链</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 0，通过 ，1不通过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">verifyChain</span><span class="params">(String chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实现简易消息处理的服务端">3.实现简易消息处理的服务端</h2><p>首先，对SocketServer的onMessage进行重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                server = <span class="keyword">new</span> <span class="title class_">SocketServer</span>(port)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(WebSocket conn, String message)</span></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    handleMessage(conn,message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                    broadcast(conn + &quot;:&quot; + message);</span></span><br><span class="line"><span class="comment">//                    System.out.println(conn + &quot;: &quot; + message + &quot;，修改后。&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>其次，定义消息接收后的处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(WebSocket conn, String message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> simpleJsonToObj(message,Message.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msg.getType())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QUERY_LATEST_BLOCK:</span><br><span class="line">            <span class="type">Message</span> <span class="variable">queryBlockMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(RETURN_LATEST_BLOCK, simpleObjToJson(queryBlockFromLocal()));</span><br><span class="line">            <span class="type">String</span> <span class="variable">sendBlockMsg</span>  <span class="operator">=</span> simpleObjToJson(queryBlockMsg);</span><br><span class="line">            conn.send(sendBlockMsg);</span><br><span class="line"></span><br><span class="line">            System.out.println(conn.getRemoteSocketAddress() + <span class="string">&quot;,queryBLOCK:&quot;</span>+ queryBlockMsg.getData());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_BLOCKCHAIN:</span><br><span class="line">            <span class="type">Message</span> <span class="variable">queryChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(RETURN_BLOCKCHAIN, queryChainFromLocal());</span><br><span class="line">            <span class="type">String</span> <span class="variable">sendChain</span>  <span class="operator">=</span> simpleObjToJson(queryChain);</span><br><span class="line">            conn.send(sendChain);</span><br><span class="line"></span><br><span class="line">            System.out.println(conn.getRemoteSocketAddress() +<span class="string">&quot;: QUERY_BLOCK_CHAIN:&quot;</span>+ queryChain.getData());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_LATEST_TRANSACTION:</span><br><span class="line">            server.broadcast(<span class="string">&quot;TRANSACTION:&quot;</span> + msg.getData());</span><br><span class="line">            System.out.println(<span class="string">&quot;TRANSACTION:&quot;</span> + msg.getData());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UPLOAD_MINED_BLOCK:</span><br><span class="line"></span><br><span class="line">            <span class="type">Block</span> <span class="variable">mineBlock</span> <span class="operator">=</span> simpleJsonToObj(msg.getData(),Block.class);</span><br><span class="line">            blockchain.add(mineBlock);</span><br><span class="line">            <span class="keyword">if</span>(!isChainValid())</span><br><span class="line">            &#123;</span><br><span class="line">                blockchain.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                server.broadcast(message);</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RETURN_LATEST_BLOCK:</span><br><span class="line">            <span class="type">Block</span> <span class="variable">b</span> <span class="operator">=</span> simpleJsonToObj(msg.getData(),Block.class);</span><br><span class="line">            blockchain.add(b);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;got the latest block! &quot;</span> + queryBlockFromLocal().hash);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RETURN_BLOCKCHAIN:</span><br><span class="line">            <span class="comment">//server.broadcast(&quot;DOWNLOAD_BLOCKCHAIN:&quot;+ msg.getData());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(&quot;DOWNLOAD_BLOCKCHAIN:&quot;+ msg.getData());</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(msg);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码ServiceServer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.giyaYon.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Blocks.Block;</span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Network.Message;</span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Network.SocketServer;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.WebSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Network.BlockConstant.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Service.ServiceClient.difficulty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceServer</span> <span class="keyword">implements</span> <span class="title class_">IQueryBlock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通信服务器</span></span><br><span class="line">    SocketServer server;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启端口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//账本</span></span><br><span class="line">    LinkedList&lt;Block&gt; blockchain = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Block&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runServer</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                server = <span class="keyword">new</span> <span class="title class_">SocketServer</span>(port)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(WebSocket conn, String message)</span></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    handleMessage(conn,message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                    broadcast(conn + &quot;:&quot; + message);</span></span><br><span class="line"><span class="comment">//                    System.out.println(conn + &quot;: &quot; + message + &quot;，修改后。&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            server.start();</span><br><span class="line">            System.out.println(<span class="string">&quot;ChatServer started on port: &quot;</span> + server.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">sysin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">in</span> <span class="operator">=</span> sysin.readLine();</span><br><span class="line">                <span class="comment">//s.broadcast(in);</span></span><br><span class="line">                <span class="keyword">if</span> (in.equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">                    server.stop(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(WebSocket conn, String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> simpleJsonToObj(message,Message.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.getType())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> QUERY_LATEST_BLOCK:</span><br><span class="line">                <span class="type">Message</span> <span class="variable">queryBlockMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(RETURN_LATEST_BLOCK, simpleObjToJson(queryBlockFromLocal()));</span><br><span class="line">                <span class="type">String</span> <span class="variable">sendBlockMsg</span>  <span class="operator">=</span> simpleObjToJson(queryBlockMsg);</span><br><span class="line">                conn.send(sendBlockMsg);</span><br><span class="line"></span><br><span class="line">                System.out.println(conn.getRemoteSocketAddress() + <span class="string">&quot;,queryBLOCK:&quot;</span>+ queryBlockMsg.getData());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QUERY_BLOCKCHAIN:</span><br><span class="line">                <span class="type">Message</span> <span class="variable">queryChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(RETURN_BLOCKCHAIN, queryChainFromLocal());</span><br><span class="line">                <span class="type">String</span> <span class="variable">sendChain</span>  <span class="operator">=</span> simpleObjToJson(queryChain);</span><br><span class="line">                conn.send(sendChain);</span><br><span class="line"></span><br><span class="line">                System.out.println(conn.getRemoteSocketAddress() +<span class="string">&quot;: QUERY_BLOCK_CHAIN:&quot;</span>+ queryChain.getData());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QUERY_LATEST_TRANSACTION:</span><br><span class="line">                server.broadcast(<span class="string">&quot;TRANSACTION:&quot;</span> + msg.getData());</span><br><span class="line">                System.out.println(<span class="string">&quot;TRANSACTION:&quot;</span> + msg.getData());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UPLOAD_MINED_BLOCK:</span><br><span class="line"></span><br><span class="line">                <span class="type">Block</span> <span class="variable">mineBlock</span> <span class="operator">=</span> simpleJsonToObj(msg.getData(),Block.class);</span><br><span class="line">                blockchain.add(mineBlock);</span><br><span class="line">                <span class="keyword">if</span>(!isChainValid())</span><br><span class="line">                &#123;</span><br><span class="line">                    blockchain.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    server.broadcast(message);</span><br><span class="line">                    System.out.println(message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> RETURN_LATEST_BLOCK:</span><br><span class="line">                <span class="type">Block</span> <span class="variable">b</span> <span class="operator">=</span> simpleJsonToObj(msg.getData(),Block.class);</span><br><span class="line">                blockchain.add(b);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;got the latest block! &quot;</span> + queryBlockFromLocal().hash);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RETURN_BLOCKCHAIN:</span><br><span class="line">                <span class="comment">//server.broadcast(&quot;DOWNLOAD_BLOCKCHAIN:&quot;+ msg.getData());</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//System.out.println(&quot;DOWNLOAD_BLOCKCHAIN:&quot;+ msg.getData());</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(msg);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryBlockFromOthers</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        Message queryBlock = new Message(QUERY_LATEST_BLOCK,&quot;&quot;);</span></span><br><span class="line"><span class="comment">//        String msg = simpleObjToJson(queryBlock);</span></span><br><span class="line"><span class="comment">//        server.sendMessage(msg);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Block <span class="title function_">queryBlockFromLocal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blockchain.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryChainFromLocal</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Block&gt; iterator = blockchain.iterator();</span><br><span class="line">        Block block;</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            block = iterator.next();</span><br><span class="line">            list.append(simpleObjToJson(block));</span><br><span class="line">            list.append(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.deleteCharAt(list.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryChainFromOthers</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  Boolean <span class="title function_">isChainValid</span><span class="params">()</span> &#123;</span><br><span class="line">        Block currentBlock;</span><br><span class="line">        Block previousBlock;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hashTarget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[ difficulty]).replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//loop through blockchain to check hashes:</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt;  blockchain.size(); i++) &#123;</span><br><span class="line">            currentBlock = blockchain.get(i);</span><br><span class="line">            previousBlock = blockchain.get(i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//compare registered hash and calculated hash:</span></span><br><span class="line">            <span class="keyword">if</span>(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Current Hashes not equal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//compare previous hash and registered previous hash</span></span><br><span class="line">            <span class="keyword">if</span>(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Previous Hashes not equal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check if hash is solved</span></span><br><span class="line">            <span class="keyword">if</span>(!currentBlock.hash.substring( <span class="number">0</span>, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This block hasn&#x27;t been mined&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-实现客户端">4.实现客户端</h2><p>客户端实现包括两个，第一是被动的网络服务，第二是用户行为主动服务</p><p>1.网络服务ConnectService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.giyaYon.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Blocks.Block;</span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Network.Message;</span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Network.SocketClient;</span><br><span class="line"><span class="keyword">import</span> org.java_websocket.WebSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Network.BlockConstant.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Service.ServiceClient.difficulty;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Service.StateConstant.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统被动型服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectService</span> <span class="keyword">implements</span> <span class="title class_">IBroadcastBlock</span>,IVerifyBlock,IQueryBlock &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ServiceClient serviceClient;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * for communication</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SocketClient client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConnectService</span><span class="params">(String url,ServiceClient serviceClient)</span> <span class="keyword">throws</span> URISyntaxException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.serviceClient = serviceClient;</span><br><span class="line">        client = <span class="keyword">new</span> <span class="title class_">SocketClient</span>(<span class="keyword">new</span> <span class="title class_">URI</span>(url))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String s)</span></span><br><span class="line">            &#123;</span><br><span class="line">                handleMessage(client,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SocketClient <span class="title function_">getClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启联网</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startService</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        client.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopService</span><span class="params">()</span>&#123;client.close();&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(WebSocket conn, String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> simpleJsonToObj(message,Message.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.getType())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//请求查询当前最新区块</span></span><br><span class="line">            <span class="keyword">case</span> QUERY_LATEST_BLOCK:</span><br><span class="line">                <span class="type">Message</span> <span class="variable">queryBlockMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(RETURN_LATEST_BLOCK, simpleObjToJson(queryBlockFromLocal()));</span><br><span class="line">                <span class="type">String</span> <span class="variable">sendBlockMsg</span>  <span class="operator">=</span> simpleObjToJson(queryBlockMsg);</span><br><span class="line">                conn.send(sendBlockMsg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//请求查询最新区块链</span></span><br><span class="line">            <span class="keyword">case</span> QUERY_BLOCKCHAIN:</span><br><span class="line">                <span class="type">Message</span> <span class="variable">queryChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(RETURN_BLOCKCHAIN, queryChainFromLocal());</span><br><span class="line">                <span class="type">String</span> <span class="variable">sendChain</span>  <span class="operator">=</span> simpleObjToJson(queryChain);</span><br><span class="line">                conn.send(sendChain);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//TODO 请求查询最新交易池</span></span><br><span class="line">            <span class="keyword">case</span> QUERY_LATEST_TRANSACTION:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 上传挖矿块</span></span><br><span class="line">            <span class="keyword">case</span> UPLOAD_MINED_BLOCK:</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解析消息</span></span><br><span class="line">                <span class="type">Block</span> <span class="variable">mineBlock</span> <span class="operator">=</span> simpleJsonToObj(msg.getData(),Block.class);</span><br><span class="line">                <span class="comment">//加入本账本</span></span><br><span class="line">                ServiceClient.blockchain.add(mineBlock);</span><br><span class="line">                <span class="comment">//验证合法性，若不正确就删除这个最新的区块</span></span><br><span class="line">                <span class="keyword">if</span>(!isChainValid())</span><br><span class="line">                &#123;</span><br><span class="line">                    ServiceClient.blockchain.removeLast();</span><br><span class="line">                    System.out.println(<span class="string">&quot;had removed the block&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">Block</span> <span class="variable">latestBlock</span> <span class="operator">=</span> queryBlockFromLocal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;i received the new block:&quot;</span> + latestBlock.toString());</span><br><span class="line">                    <span class="comment">//收到新的区块，如果用户仍在挖矿，则看看它挖的是不是重复的区块，是的话就提示他停下来了</span></span><br><span class="line">                    <span class="keyword">if</span>(serviceClient.userService.state.getType() == MINEING)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(Integer.parseInt(serviceClient.userService.state.getData()) == latestBlock.index)</span><br><span class="line">                        &#123;</span><br><span class="line">                            serviceClient.userService.stopToMineBlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 返回最新区块</span></span><br><span class="line">            <span class="keyword">case</span> RETURN_LATEST_BLOCK:</span><br><span class="line">                <span class="type">Block</span> <span class="variable">b</span> <span class="operator">=</span> simpleJsonToObj(msg.getData(), Block.class);</span><br><span class="line">                serviceClient.blockchain.add(b);</span><br><span class="line">                <span class="keyword">if</span>(!isChainValid())</span><br><span class="line">                &#123;</span><br><span class="line">                    ServiceClient.blockchain.removeLast();</span><br><span class="line">                    System.out.println(<span class="string">&quot;had removed the block&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">Block</span> <span class="variable">latestBlock</span> <span class="operator">=</span> queryBlockFromLocal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;your local latest block is:&quot;</span> + latestBlock.hash);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//TODO 返回最新的区块链</span></span><br><span class="line">            <span class="keyword">case</span> RETURN_BLOCKCHAIN:</span><br><span class="line">                serviceClient.blockchain.clear();</span><br><span class="line">                String[] chain = msg.getData().split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String s : chain) &#123;</span><br><span class="line">                    <span class="type">Block</span> <span class="variable">block</span> <span class="operator">=</span> simpleJsonToObj(s,Block.class);</span><br><span class="line">                    serviceClient.blockchain.add(block);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Block block :ServiceClient.blockchain)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(block.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(msg);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">verifyBlock</span><span class="params">(String block)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">verifyChain</span><span class="params">(String chain)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">broadcastBlock</span><span class="params">(String msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">        client.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryBlockFromOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">queryBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(QUERY_LATEST_BLOCK,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> simpleObjToJson(queryBlock);</span><br><span class="line">        client.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Block <span class="title function_">queryBlockFromLocal</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> serviceClient.blockchain.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">queryChainFromLocal</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Block&gt; iterator = serviceClient. blockchain.iterator();</span><br><span class="line">        Block block;</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            block = iterator.next();</span><br><span class="line">            list.append(simpleObjToJson(block));</span><br><span class="line">            list.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.deleteCharAt(list.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryChainFromOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">queryBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(QUERY_BLOCKCHAIN,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> simpleObjToJson(queryBlock);</span><br><span class="line">        client.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证这个区块的合法性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  Boolean <span class="title function_">isChainValid</span><span class="params">()</span> &#123;</span><br><span class="line">        Block currentBlock;</span><br><span class="line">        Block previousBlock;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hashTarget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[ difficulty]).replace(<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//loop through blockchain to check hashes:</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt;  serviceClient.blockchain.size(); i++) &#123;</span><br><span class="line">            currentBlock = serviceClient.blockchain.get(i);</span><br><span class="line">            previousBlock = serviceClient.blockchain.get(i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//compare registered hash and calculated hash:</span></span><br><span class="line">            <span class="keyword">if</span>(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Current Hashes not equal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//compare previous hash and registered previous hash</span></span><br><span class="line">            <span class="keyword">if</span>(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Previous Hashes not equal&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check if hash is solved</span></span><br><span class="line">            <span class="keyword">if</span>(!currentBlock.hash.substring( <span class="number">0</span>, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This block hasn&#x27;t been mined&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.用户服务UserService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.giyaYon.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Blocks.Block;</span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Network.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Network.BlockConstant.UPLOAD_MINED_BLOCK;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Network.BlockConstant.simpleObjToJson;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.giyaYon.Service.StateConstant.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户主动型服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    ServiceClient serviceClient;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该客户端正在干什么</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Message state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Block currentMineBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(ServiceClient serviceClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceClient = serviceClient;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">Message</span>(IDLE,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挖矿</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryToMineBlock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保持联网状态挖矿</span></span><br><span class="line">        <span class="keyword">if</span>(serviceClient.connection.client.isClosed()) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(serviceClient.connection.client.isClosing()) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(state.getType() != IDLE)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始挖矿</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ServiceClient.blockchain.size();</span><br><span class="line">        <span class="keyword">if</span> (ServiceClient.blockchain.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//定义正在挖矿的状态</span></span><br><span class="line">            state = <span class="keyword">new</span> <span class="title class_">Message</span>(MINEING, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="comment">//开挖</span></span><br><span class="line">            currentMineBlock = <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">broadcastNewBlockHash</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//模拟矿工挖矿过程</span></span><br><span class="line">            broadcastNewBlockHash = currentMineBlock.mineBlock(ServiceClient.difficulty);</span><br><span class="line">            <span class="comment">//如果为空则会自动抛弃这个矿不会广播</span></span><br><span class="line">            <span class="keyword">if</span>(broadcastNewBlockHash != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第0个！&quot;</span> + broadcastNewBlockHash);</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(UPLOAD_MINED_BLOCK, simpleObjToJson(currentMineBlock));</span><br><span class="line">                <span class="type">String</span> <span class="variable">broadcastBlock</span> <span class="operator">=</span> simpleObjToJson(msg);</span><br><span class="line">                <span class="comment">//将挖到的区块广播出去</span></span><br><span class="line">                serviceClient.connection.broadcastBlock(broadcastBlock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非创世矿挖矿</span></span><br><span class="line">            state = <span class="keyword">new</span> <span class="title class_">Message</span>(MINEING, String.valueOf(index));</span><br><span class="line">            <span class="comment">//开挖</span></span><br><span class="line">            currentMineBlock = <span class="keyword">new</span> <span class="title class_">Block</span>(index, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), ServiceClient.blockchain.get(ServiceClient.blockchain.size() - <span class="number">1</span>).hash);</span><br><span class="line">            <span class="type">String</span> <span class="variable">broadcastNewBlockHash</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            broadcastNewBlockHash = currentMineBlock.mineBlock(ServiceClient.difficulty);</span><br><span class="line">            <span class="keyword">if</span>(broadcastNewBlockHash != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + index + <span class="string">&quot;个！&quot;</span> + broadcastNewBlockHash);</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(UPLOAD_MINED_BLOCK, simpleObjToJson(currentMineBlock));</span><br><span class="line">                <span class="type">String</span> <span class="variable">broadcastBlock</span> <span class="operator">=</span> simpleObjToJson(msg);</span><br><span class="line">                <span class="comment">//将挖到的区块广播出去</span></span><br><span class="line">                serviceClient.connection.broadcastBlock(broadcastBlock);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">Message</span>(IDLE, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopToMineBlock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentMineBlock.stopMining();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对两个服务进行整合 ServiceClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.giyaYon.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Blocks.Block;</span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Blocks.TransactionData;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GiyaYon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@code</span> 服务层 网络同步区块服务模块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开启服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * //接口</span></span><br><span class="line"><span class="comment"> * 发送一个区块</span></span><br><span class="line"><span class="comment"> * 发送一个链</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 验证一个区块</span></span><br><span class="line"><span class="comment"> * 验证一个链</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看当前最新链</span></span><br><span class="line"><span class="comment"> * 查看整个链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceClient</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  receive blockchain from others 区块链数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LinkedList&lt;Block&gt; blockchain = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Block&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  receive difficulty form others 定义工作量难度由区块链协议定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">difficulty</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  交易池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;TransactionData&gt; transactions;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要先开启联网服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConnectService connection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后续的挖矿等服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceClient</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connection = <span class="keyword">new</span> <span class="title class_">ConnectService</span>(url,<span class="built_in">this</span>);</span><br><span class="line">            userService = <span class="keyword">new</span> <span class="title class_">UserService</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runClientServer</span><span class="params">()</span>&#123;</span><br><span class="line">        connection.startService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitClientServer</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        connection.stopService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ServiceServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceServer</span>(<span class="number">8888</span>);</span><br><span class="line">    server.runServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.giyaYon.Appliaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Service.ServiceClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientProgarm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">peer</span> <span class="operator">=</span> <span class="string">&quot;ws://localhost:8888&quot;</span>;</span><br><span class="line">        <span class="type">ServiceClient</span> <span class="variable">serviceClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceClient</span>(peer);</span><br><span class="line">        serviceClient.runClientServer();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                            ===================================</span></span><br><span class="line"><span class="string">                            please typing code what you want to do:</span></span><br><span class="line"><span class="string">                            1.exit system</span></span><br><span class="line"><span class="string">                            2.mine block</span></span><br><span class="line"><span class="string">                            3.update_block</span></span><br><span class="line"><span class="string">                            ===================================</span></span><br><span class="line"><span class="string">                            &quot;&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (scan.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> scan.next();</span><br><span class="line">                <span class="keyword">if</span>(str1.equals(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;exiting...&quot;</span>);</span><br><span class="line">                    scan.close();</span><br><span class="line">                    serviceClient.exitClientServer();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(str1.equals(<span class="string">&quot;2&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;try to mine block...&quot;</span>);</span><br><span class="line">                    serviceClient.userService.tryToMineBlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(str1.equals(<span class="string">&quot;3&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    serviceClient.connection.queryChainFromOthers();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//serviceClient.userService.tryToMineBlock();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        serviceClient.userService.tryToMineBlock();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><p>打开服务端：</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChatServer started on port: 8888</span><br><span class="line">Server started!</span><br><span class="line">127.0.0.1 entered the room!</span><br><span class="line">&#123;&quot;type&quot;:4,&quot;data&quot;:&quot;&#123;\&quot;index\&quot;:0,\&quot;hash\&quot;:\&quot;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39\&quot;,\&quot;previousHash\&quot;:\&quot;0\&quot;,\&quot;data\&quot;:[],\&quot;timeStamp\&quot;:1679825452774,\&quot;nonce\&quot;:1769903,\&quot;running\&quot;:true&#125;&quot;&#125;</span><br><span class="line">&#123;&quot;type&quot;:4,&quot;data&quot;:&quot;&#123;\&quot;index\&quot;:1,\&quot;hash\&quot;:\&quot;0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8\&quot;,\&quot;previousHash\&quot;:\&quot;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39\&quot;,\&quot;data\&quot;:[],\&quot;timeStamp\&quot;:1679825465536,\&quot;nonce\&quot;:8809650,\&quot;running\&quot;:true&#125;&quot;&#125;</span><br><span class="line">/127.0.0.1:8738: QUERY_BLOCK_CHAIN:&#123;&quot;index&quot;:0,&quot;hash&quot;:&quot;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&quot;,&quot;previousHash&quot;:&quot;0&quot;,&quot;data&quot;:[],&quot;timeStamp&quot;:1679825452774,&quot;nonce&quot;:1769903,&quot;running&quot;:true&#125;|&#123;&quot;index&quot;:1,&quot;hash&quot;:&quot;0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8&quot;,&quot;previousHash&quot;:&quot;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&quot;,&quot;data&quot;:[],&quot;timeStamp&quot;:1679825465536,&quot;nonce&quot;:8809650,&quot;running&quot;:true&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开客户端A：</p><hr><p>我们打开客户端A后，默认已经进入服务器内部，我们开始输入2开始挖矿，我们挖两次矿后，输入3查询当前区块链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">===================================</span><br><span class="line">please typing code what you want to do:</span><br><span class="line">1.exit system</span><br><span class="line">2.mine block</span><br><span class="line">3.update_block</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">try to mine block...</span><br><span class="line">Block Mined!!! : 000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39</span><br><span class="line">��0����000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39</span><br><span class="line">===================================</span><br><span class="line">please typing code what you want to do:</span><br><span class="line">1.exit system</span><br><span class="line">2.mine block</span><br><span class="line">3.update_block</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">i received the new block:Block&#123;index=0, hash=&#x27;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&#x27;, previousHash=&#x27;0&#x27;, data=[], timeStamp=1679825452774, nonce=1769903&#125;</span><br><span class="line">2</span><br><span class="line">try to mine block...</span><br><span class="line">Block Mined!!! : 0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8</span><br><span class="line">��1����0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8</span><br><span class="line">===================================</span><br><span class="line">please typing code what you want to do:</span><br><span class="line">1.exit system</span><br><span class="line">2.mine block</span><br><span class="line">3.update_block</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">i received the new block:Block&#123;index=1, hash=&#x27;0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8&#x27;, previousHash=&#x27;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&#x27;, data=[], timeStamp=1679825465536, nonce=8809650&#125;</span><br><span class="line">3</span><br><span class="line">===================================</span><br><span class="line">please typing code what you want to do:</span><br><span class="line">1.exit system</span><br><span class="line">2.mine block</span><br><span class="line">3.update_block</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">Block&#123;index=0, hash=&#x27;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&#x27;, previousHash=&#x27;0&#x27;, data=[], timeStamp=1679825452774, nonce=1769903&#125;</span><br><span class="line">Block&#123;index=1, hash=&#x27;0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8&#x27;, previousHash=&#x27;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&#x27;, data=[], timeStamp=1679825465536, nonce=8809650&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端B：</p><hr><p>这里我们等待客户端A挖完矿之后，连接进入服务器，直接输入3获取当前区块链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">===================================</span><br><span class="line">please typing code what you want to do:</span><br><span class="line">1.exit system</span><br><span class="line">2.mine block</span><br><span class="line">3.update_block</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">===================================</span><br><span class="line">please typing code what you want to do:</span><br><span class="line">1.exit system</span><br><span class="line">2.mine block</span><br><span class="line">3.update_block</span><br><span class="line">===================================</span><br><span class="line"></span><br><span class="line">Block&#123;index=0, hash=&#x27;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&#x27;, previousHash=&#x27;0&#x27;, data=[], timeStamp=1679825452774, nonce=1769903&#125;</span><br><span class="line">Block&#123;index=1, hash=&#x27;0000004fd1849958d1cc5045b41f6bda486e2ab6b0fc69211a2e6de1254027c8&#x27;, previousHash=&#x27;000000c257847251e823c5148046dec1bd0fbdf5aa6d1ecb8d5eba22fd217d39&#x27;, data=[], timeStamp=1679825465536, nonce=8809650&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>5.实现Web API查询服务</h1><p>1.需要引入JAVA EE Web框架</p><p>2.需要部署Tomcat服务器</p><p>3.需要检查是否引入jar包到Web-INF 的lib</p><p>4.使用运行之前需要打开ServiceServer 、ServiceClient，并且让ServiceClient挖好矿之后再进行查询测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.giyaYon.Network;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.giyaYon.Service.ServiceClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.text.StringEscapeUtils;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@javax</span>.servlet.annotation.WebServlet(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">peer</span> <span class="operator">=</span> <span class="string">&quot;ws://localhost:8888&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServiceClient</span> <span class="variable">serviceClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceClient</span>(peer);</span><br><span class="line">        serviceClient.runClientServer();</span><br><span class="line">        serviceClient.connection.queryChainFromOthers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">blocks</span> <span class="operator">=</span> serviceClient.connection.queryChainFromLocal();</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;&lt;p&gt;&quot;</span>+ blocks +<span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        serviceClient.exitClientServer();</span><br><span class="line"></span><br><span class="line">        System.out.println(blocks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>在localhost:8080/CoinBlock_war_exploded/ 后面输入hello</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/api.png" style="zoom:80%;" /><h1>后言</h1><p><strong>Author:</strong> <a href="mailto:undefined">GiyaYon</a></p><p><strong>Copyright Notice:</strong> All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p><p>后续将扩充交易信息内容模块，针对交易过程，设计Web电子商务系统，完善整个区块链系统。</p><p>参考文章：</p><p><a href="https://www.cnblogs.com/helloworld2018/p/9011369.html">https://www.cnblogs.com/helloworld2018/p/9011369.html</a> java开发区块链只需150行代码 /<a href="https://home.cnblogs.com/u/helloworld2018/">以太坊开发</a>/2018-07-19</p><p><a href="https://cloud.tencent.com/developer/article/1776246">https://cloud.tencent.com/developer/article/1776246</a> 基于Java开发一套完整的区块链系统（附源码）/ <a href="https://gitee.com/luckytuan?utm_source=poper_profile">luckytuan</a>/2021-01-20</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;本文欲实现的需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设计区块和链结构&lt;/strong&gt;：你可以创建一个&lt;code&gt;Block&lt;/code&gt;类来表示区块，其中包含属性：如时间戳、交易数据、前一个区块的哈希值、当前区块的哈希值等。然后创</summary>
      
    
    
    
    <category term="软件工程" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件开发，桌面应用" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%8C%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="软件开发" scheme="http://giyayonlib.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="区块链" scheme="http://giyayonlib.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Java" scheme="http://giyayonlib.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android企业级开发概述</title>
    <link href="http://giyayonlib.com/2023/03/28/%E5%AE%89%E5%8D%93%E7%A7%BB%E5%8A%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://giyayonlib.com/2023/03/28/%E5%AE%89%E5%8D%93%E7%A7%BB%E5%8A%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2023-03-28T09:25:55.649Z</published>
    <updated>2023-03-28T11:25:37.435Z</updated>
    
    <content type="html"><![CDATA[<h1>安卓系统架构简述</h1><p>Android系统的架构分为四层，从高层到底层依次为：<br>1、应用程序层（app+System apps）<br>2、应用程序框架层（Java API Framework）<br>3、系统运行库和运行环境层(Libraries + android Runtime)<br>4、Linux核心层(HAL+ Linux Kernel)</p><h1>一、数据</h1><h2 id="1-安卓数据结构">(1)安卓数据结构</h2><p>1、List(LinkedList、Vector、ArrayList)</p><p>2、Set(TreeSet、HashSet)</p><p>3、Map(TreeMap、HashMap、ArrayMap、LinkedHashMap)</p><h2 id="2-数据持久化">(2)数据持久化</h2><p>1、本地数据库之SQLite数据库</p><p>2、本地键值对储存库之SharedPreferences</p><h1>二、界面</h1><h2 id="1-官方UI控件">(1)官方UI控件</h2><p>1、布局<br>2、容器<br>3、常用组件</p><h2 id="2-自定义组件">(2)自定义组件</h2><p>1、组装组件<br>2、组件扩展<br>3、全自定义组件</p><h2 id="3-UI操作">(3)UI操作</h2><p>1、事件分发<br>2、事件处理</p><h2 id="4-高级交互式界面组件">(4)高级交互式界面组件</h2><p>1、fragment</p><p>2、DrawLayout</p><p>3、Dialog</p><h1>三、Android项目&amp;Android系统环境</h1><h2 id="1-四大组件">(1)四大组件</h2><p>1、Activity</p><p>2、service</p><p>3、broadcast receiver</p><p>4、content provider</p><h2 id="2-生命周期">(2)生命周期</h2><p>1、生命周期详解</p><h2 id="3-Intent系统级消息传递">(3)Intent系统级消息传递</h2><p>1、Intent详解</p><h2 id="4-权限">(4)权限</h2><p>1、动态权限申请</p><p>2、权限详解</p><h2 id="5-通知">(5)通知</h2><p>1、Notification通知使用</p><h2 id="6-音、视频管理">(6)音、视频管理</h2><p>1、音频的播报</p><p>2、视频的播放</p><h2 id="7-项目架构设计模式">(7)项目架构设计模式</h2><p>1、MVC</p><p>2、MVP</p><p>3、模块化设计理念</p><h2 id="8-观察者模式">(8)观察者模式</h2><p>1、观察者模式的基本实践</p><h1>四、设备硬件、传感器</h1><h2 id="1-动作传感器">(1)动作传感器</h2><p>1、动作传感器的基本使用</p><h2 id="2-环境传感器">(2)环境传感器</h2><p>1、环境传感器的基本使用</p><h2 id="3-位置传感器">(3)位置传感器</h2><p>1、位置传感器的基本使用</p><h2 id="4-多媒体硬件">(4)多媒体硬件</h2><p>1、相机<br>2、录音机<br>3、扬声器<br>4、蓝牙<br>5、WiFi<br>6、NFC<br>7、USB</p><h1>五、java基础</h1><h2 id="1-关键字">(1)关键字</h2><p>1、java关键字的基本讲解</p><h2 id="2-网络通信">(2)网络通信</h2><p>1、http网络通信<br>2、mqtt网络通信</p><h2 id="3-序列化">(3)序列化</h2><p>1、java序列化基础</p><h2 id="4-多线程">(4)多线程</h2><p>1、多线程详解</p><h2 id="5-锁">(5)锁</h2><p>1、android三种常用锁讲解</p><h2 id="6-类的继承-接口的实现">(6)类的继承&amp;接口的实现</h2><p>1、类继承的基本概念<br>2、接口的基本概念</p><h2 id="7-反射">(7)反射</h2><p>1、反射的基本概念及使用</p><h1>六、主流框架&amp;SDK集成开发</h1><h2 id="（1）主流框架">（1）主流框架</h2><ol><li>网络通讯之Okhttp、xUtils</li><li>图像处理之glide，imageLoader，Fresco，Picasso</li><li>轮播图banner</li><li>json数据处理之Gson</li><li>二维码之zxing</li><li>事件处理EventBus</li></ol><h2 id="（2）SDK集成开发">（2）SDK集成开发</h2><ol><li>虹软人脸识别SDK(带完美封装源码)</li><li>百度地图SDK</li><li>百度语音识别SDK</li><li>腾讯Bugly应用更新SDK</li><li>推送JPush</li><li>后端云服务Bomb</li><li>分享平台ShareSDK</li></ol><h1>后言</h1><p>参考文章：</p><p>1.<a href="http://t.csdn.cn/zvbvL">Android企业级项目实战——基础篇（系列文章）</a> /<a href="https://blog.csdn.net/EGM_NB">Carry 海</a> /2022-07-27</p><p>2.<a href="http://t.csdn.cn/IoPog">Android面试题集（2020）</a>/<a href="https://blog.csdn.net/qq_42761395">计蒙不吃鱼</a>/2020-10-03</p><p>3.<a href="http://t.csdn.cn/8GtNK">【精华】安卓开发学习路线规划</a>  /<a href="https://blog.csdn.net/cbwem">Time-space</a>/2020-11-19</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;安卓系统架构简述&lt;/h1&gt;
&lt;p&gt;Android系统的架构分为四层，从高层到底层依次为：&lt;br&gt;
1、应用程序层（app+System apps）&lt;br&gt;
2、应用程序框架层（Java API Framework）&lt;br&gt;
3、系统运行库和运行环境层(Libraries </summary>
      
    
    
    
    <category term="软件工程" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件开发" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="移动开发" scheme="http://giyayonlib.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="软件开发" scheme="http://giyayonlib.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="http://giyayonlib.com/tags/Java/"/>
    
    <category term="Android" scheme="http://giyayonlib.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术入门</title>
    <link href="http://giyayonlib.com/2023/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://giyayonlib.com/2023/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-03-19T16:08:19.142Z</published>
    <updated>2023-04-02T03:34:09.079Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>区块链已经成为构建信任的新技术基础设施，通过深度融合密码学、对等网络、共识算法、智能合约等技术进行集成创新，即实现了更广泛的社会协作，又降低了社会的信号成本。第一章为概述，宏观上介绍区块链基础知识，第二到五章分别介绍区块链的核心技术，包括区块链的密码学基础、网络协议、共识算法、智能合约等。第六到八章详解典型的区块链技术实践平台，比特币、以太坊等。</p><p>2023/3/20</p><h1>第一章 区块链概述</h1><h2 id="1-技术特点">1.技术特点</h2><ul><li>分布式一致</li><li>密码算法</li><li>对等网络</li><li>数据库</li><li>货币竞争化</li></ul><h3 id="1-储存">1.储存</h3><p>区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，它很像数据库，你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致，但缺点在于它只能增加，和查询，却不能实现修改和删除。</p><p>区块链没有管理员，是一个去中心化的应用。任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。</p><h3 id="2-安全">2.安全</h3><p>区块链是由一个个区块节点组成，一个区块分为头和体，头数据记录着当前区块的多个特征值，体记录着保护的数据。</p><p>头记录着该区块的特征，比如这个区块的生成时间，上一个区块的头数据，头数据通过 <mark>SHA256</mark> 加密出一段哈希值，因为一个区块连着上一个区块，如果改本区块的内容，那么后面的区块也随之改变，发布到全网自然会被淘汰掉，所以实现了不可篡改的要求。</p><pre><code>## 2.历史发展</code></pre><h3 id="1-0货币">1.0货币</h3><p>1.全网共享账本：不易攻破系统</p><p>2.块链式结构：加密有序</p><h3 id="2-0-智能合约">2.0 智能合约</h3><p>在隔离沙箱中运行契约程序</p><h2 id="3-结构层次">3.结构层次</h2><p>定义：狭义上按时间顺序连续区块组成一种数据结构，以密码学保证不可篡改伪造功能的分布式账本；广义上利用块链式数据结构验证存储数据利用分布式节点共识算法生成更新数据，利用密码学保证安全，利用自动化来编程与操作数据的分布式基础架构与计算范求。</p><p>应用层 开发应用工程开发工具</p><p>合约层 智能合约编程语言，沙箱</p><p>激励层 发行货币，分配机制</p><p>共识层 Pow，Pos共识算法</p><p>网络层 拓扑结构，传播</p><p>数据层 区块数据与加密</p><h3 id="1-数据层">1.数据层</h3><p>有区块结构、链结构、交易结构，通过链式结构链接以时间戳顺序打包区块结构实现不可篡改。交易结构就是基本的数据结构，记录交易的双方基本交易信息。</p><h3 id="2-网络层">2.网络层</h3><p>网络拓扑结构，区块或交易等数据协议和验证机制。在节点生成后时刻监听广播与数据，验证是否有效，检查后才加入区块</p><h3 id="3-共识层">3.共识层</h3><p>全网存储一致性：共识算法，避免区块生成过快，通过节点证明能力获得记账权的共识与难度变动的共识算法。在一定认可后确定生成区块并给予一定的奖励。</p><h3 id="4-激励层">4.激励层</h3><p>经济激励的发行于分配机制，例如发行货币是否有上限，挖矿奖励的分配</p><h3 id="5-合约层">5.合约层</h3><p>智能合约由编程语言，沙箱环境以及外部输入正确信息的预言机组成，是一段运行在安全环境的计算机程序。</p><p>该合约不可篡改，只能升级，就是生成新区块部署。</p><p>合约的生命周期：创建开发、部署运行、升级、销毁。</p><h3 id="6-应用层">6.应用层</h3><p>定义区块链应用的准则模型，垂直行业以及开发工具等。</p><h2 id="4-总结">4.总结</h2><p>分布式、密码算法、网络协议构成区块链的基础，共识算法到后来的智能合约在比特币以太坊中有所扩展，数据库存储电子货币都有所应用。</p><h1>第二章 区块链的密码学基础</h1><h1>第三章 区块链的网络协议</h1><h1>第四章 共识算法</h1><h1>第五章 智能合约</h1><h1>第六章 比特币</h1><h2 id="1-货币">1.货币</h2><p>​数字货币是基于数学加密原理构建的不可伪造的货币系统，而比特币是第一个基于数学加密原理构建的分布式数字货币系统。比特币和区块链有什么关系？一句话概括，比特币使用区块链技术实现了数字货币的可信支付。</p><p>​说起货币，我们想到的就是日常生活中使用的纸币。但是，纸币并不是天生就出现的。如果追溯到三千多年前，人类社会并没有任何货币，部落之间的贸易是物物交换。随着经济和贸易的发展，迫切需要一种“<strong>一般等价物</strong>”来作为商品交换的“中介”，这种一般等价物就是货币。最早的货币是贝壳，后来由于金属冶炼技术的进步，出现了铜、铁铸造的货币。金属货币由于体积小，容易分割和铸造，逐渐获得了广泛的使用。最终，世界各国的金属货币都落到了金、银这几种<strong>贵金属</strong>上。</p><p>​随着经济的继续发展，<strong>金属货币因为沉重并且不易携带</strong>，因此，人们发明了纸币。世界上最早的纸币出现在中国宋朝，称为“交子”。纸币的发行机制决定了必须由政府发行，并且强行推广使用，因此纸币又称法币。</p><p>​随着计算机技术的发展，银行系统经过几十年的发展，已经用计算机系统完全代替了人工记账，纸币也实现了<strong>电子化</strong>。现在，我们可以自由地使用网银、支付宝这样的工具实现随时随地转账付款，就得益于纸币的电子化和网络化。</p><p>​电子货币本质上仍然是法币，它仍然是由<strong>央行发行</strong>，只是以计算机技术把货币以实体纸币形式的流通变成了银行计算机系统的存款。和纸币相比，电子货币具有更高的流动性。我们每天使用的网上银行、支付宝、微信支付等，都是这种方式。</p><p>​而比特币作为一种数字货币，它和电子货币不同的是，比特币<strong>不需要一个类似银行的中央信任机构</strong>，就可以通过全球P2P网络进行发行和流通，这一点听上去有点不可思议，但比特币正是一种通过密码学理论建立的不可伪造的货币系统。</p><p>​总的来说，比特币具有以下特点：</p><ul><li>创建了无需信任中心的货币发行机制；</li><li>发行数量由程序决定，无法随意修改；</li><li>交易账本完全公开可追溯，不可篡改；</li><li>密码学理论保证货币防伪造，防双花；</li><li>数字签名机制保证交易完整可信，不可抵赖和撤销。</li></ul><h2 id="2-钱包">2.钱包</h2><p>比特币的交易是一种无需信任中介参与的P2P（Peer-to-peer）交易。</p><h3 id="数字签名">数字签名</h3><p>​传统的电子交易，交易双方必须通过银行这样的信任机构作为中介，这样可以保证交易的安全性，因为银行记录了交易双方的账户资金，能保证在一笔交易中，要么保证成功，要么交易无效，不存在一方到账而另一方没有付款的情况；</p><p>​但是在比特币这种去中心化的P2P网络中，并<strong>没有</strong>一个类似银行这样的<strong>信任机构</strong>存在，要想在两个节点之间达成交易，就必须实现一种在零信任的情况下安全交易的机制。</p><p>​假设有两个人，一个叫小明，一个叫小红，小明说：“我转一万块给小红！”。如何验证这个声明确实是小明作出的呢？数字签名就可以验证这个声明是否是小明做的，并且，一旦验证通过，小明是无法抵赖的。</p><p>在比特币交易中，付款方就是通过数字签名来证明自己拥有某一笔比特币，并且，要把这笔比特币转移给指定的收款方。使用签名是为了验证某个声明确实是由某个人做出的。例如，在付款合同中签名，可以通过验证笔迹的方式核对身份。而在计算机中，用密码学理论设计的数字签名算法比验证笔迹更加可信。使用数字签名时，每个人都可以自己生成一个秘钥对，这个秘钥对包含一个私钥和一个公钥：私钥被称为Secret Key或者Private Key，私钥必须严格保密，不能泄漏给其他人；公钥被称为Public Key，可以公开给任何人；</p><p>当私钥持有人，例如，小明希望对某个消息签名的时候，他可以用自己的私钥对消息进行签名，然后，把消息、签名和自己的公钥发送出去；其他任何人都可以通过小明的公钥对这个签名进行验证，如果验证通过，可以肯定，该消息是小明发出的。</p><p>数字签名算法在电子商务、在线支付这些领域有非常重要的作用：</p><ul><li>首先，签名不可伪造，因为私钥只有签名人自己知道，所以其他人无法伪造签名。</li><li>其次，消息不可篡改，如果原始消息被人篡改了，那么对签名进行验证将失败。</li><li>最后，签名不可抵赖。如果对签名进行验证通过了，那么，该消息肯定是由签名人自己发出的，他不能抵赖自己曾经发过这一条消息。</li></ul><h3 id="支付钱包">支付钱包</h3><p>对于比特币来说，钱不是支付给个人的，而是支付给某一把私钥。这就是交易匿名性的根本原因，因为没有人知道，那些私钥背后的主人是谁。所以，<strong>比特币交易的第一件事，就是你必须拥有自己的公钥和私钥。</strong></p><p>​首先生成一个比特币钱包（wallet）。<strong>这个钱包不是用来存放比特币，而是存放你的公钥和私钥。<strong>软件会帮你生成这两把钥匙，然后放在钱包里面。根据协议，公钥的长度是512位。这个长度不太方便传播，因此协议又规定，要为</strong>公钥生成一个160位的</strong><mark>指纹</mark>。所谓指纹，就是一个比较短的、易于传播的哈希值。160位是二进制，写成十六进制，大约是26到35个字符，比如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2。这个字符串就叫做<strong>钱包的地址</strong>，它是唯一的，即每个钱包的地址肯定都是不一样的。</p><p>​你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。由于你是这个地址的拥有者，所以你会收到这笔钱。</p><p><strong>由于你是否拥有某个钱包地址，是由私钥证明</strong>的（具体的证明方法稍后介绍），所以一定要保护好私钥。这是极其重要的，如果你的私钥被偷了，你的比特币也就等于没了，因为他人可以冒用你的身份了，把钱包里面的钱都转走。</p><p>同样的，你向他人支付比特币，千万不能写错他人的钱包地址，否则你的比特币就支付到了另一个不同的人了。</p><h2 id="3-交易">3.交易</h2><p>​比特币实际的交易记录是由一系列交易构成，每一个交易都包含一个或多个输入，以及一个或多个输出。未花费的输出被称为UTXO（Unspent Transaction Ouptut）。</p><p>**一笔交易就是一个地址的比特币，转移到另一个地址。**由于比特币的交易记录全部都是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否拥有足够的比特币，完成这笔交易，这是可以轻易验证的。</p><p>问题出在怎么防止其他人，冒用你的名义申报交易。举例来说，有人申报了一笔交易：地址 A 向地址 B 支付10个比特币。我怎么知道这个申报是真的，申报人就是地址 A 的主人？</p><p>比特币协议规定，申报交易的时候，除了交易金额，<strong>转出比特币的一方</strong>还必须提供以下数据。</p><blockquote><ul><li>上一笔交易的 Hash（你从哪里得到这些比特币）</li><li>本次交易双方的地址，支付方的地址</li><li>支付方的公钥</li><li>支付方的私钥生成的数字签名</li></ul></blockquote><p>验证这笔交易是否属实，需要三步。</p><blockquote><p>第一步，找到上一笔交易，确认支付方的比特币来源。算出他的资产是否足够支付这场交易</p><p>第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。</p><p>第三步，使用支付方公钥去解开数字签名，保证私钥属实。</p></blockquote><p>经过上面三步，就可以认定这笔交易是真实的。</p><h2 id="4-交易确认与写入区块链">4.交易确认与写入区块链</h2><p>确认交易的真实性以后，交易还不算完成。<strong>交易数据必须写入数据库，才算成立，对方才能真正收到钱。</strong></p><p>比特币使用的是一种特殊的数据库，叫做区块链（blockchain），详细的介绍请看<a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html">《区块链入门教程》</a>。本文只讨论交易如何写入区块链。</p><p>首先，所有的交易数据都会传送到矿工那里。矿工负责把这些交易写入区块链。</p><p>根据比特币协议，一个区块的大小最大是 1MB，而一笔交易大概是500字节左右，因此一个区块最多可以包含2000多笔交易。矿工负责把这2000多笔交易打包在一起，组成一个区块，然后计算这个区块的哈希。</p><p>计算哈希的过程叫做采矿，这需要大量的计算。矿工之间也在竞争，谁先算出哈希，谁就能第一个添加新区块进入区块链，从而享受这个区块的全部收益，而其他矿工将一无所获。</p><p>一笔交易一旦写入了区块链，就无法反悔了。这里需要建立一个观念：**比特币不存放在钱包或其他别的地方，而是只存在于区块链上面。**区块链记载了你参与的每一笔交易，你得到过多少比特币，你又支付了多少比特币，因此可以算出来你拥有多少资产。</p><h2 id="5-矿工挖矿">5.矿工挖矿</h2><p>​当某个矿工成功找到特定哈希的新区块后，他会立刻向全网<strong>广播该区块</strong>。其他矿工在收到新区块后，会对新区块进行验证，如果有效，就把它添加到区块链的尾部。同时说明，在本轮工作量证明的竞争中，这个矿工胜出，而其他矿工都失败了。失败的矿工会抛弃自己当前正在计算还没有算完的区块，转而开始计算下一个区块，进行下一轮工作量证明的竞争。</p><p>为什么区块可以安全广播？因为Merkle Hash锁定了该区块的所有交易，而该区块的第一个coinbase交易输出地址是该矿工地址。每个矿工在挖矿时产生的区块数据都是不同的，所以无法窃取别人的工作量。</p><p>​在比特币的P2P网络中，有一类节点，它们时刻不停地进行计算，试图把新的交易打包成新的区块并附加到区块链上，这类节点就是矿工。因为每打包一个新的区块，打包该区块的矿工就可以获得一笔比特币作为奖励。所以，打包新区块就被称为挖矿。</p><p>​比特币的挖矿原理就是一种工作量证明机制。<strong>工作量证明POW</strong>是英文Proof of Work的缩写。</p><p>​如果两个矿工在同一时间各自找到了有效区块，注意，这两个区块是不同的，因为coinbase交易不同，所以Merkle Hash不同，区块哈希也不同。但它们只要符合难度值，就都是有效的。这个时候，网络上的其他矿工应该接收哪个区块并添加到区块链的末尾呢？答案是，都有可能。</p><p>​通常，矿工接收先收到的有效区块，由于P2P网络广播的顺序是不确定的，不同的矿工先收到的区块是有可能的不同的。这个时候，我们说区块发生了分叉：在分叉的情况下，有的矿工在绿色的分叉上继续挖矿，有的矿工在蓝色的分叉上继续挖矿：但是最终，总有一个分叉首先挖到后续区块，这个时候，由于比特币网络采用<mark>最长分叉的共识算法</mark>，绿色分叉胜出，蓝色分叉被废弃，整个网络上的所有矿工又会继续在最长的链上继续挖矿。由于区块链虽然最终会保持数据一致，但是，一个交易可能被打包到一个后续被孤立的区块中。所以，要确认一个交易被永久记录到区块链中，需要对交易进行确认。如果后续的区块被追加到区块链上，实际上就会对原有的交易进行确认，因为链越长，修改的难度越大。一般来说，经过6个区块确认的交易几乎是不可能被修改的。</p><h3 id="手续费">手续费</h3><p>​交易的确认离不开矿工。为什么有人愿意做矿工呢？比特币协议规定，挖到新区块的矿工将获得奖励，一开始（2008年）是50个比特币，然后每4年减半，目前（2018年）是12.5个比特币。这也是比特币的<strong>供给增加机制</strong>，流通中新增的比特币都是这样诞生的。你可能看出来了，每4年奖励减半，由于比特币可以分割到小数点后八位，那么到了2140年，矿工将得不到任何奖励，比特币的数量也将停止增加。这时，矿工的收益就完全依靠交易手续费了。</p><p>所谓交易手续费，就是矿工可以从每笔交易抽成，具体的金额由支付方自愿决定。你完全可以一毛不拔，一分钱也不给矿工，但是那样的话，你的交易就会没人处理，迟迟无法写入区块链，得到确认。矿工们总是优先处理手续费最高的交易。</p><p>目前由于交易数量猛增，手续费已经水涨船高，一个区块2000多笔交易的手续费总额可以达到3～10个比特币。如果你的手续费给低了，很可能过了一个星期，交易还没确认。</p><h2 id="6-点对点网络">6.点对点网络</h2><p>比特币是一个全世界的开放网络，只要你有服务器，就能加入这个网络，成为一个节点。每个节点都包含了整个区块链（目前2018大概 100多 GB），并且节点之间时刻不停地在同步信息。当你发生了一笔支付，你所在的节点就会把这笔交易告诉另一个节点，直至传遍整个网络。矿工从网上收集各种新发生的交易，将它们打包写入区块链。一旦写入成功， 矿工所在节点的区块链，就成为最新版本，其他节点都会来复制新增的区块，保证全网的区块链都是一致的。</p><p>最后，你所在的节点也拿到了最新的区块链，从而得知你早先的那笔交易，已经写在里面了，至此交易确认成功。</p><h2 id="7-UTXO模型">7.UTXO模型</h2><p>比特币的区块链由一个个区块串联构成，而每个区块又包含一个或多个交易。</p><p>如果我们观察任何一个交易，它总是由若干个输入（Input）和若干个输出（Output）构成，一个Input指向的是前面区块的某个Output，只有Coinbase交易（矿工奖励的铸币交易）没有输入，只有凭空输出。所以，任何交易，总是可以由Input溯源到Coinbase交易。</p><p>还没有被下一个交易花费的Output被称为UTXO：Unspent TX Output，即未花费交易输出。给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和。</p><p>因此，比特币的交易模型和我们平时使用的银行账号有所不同，它并没有账户这个说法，只有UTXO。想要确定某个人拥有的比特币，并无法通过某个账户查到，必须知道此人控制的所有UTXO金额之和。</p><p>在钱包程序中，钱包管理的是一组私钥，对应的是一组公钥和地址。钱包程序必须从创世区块开始扫描每一笔交易，如果：</p><ol><li>遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；</li><li>遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。</li></ol><p>钱包的当前余额总是钱包地址关联的所有UTXO金额之和。</p><p>如果刚装了一个新钱包，导入了一组私钥，在钱包扫描完整个比特币区块之前，是无法得知当前管理的地址余额的。</p><p>那么，给定一个地址，要查询该地址的余额，难道要从头扫描几百GB的区块链数据？</p><p>当然不是。</p><p>要做到瞬时查询，我们知道，使用关系数据库的主键进行查询，由于用了索引，速度极快。</p><p>把MySQL的binlog日志完整地记录下来，再进行重放，即可在另一台机器上完整地重建整个数据库。把区块链看作不可修改的binlog日志，我们只要把每个区块的所有交易重放一遍，即可重建一个地址-余额的数据库。</p><p>可见，比特币的区块链记录的是修改日志，而不是当前状态。</p><h1>第七章 以太坊</h1><p>以太坊（Ethereum）是一个支持智能合约的区块链平台，它与比特币最大的不同是，以太坊通过一个虚拟机（EVM）可以运行智能合约。</p><h1>第八章 Hyperledger Fabric</h1><h1>后言</h1><p>相关技术文章：</p><p><a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a>  比特币：一种点对点的电子现金系统/中本聪/2008.10</p><p>参考文章：</p><p><a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html">https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html</a> 比特币入门教程/阮一峰/2018.1.4</p><p><a href="https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html">https://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html</a> 区块链入门教程/阮一峰/2017.12.26</p><p><a href="https://www.liaoxuefeng.com/wiki/1207298049439968">https://www.liaoxuefeng.com/wiki/1207298049439968</a> 区块链教程/廖雪峰/2018.4.10</p><p>《区块链技术与实践》朱建民 机械工业出版社.2021</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;区块链已经成为构建信任的新技术基础设施，通过深度融合密码学、对等网络、共识算法、智能合约等技术进行集成创新，即实现了更广泛的社会协作，又降低了社会的信号成本。第一章为概述，宏观上介绍区块链基础知识，第二到五章分别介绍区块链的核心技术，包括区块链的密码</summary>
      
    
    
    
    <category term="网络工程" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="网络安全" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="区块链" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="密码学" scheme="http://giyayonlib.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="网络安全" scheme="http://giyayonlib.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="网络" scheme="http://giyayonlib.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络安全渗透测试作业题</title>
    <link href="http://giyayonlib.com/2023/03/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A%E9%A2%98/"/>
    <id>http://giyayonlib.com/2023/03/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A%E9%A2%98/</id>
    <published>2023-03-11T12:25:18.692Z</published>
    <updated>2023-05-25T07:50:44.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本书是《网络安全渗透测试》王晓东 西安电子科技大学出版社.</p><p>在信息安全领域中，渗透测试是公认度非常高的新型安全测试方法。从其机理而言，渗透测试属于破坏性检验的范畴。在前三章讲渗透测试的基础概念；第四章讲到信息收集，五到七章讲到服务器 客户端 网络设备渗透测试，第八章讲到后渗透测试，第九章讲到社会工程学，十到十一讲到工控网络和无线网络的测试，十二到十三章讲到自动化框架，最后一章讲了质量控制介绍</p><h1 id="第一章：概述"><a href="#第一章：概述" class="headerlink" title="第一章：概述"></a>第一章：概述</h1><h3 id="什么是渗透测试？"><a href="#什么是渗透测试？" class="headerlink" title="什么是渗透测试？"></a>什么是渗透测试？</h3><blockquote><p>​渗透测试是服务于信息安全的保障技术。</p><p>​信息安全又可分为狭义上的信息安全和广义上的信息安全，狭义上是以密码学为基础，服役通信网络、计算机编程等方面相关信息保护技术。</p><p>​渗透测试是指对计算机系统、网络、应用程序等进行安全评估的一种测试方法。渗透测试通过模拟攻击者的攻击方式和手段，来评估目标系统的安全性，并发现系统存在的漏洞和弱点，从而提供针对性的修复建议，以保障系统的安全性和完整性。</p></blockquote><h3 id="渗透测试的分类有哪些？各有什么特点？"><a href="#渗透测试的分类有哪些？各有什么特点？" class="headerlink" title="渗透测试的分类有哪些？各有什么特点？"></a>渗透测试的分类有哪些？各有什么特点？</h3><blockquote><p>1.按照协议分类</p><p>​按照OSI七层模型与用户一层的八层进行针对性试探</p><p>2.按照信息公开与否分类</p><p>​是否通过公开测试来进行测试</p><p>3.按照测试方法分类</p><p>​黑盒测试：对服务器内部情况一无所知，只有DNS、Web、E-mail公开的服务器知道</p><p>​白盒测试：通过正规渠道获取到公司内部的服务器结构框架针对性的模拟内部企业雇员的越权行为</p><p>4.按照测试目标分类</p><p>​专门的操作系统，数据库，网络设备进行测试</p></blockquote><h3 id="渗透测试的主要方法有哪些？"><a href="#渗透测试的主要方法有哪些？" class="headerlink" title="渗透测试的主要方法有哪些？"></a>渗透测试的主要方法有哪些？</h3><blockquote><ol><li>主动侦查：这是收集有关目标系统的信息的过程。渗透测试人员会使用各种技术和工具，如端口扫描、DNS信息收集和Whois查询等，来收集有关目标系统的详细信息。</li><li>社会工程学攻击：这是一种攻击人员通过欺骗、伪装等方式欺骗用户揭露密码、访问权限等敏感信息的技术。渗透测试人员会通过各种方式测试系统用户的社会工程学素养，包括钓鱼、垃圾邮件和网络欺诈等。</li><li>漏洞扫描：这是通过使用自动化工具扫描目标系统中的漏洞，以确定目标系统中存在的安全漏洞。常见的漏洞扫描工具包括OpenVAS、Nessus和Nmap等。</li><li>漏洞利用：这是一种尝试利用发现的安全漏洞来获取系统访问权限的行为。这包括使用各种技术和工具，如暴力破解、字典攻击和缓冲区溢出等。</li><li>密码攻击：这是一种针对系统中存储的密码进行攻击的行为。渗透测试人员会使用各种密码破解工具，如John the Ripper和Hashcat等，以尝试破解系统中存储的密码。</li><li>社会工程学测试：这是一种测试目标系统用户的社会工程学素养的行为。渗透测试人员会模拟各种攻击场景，以测试系统用户对攻击的反应和应对能力。</li></ol></blockquote><h3 id="渗透测试与软件测试的区别是什么？"><a href="#渗透测试与软件测试的区别是什么？" class="headerlink" title="渗透测试与软件测试的区别是什么？"></a>渗透测试与软件测试的区别是什么？</h3><blockquote><p>渗透测试（Penetration Testing）也被称为漏洞评估，它是指一种通过模拟黑客攻击的方式，来评估计算机系统、网络或应用程序的安全性的方法。渗透测试通常涉及以下步骤：信息收集、漏洞扫描、漏洞利用、权限提升、数据获取、漏洞利用后清理等。渗透测试需要深入了解系统架构和网络安全知识，通常由专业的安全测试工程师完成。</p><p>软件测试（Software Testing）是指在开发软件的过程中，对软件的各项功能、性能、安全性等进行全面的测试和验证。软件测试通常涉及以下步骤：测试计划、测试用例设计、测试执行、缺陷管理和测试报告。软件测试需要深入了解软件开发和测试方法，通常由专业的测试工程师完成。</p><p>渗透测试侧重于系统安全性的评估和漏洞发现，需要深入了解系统安全领域的知识，而软件测试侧重于软件质量的验证和提高，需要深入了解软件开发和测试方法。</p></blockquote><h3 id="论述渗透测试与黑客攻击的区别？"><a href="#论述渗透测试与黑客攻击的区别？" class="headerlink" title="论述渗透测试与黑客攻击的区别？"></a>论述渗透测试与黑客攻击的区别？</h3><blockquote><ol><li>合法性：渗透测试是经过委托或者授权的正规测试行为，而黑客攻击则是未经授权或违法的攻击行为。</li><li>目的：渗透测试的目的是评估目标系统的安全性，并提供改进措施，而黑客攻击的目的是非法获取系统资源或者信息。</li><li>方法：渗透测试使用合法的测试工具和技术来模拟攻击，以探测和利用系统的安全漏洞，而黑客攻击则使用各种非法手段来攻击目标系统。</li><li>范围：渗透测试在明确范围内进行，不会超出客户授权的范围，而黑客攻击则可以攻击任何目标。</li><li>报告：渗透测试通常会在测试结束后提供详细的测试报告，报告中包括系统中发现的安全漏洞和建议的改进措施。黑客攻击不会提供任何报告，其目的只是攻击目标系统并非法获取信息或者资源。</li></ol></blockquote><h3 id="简述渗透测试的发展过程？"><a href="#简述渗透测试的发展过程？" class="headerlink" title="简述渗透测试的发展过程？"></a>简述渗透测试的发展过程？</h3><blockquote><ol><li>手动渗透测试阶段：早期的渗透测试主要采用手动方式进行，渗透测试人员需要通过自己的知识和经验，手动识别和利用目标系统的漏洞，进行攻击和渗透。</li><li>自动化渗透测试阶段：随着计算机技术的不断发展，渗透测试工具逐渐自动化，如著名的Nmap、Metasploit、Burp Suite等渗透测试工具。这些工具可以自动扫描目标系统，自动化地进行漏洞验证和攻击测试。</li><li>智能化渗透测试阶段：智能化渗透测试工具的出现，使得渗透测试更加高效和准确。智能化渗透测试工具可以通过机器学习、人工智能等技术，快速识别和利用目标系统的漏洞，有效地进行攻击和渗透。</li><li>云渗透测试阶段：云计算的出现，为渗透测试带来了更多的便利和效率。云渗透测试平台可以帮助企业快速、低成本地进行渗透测试，实现对企业安全的全面保护。</li></ol></blockquote><h3 id="渗透测试的步骤是什么？"><a href="#渗透测试的步骤是什么？" class="headerlink" title="渗透测试的步骤是什么？"></a>渗透测试的步骤是什么？</h3><blockquote><p>渗透测试通常涉及以下步骤：信息收集、漏洞扫描、漏洞利用、权限提升、数据获取、漏洞利用后清理等。</p></blockquote><h3 id="渗透测试的工具有哪些？"><a href="#渗透测试的工具有哪些？" class="headerlink" title="渗透测试的工具有哪些？"></a>渗透测试的工具有哪些？</h3><blockquote><p>1.Metasploit</p><p>2.Nessus</p><p>3.Nmap</p><p>4.Burp Suite</p><p>5.OWASP ZAP</p><p>6.SQLmap</p><p>7.Kali Linux</p></blockquote><h3 id="渗透测试的原则有哪些？"><a href="#渗透测试的原则有哪些？" class="headerlink" title="渗透测试的原则有哪些？"></a>渗透测试的原则有哪些？</h3><blockquote><p>1.标准性原则：需要遵守相关规定</p><p>2.规范性原则：有良好的写作格式，清楚地记录所用工具以及策略</p><p>3.可控性原则：对工作的可控，在双方认可的范围内进行</p><p>4.影响性原则：测试过程不可让系统崩溃或网络造成破坏，在业务时间允许的情况进行，做到影响小</p><p>5.整体性和不可缺原则：测试对象不可在规定的范围外进行</p><p>6.保密性原则：过程与结果都要保密，不可泄漏</p></blockquote><h3 id="渗透测试的道德约束和法律约束是什么？"><a href="#渗透测试的道德约束和法律约束是什么？" class="headerlink" title="渗透测试的道德约束和法律约束是什么？"></a>渗透测试的道德约束和法律约束是什么？</h3><blockquote><p>道德约束包括：</p><ol><li>确保事先获得授权：渗透测试必须在经过被测试系统拥有者或合法代表的书面授权后才能进行。</li><li>遵守保密协议：渗透测试人员需要严格遵守保密协议，不得泄露任何有关被测试系统的信息。</li><li>确保安全：渗透测试人员需要在测试期间确保被测试系统的安全性，不得在测试过程中破坏、篡改或者删除任何数据。</li></ol><p>法律约束包括：</p><ol><li>合法授权：渗透测试必须在被测试系统拥有者或合法代表的书面授权后才能进行，否则将会触犯法律。</li><li>不侵犯隐私：在渗透测试过程中，测试人员必须遵守隐私保护规定，不得侵犯被测试系统用户的隐私权。</li><li>不破坏系统：在测试过程中，渗透测试人员必须严格遵守法律规定，不得破坏、篡改或者删除被测试系统中的数据和信息。</li><li>合法使用工具：在渗透测试过程中，测试人员必须使用合法的工具和软件，不得使用非法、盗版或者未授权的工具和软件。</li></ol></blockquote><h1 id="第二章：渗透测试原理与模型"><a href="#第二章：渗透测试原理与模型" class="headerlink" title="第二章：渗透测试原理与模型"></a>第二章：渗透测试原理与模型</h1><h3 id="什么是网络攻击？网络攻击的手段有哪些？"><a href="#什么是网络攻击？网络攻击的手段有哪些？" class="headerlink" title="什么是网络攻击？网络攻击的手段有哪些？"></a>什么是网络攻击？网络攻击的手段有哪些？</h3><blockquote><p>网络攻击是针对计算机信息系统、基础设施、计算机网络或个人计算机设备的任何类型的进攻动作。</p><ol><li>拒绝服务攻击（Denial of Service, DoS）：通过发送大量无效请求或攻击数据包，使服务器负载过大，最终导致服务不可用。</li><li>木马病毒攻击：将木马病毒程序传入目标主机，并通过该程序获取或窃取计算机中的敏感信息。</li><li>黑客攻击：利用漏洞攻击操作系统或应用程序，获取管理员权限，并在系统中实施各种破坏性行为。</li><li>社会工程学攻击：通过伪装成信任的个人或组织，诱骗用户提供敏感信息，如密码、账号等。</li><li>网络钓鱼攻击：利用电子邮件、短信等方式诱导用户点击链接或下载附件，以获取用户的账号和密码等敏感信息。</li><li>网络间谍攻击：通过入侵目标网络或计算机，获取目标组织或个人的敏感信息，如商业机密、个人隐私等。</li><li>网络入侵检测攻击：利用漏洞攻击网络入侵检测系统，从而获得管理员权限，控制系统并绕过安全检测。</li></ol></blockquote><h3 id="密码分析如何按照攻击的方式和条件进行分类？"><a href="#密码分析如何按照攻击的方式和条件进行分类？" class="headerlink" title="密码分析如何按照攻击的方式和条件进行分类？"></a>密码分析如何按照攻击的方式和条件进行分类？</h3><blockquote><p>密码分析是指通过各种手段分析加密或编码后的数据，以便揭示加密算法、密码、密钥等信息。根据攻击的方式和条件，密码分析可以分为以下几类：</p><p>1.1 字典攻击：利用事先准备好的字典文件，尝试对目标加密数据进行猜解，以获得密码信息。</p><p>1.2 暴力破解：穷举所有可能的密码组合，直到找到正确的密码为止。</p><p>1.3 差分攻击：针对加密算法中的差分运算进行攻击，通过观察输入和输出之间的关系来破解密钥。</p><p>1.4 工具攻击：使用各种密码破解工具，如John the Ripper、Hashcat等。</p><p>1.5 侧信道攻击：通过观察目标设备的电磁辐射、功耗、时间等信息，来推测目标设备的加密算法、密钥等信息。</p><p>1.6 社会工程学攻击：通过与目标用户的交互来获取密码等敏感信息，如钓鱼邮件、假冒网站等。</p><p>这些攻击方式可能会结合使用，以提高攻击的成功率。密码分析的目的是为了揭示加密算法的漏洞，从而加强密码的安全性。</p></blockquote><h3 id="什么是漏洞？漏洞的分类有哪些？画图说明安全漏洞的生命周期。"><a href="#什么是漏洞？漏洞的分类有哪些？画图说明安全漏洞的生命周期。" class="headerlink" title="什么是漏洞？漏洞的分类有哪些？画图说明安全漏洞的生命周期。"></a>什么是漏洞？漏洞的分类有哪些？画图说明安全漏洞的生命周期。</h3><blockquote><p>漏洞是系统中存在的一些功能性或安全性的逻辑缺陷，包括可能导致威胁、损坏计算机系统安全性的因素，也可以认为是计算机系统在硬件、软件、协议的具体实现或系统安全策略上存在的所有缺陷和不足。</p><p>1.身份验证与授权漏洞：指攻击者可以通过各种方式绕过身份验证或者授权机制，获得未授权的访问权限。</p><p>2.输入验证漏洞：指攻击者可以利用输入验证不充分的漏洞来执行恶意代码或者通过SQL注入等方式访问和修改数据。</p><p>3.加密和安全协议漏洞：指攻击者可以利用加密算法或安全协议中的漏洞，获取数据或者执行恶意代码。</p><p>4.网络服务漏洞：指网络服务应用程序存在漏洞，导致攻击者可以通过攻击服务来获取系统权限或者执行恶意操作。</p><p>5.操作系统漏洞：指操作系统本身存在的漏洞，攻击者可以利用漏洞获取系统权限或执行恶意操作。</p><p>安全漏洞的生命周期包括以下几个阶段：</p><p>1.发现漏洞：安全漏洞的第一步是发现它们，可以是由安全专业人员、黑客或其他人员发现。</p><p>2.分析漏洞：在这个阶段，安全专业人员需要分析漏洞，确定漏洞的性质和影响范围。</p><p>3.利用漏洞：攻击者利用漏洞来获取系统访问权限、执行恶意代码或窃取敏感信息。</p><p>4.公开漏洞：漏洞可能会被安全专家或黑客公开披露，从而暴露给广大用户。</p><p>5.修复漏洞：漏洞修复是防止攻击的最佳方法，需要厂商或管理员及时修补漏洞，以防止攻击者利用漏洞攻击系统。</p></blockquote><h3 id="区分Shellcode、EXP、Payload"><a href="#区分Shellcode、EXP、Payload" class="headerlink" title="区分Shellcode、EXP、Payload."></a>区分Shellcode、EXP、Payload.</h3><blockquote><p>EXP： 对漏洞如何利用的纤细说明或者是一段演示漏洞攻击的代码，EXP 可以帮助使用者了解漏洞的机理以及利用的方法。</p><p>Payload：攻破目标系统后所进行的操作，目的是提升权限、加强控制等操作。</p><p>Shellcode：指一小段用来执行特定任务的机器码，通常是用于利用软件漏洞的过程中，用于获得对受攻击计算机的控制权限。Shellcode通常被注入到受攻击计算机的内存中，并被执行。Shellcode可以执行各种各样的任务，如创建一个远程访问后门、下载并执行恶意软件、以及执行其他指定的操作。</p></blockquote><h3 id="简述攻击树、攻击图、特权图、Petri、状态转移攻击模型"><a href="#简述攻击树、攻击图、特权图、Petri、状态转移攻击模型" class="headerlink" title="简述攻击树、攻击图、特权图、Petri、状态转移攻击模型"></a>简述攻击树、攻击图、特权图、Petri、状态转移攻击模型</h3><blockquote><p>攻击树（Attack Tree）是一种用于表达攻击路径的方法，它通过树状结构展示攻击者达到某个目标的所有可能路径和方法，每个节点代表一种攻击手段或条件，从根节点开始，通过不断地分解和细化攻击目标，最终到达攻击成功的叶子节点。</p><p>攻击图（Attack Graph）是一种用于分析网络攻击路径的方法，它通过展示攻击者攻击网络时可能的路径、攻击点和攻击方式来分析网络攻击的可能性和危害程度。</p><p>特权图（Privilege Graph）是一种用于描述系统权限控制的方法，它通过展示系统中各个主体（如用户、程序、服务等）的权限关系来分析系统的安全性。</p><p>Petri网（Petri Net）是一种用于描述并发系统的方法，它通过表示系统中的各个状态和状态之间的变迁关系来分析系统的行为和安全性。</p><p>状态转移攻击模型（STAM）是一种基于状态机模型的攻击模型，它通过描述系统中各个状态以及状态之间的转移关系来分析攻击者在系统中的行为和攻击路径。STAM通常用于分析网络协议和安全协议的安全性。</p></blockquote><h3 id="简述攻击方案的生成过程"><a href="#简述攻击方案的生成过程" class="headerlink" title="简述攻击方案的生成过程"></a>简述攻击方案的生成过程</h3><blockquote><ol><li>收集信息：攻击者通过各种手段获取目标系统的信息，包括系统架构、操作系统版本、应用程序版本、网络拓扑结构等。</li><li>制定攻击目标：根据收集到的信息，攻击者制定攻击目标，选择合适的攻击手段和工具，以及攻击的时间和地点。</li><li>分析攻击面：攻击者分析目标系统的攻击面，即可能被攻击的漏洞或弱点，确定攻击方案的方向和重点。</li><li>选择攻击技术：攻击者根据攻击面和攻击目标，选择适合的攻击技术，例如漏洞利用、社会工程学攻击、拒绝服务攻击等。</li><li>编写攻击代码：攻击者根据选择的攻击技术，编写攻击代码或利用已有的攻击代码。</li><li>测试攻击代码：攻击者测试攻击代码的有效性和可靠性，确保攻击能够成功。</li><li>部署攻击代码：攻击者将攻击代码部署到目标系统中，执行攻击。</li><li>操作维护：攻击者在攻击过程中不断进行操作和维护，以保证攻击的成功和持续性。</li></ol></blockquote><h1 id="第三章：渗透测试环境工程"><a href="#第三章：渗透测试环境工程" class="headerlink" title="第三章：渗透测试环境工程"></a>第三章：渗透测试环境工程</h1><h3 id="渗透测试的要素有哪些？"><a href="#渗透测试的要素有哪些？" class="headerlink" title="渗透测试的要素有哪些？"></a>渗透测试的要素有哪些？</h3><blockquote><p>包括测试质量、人员、技术、标准、资源</p><p>质量是测试目标的核心</p><p>人员起决定因素</p><p>技术是工具</p><p>标准是规范要求</p><p>资源是所需基础</p></blockquote><h3 id="简述测试覆盖率与测试效率的关系"><a href="#简述测试覆盖率与测试效率的关系" class="headerlink" title="简述测试覆盖率与测试效率的关系"></a>简述测试覆盖率与测试效率的关系</h3><blockquote><p>测试覆盖率是用来度量测试完整性的一种手段，是测试技术有效性的一个指标。</p><p>测试效率是指测试过程中执行测试人物的时间有效性。</p><p>提升测试效率有利于进一步增加测试覆盖率</p></blockquote><h3 id="对渗透测试人员的要求有哪些？如何进行训练？"><a href="#对渗透测试人员的要求有哪些？如何进行训练？" class="headerlink" title="对渗透测试人员的要求有哪些？如何进行训练？"></a>对渗透测试人员的要求有哪些？如何进行训练？</h3><blockquote><p>1.专业的理论素质</p><p>2.分析解决问题能力</p><p>3.创新思维</p><p>4.团队沟通能力</p><p>5.法律意识与知识</p><p>公认度较高的渗透测试能力训练的手段包括参加CTF和网络对抗训练</p></blockquote><h3 id="简述Docker与虚拟机的区别"><a href="#简述Docker与虚拟机的区别" class="headerlink" title="简述Docker与虚拟机的区别"></a>简述Docker与虚拟机的区别</h3><blockquote><p>虚拟机是通过软件模拟的具有完整硬件系统功能的运行在一个完全隔离环境中的完整计算机系统</p><p>Docker是一个开源的应用容器引擎。让开发者打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows机器上，也可以实现虚拟化。</p><p>区别：</p><p>1.Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器相互隔离。</p><p>2.虚拟机的启动需要几分钟，而Docker容器可以在几毫秒内启动。</p><p>3.Docker没有从操作系统，节省了大量的磁盘空间。</p><p>4.虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户，而Docker通常于隔离不同的应用，例如前端、后端、以及数据库</p></blockquote><h3 id="介绍攻击机平台搭建方法。"><a href="#介绍攻击机平台搭建方法。" class="headerlink" title="介绍攻击机平台搭建方法。"></a>介绍攻击机平台搭建方法。</h3><blockquote><p>攻击机平台是指用于进行渗透测试和安全评估的计算机系统，它可以模拟真实攻击场景并进行安全测试。以下是攻击机平台搭建的一般步骤：</p><ol><li>确定操作系统：选择一个适合渗透测试的操作系统，如Kali Linux、Parrot OS、BlackArch等。</li><li>安装必要的软件：根据具体的渗透测试需求，安装必要的软件，如Nmap、Metasploit、Burp Suite、Hydra、John the Ripper等。</li><li>配置网络：在攻击机平台上设置IP地址、网关、DNS服务器等，确保能够访问被测系统。</li><li>安装虚拟机：如果需要模拟多种攻击场景，可以在攻击机平台上安装虚拟机软件，如VirtualBox、VMware等，并安装适合的操作系统和软件。</li><li>模拟攻击场景：根据渗透测试的目标和要求，模拟真实攻击场景，如Web应用程序渗透测试、无线网络攻击、社会工程学攻击等。</li><li>记录测试结果：在攻击机平台上记录测试过程中的操作和结果，以便进行分析和总结。</li></ol><p>在搭建攻击机平台时，需要注意以下几点：</p><ol><li>安全防护：攻击机平台可能会存在安全风险，需要加强系统安全防护措施，如加密磁盘、安装防病毒软件、关闭不必要的服务等。</li><li>合法性问题：在进行渗透测试时，需要遵守法律法规，确保测试行为的合法性，避免对他人造成损失和影响。</li><li>维护成本：攻击机平台需要进行定期维护和更新，以确保系统稳定性和安全性，需要有专业的人员进行管理和维护。</li></ol></blockquote><h3 id="简述靶场技术。"><a href="#简述靶场技术。" class="headerlink" title="简述靶场技术。"></a>简述靶场技术。</h3><blockquote><p>靶场技术是一种安全测试方法，旨在模拟真实世界中的攻击场景，以评估系统的安全性和弱点。靶场通常是虚拟或真实的系统或网络环境，其中安装了各种漏洞和弱点，以模拟真实世界中的攻击情况。靶场可以用于测试安全人员的技能和知识，以及测试安全工具和技术的有效性。</p><p>靶场技术的基本过程如下：</p><ol><li>确定测试目标：确定要测试的系统或网络，以及测试的目的和范围。</li><li>收集信息：收集与测试目标有关的信息，包括IP地址、端口、操作系统版本、应用程序等。</li><li>定义攻击场景：根据测试目标和信息，定义攻击场景，包括攻击类型、攻击方法、攻击者角色等。</li><li>准备靶场：设置靶场环境，包括安装漏洞和弱点，设置攻击场景和网络拓扑等。</li><li>进行测试：进行测试，模拟攻击场景，测试系统的安全性和弱点。</li><li>分析结果：分析测试结果，确定系统的安全性和弱点，制定改进计划。</li></ol><p>靶场技术可以帮助安全人员了解攻击者的思维方式和攻击方式，帮助他们更好地了解系统和网络的安全性，以便更好地保护其机密性、完整性和可用性。</p></blockquote><h3 id="简述PETS渗透测试标准。"><a href="#简述PETS渗透测试标准。" class="headerlink" title="简述PETS渗透测试标准。"></a>简述PETS渗透测试标准。</h3><blockquote><p>PETS (Penetration Testing Execution Standard) 是一种渗透测试标准，其目的是帮助渗透测试人员开展有效的测试，并为客户提供全面的渗透测试报告。PETS 标准包括以下阶段：</p><ol><li>确定范围：定义测试的目标、边界和规则。</li><li>收集信息：通过各种手段搜集测试目标的信息，包括网络拓扑、操作系统、应用程序等等。</li><li>识别漏洞：通过各种手段识别目标系统的漏洞，包括端口扫描、漏洞扫描、手工测试等等。</li><li>利用漏洞：利用已知或发现的漏洞，获取目标系统的敏感信息或控制权。</li><li>维持访问：保持攻击者对目标系统的持久访问权限。</li><li>分析漏洞：对已发现的漏洞进行分析，包括漏洞利用效果、影响范围、风险等等。</li><li>编写报告：撰写详细的渗透测试报告，包括测试目的、测试方法、测试结果、建议改进等等。</li><li>清除痕迹：在测试结束后，清除所有与测试相关的痕迹，以确保不留下任何安全漏洞。</li></ol><p>PETS 标准的主要特点是：明确的测试流程、可重复性和标准化、详细的测试报告。</p></blockquote><h3 id="简述渗透测试资源的定义。"><a href="#简述渗透测试资源的定义。" class="headerlink" title="简述渗透测试资源的定义。"></a>简述渗透测试资源的定义。</h3><blockquote><p>泛指一切实施渗透测试系统所依赖的软硬件、知识与信息</p><p>分为有形、无形</p><p>无形是指知识与信息，包括漏洞库、字典、社会工程库、系统源代码、指纹特征。</p><p>有形是指设备、软件、人力资源为主</p></blockquote><h3 id="简述渗透测试的漏洞资源。"><a href="#简述渗透测试的漏洞资源。" class="headerlink" title="简述渗透测试的漏洞资源。"></a>简述渗透测试的漏洞资源。</h3><blockquote><p>漏洞库是记录漏洞信息的数据库。有助于为安全厂商基于漏洞发现和攻击防护类的产品提供数据和数据支持，政府机构指导制定未来的安全策略。</p></blockquote><h3 id="简述渗透测试的计算资源。"><a href="#简述渗透测试的计算资源。" class="headerlink" title="简述渗透测试的计算资源。"></a>简述渗透测试的计算资源。</h3><blockquote><p>渗透测试往往需要用密码分析对系统认证进行突破，而密码分析通常需要密集、高质量的计算资源</p></blockquote><h1 id="第四章：渗透测试信息收集与分析"><a href="#第四章：渗透测试信息收集与分析" class="headerlink" title="第四章：渗透测试信息收集与分析"></a>第四章：渗透测试信息收集与分析</h1><h3 id="渗透测试的信息有哪些？"><a href="#渗透测试的信息有哪些？" class="headerlink" title="渗透测试的信息有哪些？"></a>渗透测试的信息有哪些？</h3><blockquote><p>信息源一般分为实物型信息源、文献型信息源、电子型信息源和网络信息源</p><p>1.实物型信息源：具体的观察对象在运动过程中直接产生的有关信息，例如事物运动现场、学术研讨会、展览会等</p><p>2.文献型信息源：承载者系统的知识信息的各种载体信息源，包括图书、报纸、期刊、专利文献、学位论文、公文等。</p><p>3.电子型信息源：电子技术实现信息传播的信息源、广播、电视、电子刊物等。</p><p>网络型信息源：蕴藏在计算机网络、特别是因特网中的有关信息而形成的信息源。</p><p>在渗透测试中，根据信息的性质可以对信息进行不同的划分，不同的信息在时效性、处理方法、存储方法和利用方式上差异很大，要区别对待。</p><p>1.根据信息的可用性，分为直接信息、间接信息、隐藏信息。</p><p>2.根据信息内容，分为技术信息、管理信息、物理细节</p><p>3.根据信息的保密等级，分为公开信息、保密信息、机密信息</p><p>4.根据信息的格式，分为文本信息、参数信息、规律信息</p><p>5.根据信息的位置，分为线上信息和线下信息</p></blockquote><h3 id="渗透测试信息的收集方法有哪些？"><a href="#渗透测试信息的收集方法有哪些？" class="headerlink" title="渗透测试信息的收集方法有哪些？"></a>渗透测试信息的收集方法有哪些？</h3><blockquote><p>按收集的手段分类，信息收集可以分为主动信息收集和被动信息收集。主动信息收集是与目标主机进行直接交互；从而获取目标信息；而被动信息收集恰恰相反，不与目标主机进行直接交互，而是通过第三方获取目标信息。</p><p>1.主动信息收集通过直接访问、扫描、尝试连接等方法收集信息，这种方法将产生流量，可能被监测和记录。</p><p>2.被动信息收集利用第三方的服务对目标进行访问了解，例如搜索引擎、公开媒体等，不产生流量具有比较好的隐蔽性。</p></blockquote><h3 id="公开信息有哪些？如何进行收集？"><a href="#公开信息有哪些？如何进行收集？" class="headerlink" title="公开信息有哪些？如何进行收集？"></a>公开信息有哪些？如何进行收集？</h3><blockquote><p>公开信息资源的表现有报刊、图书、地图、声像、照片、微缩、因特网、其他等。</p><p>信息获取方法</p><p>1.直接获取</p><p>用户可以根据自己对信息的需求，针对明确的信息目标，通过搜索引擎或者网址来精确地定位到信息资源所在的位置。</p><p>2.间接获取</p><p>通过网址链接或者是网络导航来获取网络信息资源。很多时候用户不一定很明确自己所需要的信息资源，一般通过一层一层链接找到对自己有用的信息，这种获取网络信息资源的方式并非目标所指，是网络行为导致的一种必然趋势，但这种方式并不比直接获取简单快捷，一般会花费一些时间，而且有时候最终也不一定能够得到对自己游泳的信息资源。</p><p>3.其他</p><p>除了社交网络外，与社交网络捆绑的金融、服务、旅游、导航也是公开信息收集可利用的渠道</p></blockquote><h3 id="解释什么是Google-Hacking"><a href="#解释什么是Google-Hacking" class="headerlink" title="解释什么是Google Hacking"></a>解释什么是Google Hacking</h3><blockquote><p>设备信息：信息系统是由通信网络链接起来的信息设备构成的，进行渗透测试首先需要了解系统的设备信息。</p><p>​Shodan是用来搜索网络空间中在线主机设备的</p><p>​ZoomEye侧重于Web层面的资产发现。</p><p>网站信息</p><p>​1.网站信息跟踪：网站是企业、单位发布信息的窗口，可以利用网站渗透测试目标的大量公开信息</p><p>​1# 跟踪新闻网站</p><p>​2# 分析相关的专业机构网站</p><p>​3# 关注新型的传播平台</p><p>​4# 利用因特网数字图书馆资源</p><p>​2.搜索引擎：通过搜索引擎可以检索到非常多的信息。</p><p>​谷歌黑客（GoogleHacking）就是专门利用搜索引擎实施黑客活动的方法。</p><p>​渗透测试一般基于软件漏洞给和错误配置，虽然一些有经验的入侵者的目标瞄准了一些特殊的系统，尝试发现可能进入的漏洞，但大部分的入侵者是从具体的软件漏洞或者普通用户错误配置开始查找漏洞，在这些配置中，找到怎样侵入并且尝试发现或者扫描有该中漏洞的系统。谷歌黑客对于第一种攻击者来说用处很少，但是对于第二种攻击者则发挥了重要作用</p><p>社交网络</p><p>​社交网络通过网络聊天、博客、播客和社区共享等途径，实现个体社交圈的逐步扩大，最终形成一个链接”熟人的熟人“的大型网络社交圈，充分反映出人类社会的六度分隔理论特征。蕴含大量可以利用的公开信息，日趋发展成网民获取信息、表达观点和信息交流不可缺少的网络传播媒介。</p><p>​1.信息价值分析</p><p>​从信息获取成本来说，社会上刚发生过的新闻，社交网络上可以第一时间获取，好友发布的日志以及状态也能第一时间获得，单从成本来看，成本很低获取到社交网络的信息普遍具有一定价值</p><p>​从信息获取收益来说，社交网络本身是一个大型的网络圈，信息可以一传十，十传百地传播，信息获取速度块，用户根据自己需求筛选，可以短时间内获得大量对自己有用的信息。</p><p>​从信息本身的有效性和可信度来说，获得同一信息的途径可能不同，那么造成的信息可信度也就不一样，因此根据信息可信度来判断信息的价值也是不确定的，视情况来定</p></blockquote><h3 id="什么是主机指纹信息？"><a href="#什么是主机指纹信息？" class="headerlink" title="什么是主机指纹信息？"></a>什么是主机指纹信息？</h3><blockquote><p>​网络信息系统最基本的单元是主机，因此进行渗透测试时，应当首先获得目标主机的信息。主机信息包括信息内容，指纹信息，安防设备。操作系统指纹是指识别某台网络设备上运行的操作系统类型的特征。网络操作系统的指纹实际上来源于TCP&#x2F;IP的协议栈。TCP&#x2F;IP协议栈技术只在RFC文档中描述，并没有一个统一的行业标准，各个公司在编写应用于自己的操作系统的TCP&#x2F;IP协议栈时，对RFC文档做出了不同的诠释，造成了各个操作系统在TCP&#x2F;IP协议的实现上有所不同。例如人的指纹，通过比较不同操作系统的TCP&#x2F;IP协议栈的细微差异，就可以判定操作系统类型以及版本。这种方式称为”指纹方法学“</p></blockquote><h3 id="如何探测目标系统的安防设备信息？"><a href="#如何探测目标系统的安防设备信息？" class="headerlink" title="如何探测目标系统的安防设备信息？"></a>如何探测目标系统的安防设备信息？</h3><blockquote><p>1.防火墙，扫描出防火墙上开放的端口，通过检查响应包可以识别端口是否被防火墙过滤</p><p>2.负载均衡，负载均衡从其应用的地理结构上分为本地负载均衡和全局负载均衡。本地负载均衡是指对本地的服务器群做负载均衡；全局负载均衡是指分别放置在不同地理位置、有不同网络结构的服务器群间作负载均衡。</p><p>3.WAF识别，Web Application Firewall 应用层，通过执行一些列针对Http&#x2F;Https的安全策略专门来保护Web应用的产品。检测通过WAF检测通过发送一个正常的 Http 请求，然后观察其返回有没有一些特征字符，若没有，再发送一个恶意的请求触发 WAF 拦截，用获取其返回的特征来判断 WAP 的存在。可以借助一些工具，如wafwoof、sqlmap等，也可以使用手动方法(在网站 URL 地址后面输入诸如““and”“1&#x3D;1等SQL 语句)触发 WAF并回显网站的 WAF 信息。对于一些旁路或工作在透明模式的安防设备，如IDS、IPS、行为管控系统、病毒墙等,不能通过主动方式探测，只能通过数据分析和推理的方法了解其存在以及相关参数。</p></blockquote><h3 id="端口扫描有哪些方法？"><a href="#端口扫描有哪些方法？" class="headerlink" title="端口扫描有哪些方法？"></a>端口扫描有哪些方法？</h3><blockquote><p>​端口扫描时，扫描者假意与目标进行TCP连接，发起请求，通过观察端口反应来判断端口信息,端口扫描可以采用的方法包括 TCP connect ()、TCP SYN、TCP FINQNULLACK、UDP 扫描等。</p><p>1.TCP connect() </p><p>​扫描TCP connect()是最基本的TCP扫描，或称为全开扫描。操作系统提供的connect0系统调用，用来与每一个感兴趣的目标计算机的端口进行连接。如果端口处于侦听状态，那么connectO就能成功;否则，这个端口是不能用的，即没有提供服务。这个技术最大的优点是不需要任何权限，系统中的任何用户都有权利使用这个调用。另一个优点就是速度。如果对每个目标端口以线性的方式使用单独的connect0调用，那么将会花费相当长的时间,但可以通过同时打开多个套接字加速扫描，如使用非阻塞 I&#x2F;O 允许设置一个低的时间用尽周期，同时观察多个套接字。这种方法的缺点是很容易被发觉，并且被过滤掉。目标计算机的 logs 文件会显示一连串的连接和连接出错的服务消息，并且能很快地关闭它。</p><p>2.TCP SYN 扫描</p><p>​TCPSYN扫描技术通常被认为是“半开放”扫描，因为这种扫描程序不必打开一个完全的 TCP 连接。扫描程序发送的是一个 SYN 数据包，和试图打开一个实际的连接并等待反应一样(参考 TCP 的三次握手建立一个 TCP 连接的过程)。一个 SYNIACK 的返回信息表示端口处于侦听状态。一个RST返回表示端口没有处于侦听状态。如果收到一个SYNIACK则扫描程序必须再发送一个 RST 信号来关闭这个连接过程。这种扫描技术的优点是一般不会在目标计算机上留下记录;缺点是必须要有 root 权限才能建立SYN 数据包。</p><p>3.TCP FIN 扫描</p><p>​有的时候，SYN扫描有可能不够秘密，一些防火墙和包过滤器会对一些指定的端口进行监视，有的程序能检测到这些扫描，而 FIN 数据包可能会没有任何麻烦地通过。一方面这种扫描方法的思想是关闭的端口会用适当的 RST 来回复 FIN 数据包，另一方面，打开的端口会忽略对 FIN 数据包的回复，这种方法和系统的实现有一定的关系。有的系统不管端口是否打开都回复 RST，这时，TCP FIN 扫描方法就不适用了，但这种方法在区分 UnixNT 时十分有用。</p><p>4.NULL扫描</p><p>​RFC793 中规定，当一个端口关闭时，如果它收到一个标志位为空的信息，系统应当反馈一条 RST;当端口开放时，如果收到这种标志位为空的信息，系统不予响应。这种标志位为空的信息，称其为NULL，故这种扫描称为 NULL 扫描。NULL 扫描的优点就是行踪隐蔽，但相对于半连接扫描(完成一半的 TCP 连接)，毕竟还是执行了大部分握手过程，如果目标网络的安防措施部署得较为深入，难免会有被发现的风险。而 NULL扫描隐蔽性更强，不必过分担心被防火墙和包过滤器等防护设备的端口监视功能发现。</p><p>5，ACK扫描<br>ACK 扫描是利用标志位 ACK 实施扫描探测，而ACK 标志在 TCP 协议中表示确认序号有效，它表示确认一个正常的TCP 连接，但是在 TCP ACK 扫描中没有进行正常的TCP连接过程，实际上是没有真正的TCP连接。使用 TCP ACK 扫不能够确定端口的关闭或者开放，因为当发送给对方一个含有 ACK 表示的TCP 报文时，都返回含有 RST标志的报文，无论端口是开放或者关闭的。</p><p>6、UDP扫描</p><p>​当一个UDP端口接收到一个UDP数据报时，如果它是关闭的，就会给源端发回一个ICMP端口不可达数据报，如果它是开放的，那么就会忽略这个数据报，也就是将它丢而不返回任何信息。UDP扫播的优点是可以完成对 UDP 端口的探测:缺点是需要系统管理员的权限，扫描结果的可靠性不高(因为当发出一个UDP数据报而没有收到任何应答时有可能是因为这个UDP端口是开放的，也有可能是因为这个数据报在传输过程中丢失了)另外，扫描的速度很慢(原因是RFC1812中对ICMP错误报文的生成速度进行了限制)。</p></blockquote><h3 id="简述漏洞扫描的过程。"><a href="#简述漏洞扫描的过程。" class="headerlink" title="简述漏洞扫描的过程。"></a>简述漏洞扫描的过程。</h3><blockquote><p>通过PoC代码或漏洞机理对目标系统进行分析，就可以发现是否存在漏洞。</p><p>漏洞扫描可以分为主机漏洞扫描和网络漏洞扫描，其扫描过程稍有不同。</p><p>1.主机漏洞扫描</p><p>​主机漏洞扫描通常在目标系统上安装一个代理(Agent)或者是服务(Services)以便能够访问所有的文件与进程，以此来扫描计算机中的漏洞。</p><p>2.网络漏洞扫描<br>网络漏洞扫描通过网络来扫描远程计算机中的漏洞，可以看作一种漏洞信息收集。根据不同漏洞的特性构造网络数据包，发给网络中的一个或多个目标服务器，以判断某特定的漏洞是否存在。</p><p>​(1)网络漏洞扫描进行工作时，首先探测目标系统的存活主机(例如 SYN 扫描)，对存活主机进行端口扫描，确定系统开放的端口，同时根据协议指纹技术识别出主机的操作系统类型(初始化旗标):然后根据目标操作系统和提供的网络服务，调用漏洞资料库中已知的各种漏洞进行逐一检测，通过对目标系统探测响应数据包的分析判断是否存在漏洞。</p><p>​(2)当前的漏洞扫描技术主要是基于特征匹配原理的，一些漏洞扫描器通过检测目标主机不同端口开放的服务并记录其应答，然后与漏洞库进行比较，如果满足匹配条件，则认为存在安全漏洞。<br>在漏洞扫描中，漏洞库 PoC 定义的精确与否直接影响最后的扫描结果。费</p></blockquote><h3 id="简述漏洞扫描器的结构。"><a href="#简述漏洞扫描器的结构。" class="headerlink" title="简述漏洞扫描器的结构。"></a>简述漏洞扫描器的结构。</h3><blockquote><p>​在漏洞扫描的过程中，可以借助于漏洞扫描器。</p><p>​传统的漏洞扫描器可以分为两种类型:主机漏洞扫描器(Host Sanner)和网络漏洞扫描器(Network Scanner)。</p><p>​主机漏洞扫描器是用于系统本地运行检测系统漏洞程序的硬设备:</p><p>​网络漏洞扫描器是对企业网络架构系统或者网站进行扫描的硬件设备。</p><p>​漏洞扫描也是一种主动探测的方式，在有些渗透测试条件下不被允许，并且扫描过程也受到扫描器、扫描软件的限制，精准性、指向性比较差。渗透测试者还可以根据应用指纹信息、版本号，通过漏洞发布平台进行直接查询。</p></blockquote><h3 id="如何进行目标系统网络拓扑探测？"><a href="#如何进行目标系统网络拓扑探测？" class="headerlink" title="如何进行目标系统网络拓扑探测？"></a>如何进行目标系统网络拓扑探测？</h3><blockquote><p>​对于目标系统，网络的安全信息最终可以投射到态势图上，形成整体和动态的认识。一般以网络拓扑或地理地图为背景。</p><p>​网络的拓扑结构是研究如何在一个网络中互连节点之间链接的安排，可以分为物理网拓扑和逻辑网络拓扑结构两类。网络拓扑发现技术的原理是通过网络扫播、主机探测数据噢探等技术手段。发现网络拓扑中各网络节点、主机和网络连接等拓扑信息，以及名个设备、主机之间的互连关系。</p><p>​实现网络拓扑探测发现必须要解决的问题主要包括:发现不同类型的设备，发现有关设备类型的详细信息，需要一个更好的算法来识别的设备类以及网络拓扑可视化。</p><p>1.基于ARP协议的网络拓扑发现</p><p>​每个路由设备的以太网接口在本地缓存中维护着张 ARP表，表中记录了接口连接网络中IP地址和MAC的转化关系。因此，根据路由器的 ARP 表项，可以发现接口同一侧局城网中所有的网络设备和主机，然后继续利用 ARP 关系进行发现，以此类推，就可得到整个网络的拓扑结构。这种方法适合于局域网发现，发现效率很高，但不适合于过大的网络,不能发现那些不支持ARP 协议的网络连接和设备。</p><p>2、基于OSPF路由协议的网络拓扑发现</p><p>​开放最短路径优先(OSPF)是一种自适应的路由协议，内部网关协议用于互联网协议(IP)网络。在一个自治系统(AS)内使用链接状态路由算法，用于单一自治系统内决策跨由。<br>​基于 OSPF 路由协议的网络拓扑发现就是根据 OSPF 协议的实现原理，使其能够与路由设备相互通信，访问区域内所有边界路由设备的拓扑数据库。</p><p>3.基于SNMP协议的网络拓扑发现</p><p>​基于 SNMP 协议的网络拓扑发现主要是利用 MIB 中定义的路由信息表(ipRoutetable)来判断网络层的拓扑结构。基于 SNMP 的网络拓扑发现基本上分为网络设备存活性、判别设备类型区分和节点连接发现三个步骤进行。</p></blockquote><h3 id="什么是网络态势图？"><a href="#什么是网络态势图？" class="headerlink" title="什么是网络态势图？"></a>什么是网络态势图？</h3><blockquote><p>​态势感知是一种基于环境和动态整体地洞悉安全风险的能力，是以安全数据为基础,从全局视角提供网络识别、理解分析的一种方式，最终为决策与行动提供支持。</p><p>​态势感知的概念最早在军事领域被提出，分为态势要素获取、理解和预测三个层次(如图412)。并随着网络的兴起而升级为网络态势感知(CyberspaceSituationAwareness，CSA)旨在大规模网络环境中对能够引起网络态势发生变化的安全要素进行获取、理解、显示,以及最近发展趋势的顺延性预测，进而进行决策与行动。</p><p>​态势图基于态势感知技术。在渗透测试过程中建立态势图，能够从全局的角度了解测试目标的安全状态。所谓网络态势图，是指由各种网络设备运行状况、网络行为以及用户行为等因素构成的整个网络当前的安全状态和变化趋势，并采用地图背景展示。</p><p>​态势图一般以地图或拓扑图为背景，上面有服务器、主机、网络节点的各类信息(如IP端口、操作系统、漏洞等)标定，可以通过一些图形操作进行交互访问。</p><p>​这里所说的态势是一种状态、趋势，是整体和全局的概念，任何单一的情况或状态都不能称之为态势，因此对态势的理解特别强调环境性、动态性和整体性。环境性是指态势感知的应用环境，是在一个较大的范围内具有一定规模的网络;动态性是指态势随时间不断变化，态势信息不仅包括过去和当前的状态，还要对未来的趋势做出预测;整体性是态势各实体间相互关系的体现，某些网络实体状态发生变化，会影响到其他网络实体的状态进而影响整个网络的态势。<br>为了实时、准确地绘制整个网络安全态势图，网络安全态势感知要在对网络资源进行要素采集的基础上，通过数据预处理、网络安全态势特征提取、态势评估、态势预测和势展示等过程来完成，这其中涉及许多相关的技术问题，主要包括数据融合技术、数据挖掘技术、特征提取技术、态势预测技术和可视化技术等。</p></blockquote><h3 id="解释网络嗅探的原理。"><a href="#解释网络嗅探的原理。" class="headerlink" title="解释网络嗅探的原理。"></a>解释网络嗅探的原理。</h3><blockquote><p>​嗅探一般指嗅探器捕获网络数据包。</p><p>​噢探器可以窃听网络上传输的数据包。用集线器 hub 组建的网络是基于共享原理的局域网内所有的计算机都接收相同的数据包，而网卡构造了硬件的“过滤器”，通过识别MAC地址过滤掉和自己无关的信息，嗅探程序只需关闭这个过滤器，将网卡设置为“混杂模式”就可以进行嗅探。</p><p>​网络嗅探利用的是共享式的网络传输介质。共享即意味着网络中的一台机器可以嗅探到传递给本网段(冲突域)中所有机器的报文。最常见的以太网就是一种共享式的网络技术。</p><p>​以太网卡收到报文后，通过对目的地址进行检查来判断是否是传递给自己的，如果是，则把报文传递给操作系统;否则，将报文丢弃，不进行处理。</p><p>​网卡存在一种特殊的工作模式，在这种工作模式下，网卡不对目的地址进行判断，而直接将收到的所有报文都传递给操作系统进行处理，这种特殊的工作模式称为混杂模式。网络嗅探器通过将网卡设置为混杂模式来实现对网络的嗅探。</p><p>（网卡：一个主机系统实体中，数据的收发是由网卡来完成的，当网卡接收到传输来的数据时，网卡内的单片程序首先解析数据包的目的网卡物理地址，然后根据网卡驱动程序设置的接收模式判断该不该接收，认为该接收就产生中断信号通知CPU，认为不该接收就丢数据包，所以不该接收的数据包就被网卡截断了，上层应用根本就不知道这个过程。CPU如果得到网卡的中断信号，则根据网卡的驱动程序设置的网卡中断程序地址调用驱动程序接收数据，并将接收的数据交给上层协议软件处理。）</p></blockquote><h3 id="如何进行流量分析？流量分析可以提供哪些信息？"><a href="#如何进行流量分析？流量分析可以提供哪些信息？" class="headerlink" title="如何进行流量分析？流量分析可以提供哪些信息？"></a>如何进行流量分析？流量分析可以提供哪些信息？</h3><blockquote><p>​除了数据包本身，数据包流量统计特征也可能蕴含重要信息。</p><p>​针对数据包流量统计特征蕴含的大量信息进行分析的技术就是网络流量分析。网络流量分析是计算机信息安全领域的一个分支，它将一组设备产生的网络流量作为输入，将与这些设备、用户、应用程序或流量本身有关的信息作为输出。</p><p>​网络流量分析通常包括4 个阶段，流量收集、预处理、数据分析和结果评估。</p><p>流量收集是构建数据集的过程;<br>预处理则通过去除数据集中无效的数据或提取流量的关键特征等将收集到的数据转换为可理解的格式以便后续分析;<br>数据分析是网络流量分析流程中最重要的环节;<br>结果评估输出分析结果。</p><p>​通过网络流量分析可以获取设备、用户行为、用户标识等信息。</p></blockquote><h3 id="什么是正向工程、逆向工程、再工程？关系如何？"><a href="#什么是正向工程、逆向工程、再工程？关系如何？" class="headerlink" title="什么是正向工程、逆向工程、再工程？关系如何？"></a>什么是正向工程、逆向工程、再工程？关系如何？</h3><blockquote><p>​软件逆向分析涵盖在软件逆向工程范畴内。软件逆向工程是软件科学和计算机科学的一个分支，它综合了加密和解密、编译和反编译、系统分析、程序理解等多种计算机技术，从可运行的程序系统出发，生成对应的源程序、系统结构以及相关设计原理和算法思想的文档等。</p><p>​可见软件逆向是对已构建程序的解构还原，从二进制代码出发，逆向猜测、推理、分析出程序原本的功能、逻辑甚至源代码。</p><p>​这个过程与逆向思维过程十分吻合。所谓逆向思维是指从反面提出问题、分析问题、解决问题的一种思维方式，它是与正向思维相对应的一种思维，因此软件逆向分析的逆向思维是对软件创作的正向思维的目标逆向、方向逆向和方式逆向。软件逆向分析过程可视为与软件作者的博弈对抗过程。</p><p>​正向工程是指根据需求和设计，通过编码、编译等步骤，将软件开发为可执行的程序的过程。它是从需求和设计到实现的过程，是软件系统开发的正常流程。</p><p>​逆向工程是从任何人造产品中提取知识或者设计规划的过程。</p><p>​再工程（Reengineering）：再工程是指对已有软件系统的源代码、文档等进行分析和修改，以提高其质量、可维护性和可扩展性的过程。再工程是一个包括逆向工程在内的过程，旨在通过对现有系统进行分析和修改，使其满足新的需求或提高其质量。</p><p>​正向工程解决了功能的实现，说明了哪些功能需要增加和删除;逆向工程是从实现到设计或需求的过程，再工程则是对现有系统进行分析和修改以改进其质量和可维护性的过程。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/%E5%B7%A5%E7%A8%8B%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" style="zoom:50%;" /><center>正向逆向再工程三者关系</center><p>逆向分析的一般流程包括解码&#x2F;反汇编(目标二进制代码)、中间语言翻译(汇编&#x2F;类汇编代码)、数据流分析、控制流分析(各级中间语言)其他分析(高级抽象代码)和优化几个步骤</p><p>​1.静态反汇编是对反汇编出来的程序清单的分析，从提示信息入手进行分析。<br>​目前,多数软件在设计时都采用了人机对话方式。所谓人机对话，即在软件运行过程中，需要有用户选择的地方，软件应显示相应的提示信息，并等待用户按键选择。如在执行某段程序之后显示一串提示信息，以反映该段程序运行后的状态，是正常运行，还是出现错误，或者提示用户进行下一步工作的帮助信息。<br>​如果我们对静态反汇编出来的程序清单进行阅读，就可了解软件的编程思路，顺利破解该软件，这也就是我们常说的破解版(即盗版)。</p><p>​2.编译和反编译不一定要生成汇编代码，一般生成某种设计好的中间语言。但在反编译的二进制解码过程中，首先会生成一种类汇编或汇编代码，因此二进制解码也可称为反汇编。在反编译的过程中，中间代码也有很多级别，类汇编或汇编代码只是低级中语言。<br>中间语言便于对程序的理解和分析。</p><p>​3.数据流分析是在不执行程序的情况下，收集程序数据运行时的信息，分析程序中数据对象之间的关系。</p><p>​4.控制流分析对执行语句的若干可执行路径进行分析，确定程序的控制结构，建立控制流图。控制流分析有两种形式:过程内(intraprocedural)分析和过程间(interprocedural)分析。</p><p>​5.其他分析和优化是指对分析的结果进行高级推理和优化，使其逼近理想结果<br>逆向分析过程通常可以借助于一些软件工具，如反汇编工具IDA(DA Pro Disassemblerand Debugger)、OllyDbg、D32Aam; 反编译工具dcc&#x2F;UQBT&#x2F;Boomerang、CodeSurfer和CodeSufer&#x2F;x86 等，以提高工作效率。</p></blockquote><h1 id="第五章：服务器端渗透测试"><a href="#第五章：服务器端渗透测试" class="headerlink" title="第五章：服务器端渗透测试"></a>第五章：服务器端渗透测试</h1><h3 id="什么是服务器端渗透"><a href="#什么是服务器端渗透" class="headerlink" title="什么是服务器端渗透?"></a>什么是服务器端渗透?</h3><blockquote><p>服务器、客户机以及网络设备等实质上都是计算机主机。</p><p>​服务器端渗透是指攻击者利用漏洞和安全弱点，入侵和控制服务器操作系统、应用程序、数据库等后台系统，以获取敏感信息、掌握系统权限、窃取数据等恶意行为。</p><p>​服务器端渗透通常需要掌握一定的操作系统、网络和编程技能，能够深入了解服务器和应用程序的工作原理，并发现和利用潜在的安全漏洞。攻击者可以使用各种工具和技术来进行服务器端渗透，包括漏洞扫描器、渗透测试框架、密码破解工具、Web Shell等。</p><p>​服务器端渗透可以对企业和组织的核心业务产生巨大的影响，可能导致业务中断、数据丢失、机密泄露等严重后果。因此，服务器端渗透测试也成为企业和组织信息安全管理中的重要组成部分，可以帮助企业和组织发现和修复安全漏洞，提高系统的安全性和稳定性。</p></blockquote><h3 id="什么是DMZ区"><a href="#什么是DMZ区" class="headerlink" title="什么是DMZ区?"></a>什么是DMZ区?</h3><blockquote><p>DMZ（隔离区）也称为军事化区，它是为了解决安装防火墙后部网络的访问用户不能访问内部网络服务器的问题而设立的一个非安全系统与安全系统之间的缓冲区。在这个小网络区域内可以放置一些必须公开的服务器设施，企业Web服务器、FTP服务器和论坛等。</p></blockquote><h3 id="为什么Web-应用程序成为攻击者重点攻击的对象"><a href="#为什么Web-应用程序成为攻击者重点攻击的对象" class="headerlink" title="为什么Web 应用程序成为攻击者重点攻击的对象?"></a>为什么Web 应用程序成为攻击者重点攻击的对象?</h3><blockquote><p>Web应用除了开放性、多样性和脆弱性外，还有以下问题导致了Web应用成为目前信息安全防御体系的短板</p><p>1.远程执行：随着动态网页技术的引用，，Web应用程序提供了大量的功能函数，以实现基于数据的高级应用。</p><p>2.隐蔽性强：Web访问所基于http和https攻击数据流，通常能够正常通过防火墙和过滤技术的监测，为攻击行为提供保护。</p><p>3.更新困难：很多Web站点结合使用了各种商业应用程序和开源脚本，导致很难实时更新安全补丁。</p></blockquote><h3 id="FTP渗透的方法是什么"><a href="#FTP渗透的方法是什么" class="headerlink" title="FTP渗透的方法是什么?"></a>FTP渗透的方法是什么?</h3><blockquote><p>FTP渗透主要利用用户口令破译、远程溢出、文件上传三种方法进行测试。</p><p>​用户口令破译渗透：用户口令破译可以采用的方法有弱口令探测和嗅探，弱口令扫描方法具体是利用积累的口令字典实现，俗称碰撞。</p><p>​远程溢出：当FTP服务程序存在失误时，可能导致程序溢出以及远程命令的执行。渗透者可以通过漏洞挖掘或向已经公布漏洞但未打补丁的服务器发起攻击实现渗透。</p><p>​文件上传渗透：上传文件方式实施基于社会工程学，或上传畸形文件导致下载、执行该文件用户发生错误</p></blockquote><h3 id="比较FTP主、被动模式的不同，并回答为什么被动模式适合公网服务"><a href="#比较FTP主、被动模式的不同，并回答为什么被动模式适合公网服务" class="headerlink" title="比较FTP主、被动模式的不同，并回答为什么被动模式适合公网服务"></a>比较FTP主、被动模式的不同，并回答为什么被动模式适合公网服务</h3><blockquote><ol><li>主动模式</li></ol><p>在主动模式中，FTP客户端主动向FTP服务器的端口21发起连接请求，随后FTP服务器会在其本地随机选择一个端口，将该端口号发送给FTP客户端。FTP客户端收到FTP服务器发送的数据端口号后，会主动发起一个数据连接请求，以与FTP服务器进行数据传输。</p><p>​2.被动模式</p><p>在被动模式中，FTP客户端向FTP服务器的端口21发起连接请求后，FTP服务器会随机选择一个端口（通常在1024~65535之间），将该端口号发送给FTP客户端。FTP客户端接收到FTP服务器发送的数据端口号后，会主动发起一个连接请求，以与FTP服务器进行数据传输。</p><p>总的来说，主动模式是FTP服务器主动向FTP客户端发起数据连接请求，而被动模式是FTP客户端主动向FTP服务器发起数据连接请求。</p><p>被动模式更适合在公网服务中使用，因为公网服务中的FTP服务器位于防火墙后，无法直接从外部访问其数据端口。被动模式允许FTP服务器在任何端口上打开数据连接，从而避免了因端口限制导致的连接问题。</p></blockquote><h3 id="如何对SMTP服务器进行渗透"><a href="#如何对SMTP服务器进行渗透" class="headerlink" title="如何对SMTP服务器进行渗透?"></a>如何对SMTP服务器进行渗透?</h3><blockquote><ol><li>收集信息：您需要了解SMTP服务器的IP地址、端口、SMTP协议的版本等信息。可以使用Nmap或其他端口扫描工具来扫描SMTP服务器。</li><li>枚举：使用工具进行用户枚举，例如使用smtp-user-enum、Metasploit等工具来查找存在的用户列表。</li><li>验证：尝试使用用户名和密码进行登录验证。使用SMTP扫描工具，例如smtp-user-enum，对SMTP服务器进行枚举，然后使用基于字典的攻击工具，例如Hydra和Medusa等，尝试使用常见的用户名和密码进行登录验证。</li><li>暴力破解：如果枚举和验证失败，则可以使用暴力破解攻击进行密码破解。使用工具，例如Hydra、Medusa等，使用字典或暴力破解攻击进行密码破解。</li><li>利用漏洞：如果SMTP服务器存在漏洞，则可以利用该漏洞进行攻击。您可以使用漏洞扫描工具，例如Nessus、OpenVAS等，来查找SMTP服务器的漏洞，并尝试使用相应的漏洞利用工具进行攻击。</li><li>后门：如果您已经成功获取了访问SMTP服务器的权限，则可以尝试在SMTP服务器上安装后门，以便以后随时访问SMTP服务器。</li></ol></blockquote><h3 id="如何对POP3-服务器进行渗透"><a href="#如何对POP3-服务器进行渗透" class="headerlink" title="如何对POP3 服务器进行渗透?"></a>如何对POP3 服务器进行渗透?</h3><blockquote><p>POP3和SMTP是两个不同的协议，POP3主要用于接收邮件，SMTP主要用于发送邮件。因此，在进行渗透测试时，需要采用不同的方法和工具。</p><p>对于POP3服务器，攻击者可以使用类似于对其他服务进行渗透测试的方法。一些常见的攻击方式包括：</p><ol><li>用户名&#x2F;密码枚举：使用字典攻击、暴力破解等方式尝试猜测用户名和密码。</li><li>漏洞利用：搜索和利用POP3服务器的漏洞，例如缓冲区溢出、拒绝服务攻击等。</li><li>中间人攻击：攻击者可以在客户端和POP3服务器之间插入自己的服务器，然后拦截和篡改邮件。</li></ol><p>对于SMTP服务器，攻击者可以使用以下方法：</p><ol><li>邮件欺骗：使用欺骗的SMTP服务器发送欺骗邮件，例如伪造发件人地址、伪造收件人地址、伪造邮件内容等。</li><li>暴力破解：类似于POP3服务器的攻击方法，使用字典攻击、暴力破解等方式尝试猜测用户名和密码。</li><li>漏洞利用：搜索和利用SMTP服务器的漏洞，例如缓冲区溢出、拒绝服务攻击等。</li><li>中间人攻击：攻击者可以在客户端和SMTP服务器之间插入自己的服务器，然后拦截和篡改邮件。</li></ol></blockquote><h3 id="DNS渗透的方法如何"><a href="#DNS渗透的方法如何" class="headerlink" title="DNS渗透的方法如何?"></a>DNS渗透的方法如何?</h3><blockquote><ol><li>DNS欺骗：攻击者可以通过DNS欺骗来实现中间人攻击或劫持，向用户提供错误的DNS解析结果或将用户重定向到恶意网站。常见的DNS欺骗技术包括DNS投毒、DNS重绑定等。</li><li>DNS缓存投毒：攻击者可以利用DNS缓存中的漏洞，向DNS服务器发送虚假的DNS响应，将恶意的DNS记录插入到缓存中，导致用户访问的是恶意的网站或服务器。</li><li>DNS拒绝服务（DNS DoS）：攻击者可以向DNS服务器发送大量的DNS请求或欺骗请求，占用服务器资源或使服务器崩溃，导致无法正常解析DNS查询。</li><li>DNS隧道：攻击者可以利用DNS协议的报文格式来传输恶意的数据或通信，例如通过DNS隧道将远程控制命令传递到目标系统中。</li></ol></blockquote><h3 id="简述数据库服务器端的渗透方法"><a href="#简述数据库服务器端的渗透方法" class="headerlink" title="简述数据库服务器端的渗透方法"></a>简述数据库服务器端的渗透方法</h3><blockquote><p>黑客攻击数据库的常用方法有拖库、洗库、撞库。</p><p>​拖库是指黑客入侵有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，也经常被称作“脱库”。</p><p>​在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价镇的用户数据变现，通常也被称作“洗库”。</p><p>​最后黑客将得到的数据在其他网站上进行尝试录，称为“撞库”，因为很多用户喜欢使用相同的用户名和密码，“撞库”也可以使黑客获颇丰。</p><p>1远程下载数据库文件</p><p>2利用Web应用漏洞</p><p>3、数据库解密</p></blockquote><h3 id="为什么要对安全机制进行反制"><a href="#为什么要对安全机制进行反制" class="headerlink" title="为什么要对安全机制进行反制?"></a>为什么要对安全机制进行反制?</h3><blockquote><p>可以采取的措施主要包括防火墙、入侵检测等技术设备。渗透测试必须进行有效规避，才能对服务器端展开渗透。</p></blockquote><h1 id="第六章：客户端渗透测试"><a href="#第六章：客户端渗透测试" class="headerlink" title="第六章：客户端渗透测试"></a>第六章：客户端渗透测试</h1><h3 id="客户器端渗透的提出原因是什么"><a href="#客户器端渗透的提出原因是什么" class="headerlink" title="客户器端渗透的提出原因是什么?"></a>客户器端渗透的提出原因是什么?</h3><blockquote><ol><li>客户端应用程序和用户终端设备普及度高：大多数人都使用电脑、手机等客户端设备进行工作、生活和娱乐，而这些设备上安装的应用程序往往是网络攻击的主要目标。</li><li>客户端设备存在漏洞：很多客户端设备存在漏洞，黑客可以通过利用这些漏洞进行攻击，比如利用浏览器漏洞进行钓鱼攻击、利用PDF阅读器漏洞进行远程控制等。</li><li>客户端设备经常连接到不受信任的网络：很多用户经常在咖啡厅、图书馆等公共场所连接到不受信任的Wi-Fi网络，这些网络容易受到中间人攻击和DNS劫持等威胁，导致用户的数据和隐私泄露。</li></ol><p>对客户端应用程序和用户终端设备进行渗透测试可以发现并修复潜在的安全漏洞，保护用户的数据和隐私安全。</p></blockquote><h3 id="什么是内存对抗"><a href="#什么是内存对抗" class="headerlink" title="什么是内存对抗?"></a>什么是内存对抗?</h3><blockquote><p>​内存对抗（Memory Forensics）是一种计算机取证技术，主要用于研究和分析恶意软件和攻击行为，从<strong>计算机内存中提取并分析数据，以了解攻击者对受害者计算机的操作行为、攻击路径和受害者系统的状态</strong>。内存对抗技术可以用于检测、定位和分析各种恶意行为，包括病毒、木马、后门、rootkit、网络钓鱼等。它可以帮助安全人员更好地了解攻击者对受害者计算机的控制情况，提供更全面、深入的信息，以便更好地处理安全事件。</p></blockquote><h3 id="解释堆喷射的原理。"><a href="#解释堆喷射的原理。" class="headerlink" title="解释堆喷射的原理。"></a>解释堆喷射的原理。</h3><blockquote><p>​堆喷射（Heap spraying）是一种利用浏览器或操作系统漏洞进行攻击的技术。其原理是利用JavaScript等脚本语言来在内存中创建大量相同的特定数据，从而将某一段特定的内存空间（通常是堆内存）填满，然后将恶意代码插入到已经预先填充好的内存块中，等待受害者访问时被执行。</p><p>​堆喷射的攻击原理是，利用漏洞将堆内存中的指针覆盖成攻击者控制的地址，使得攻击者可以将恶意代码注入到指定的内存地址中。因为现代操作系统和浏览器都会对栈进行一定的保护，但对堆的保护相对较弱，因此堆喷射已经成为了一种广泛应用的攻击手段。</p></blockquote><h3 id="什么是空指令与滑行区"><a href="#什么是空指令与滑行区" class="headerlink" title="什么是空指令与滑行区?"></a>什么是空指令与滑行区?</h3><blockquote><p>​空指令是指在程序中没有实际作用的指令。通常是由编译器或者开发者为了调试程序而添加的，实际上并不对程序逻辑产生影响。空指令通常被用作占位符，因为在指令中占用了一个地址，可以用来填充代码中的空洞，以达到指令地址的对齐。</p><p>​滑行区是指在堆喷射攻击中，为了在特定的地址空间中寻找合适的空间来存储攻击代码，需要在堆中创建足够的空间。滑行区通常是指在堆中创建的一段用于存储攻击代码的空间，这个空间通常与目标应用程序的堆空间不重叠，以确保攻击代码的正常运行。在堆喷射攻击中，攻击者通常通过滑行区来寻找目标空间，并将攻击代码注入到目标空间中，以达到控制程序流程的目的。</p></blockquote><h3 id="什么是栈溢出-什么是堆溢出"><a href="#什么是栈溢出-什么是堆溢出" class="headerlink" title="什么是栈溢出?什么是堆溢出?"></a>什么是栈溢出?什么是堆溢出?</h3><blockquote><p>​栈溢出指的是利用程序在函数调用时使用的栈空间出现错误，导致向栈中写入了超出预留空间的数据，覆盖了栈上的其他重要数据，例如函数返回地址和函数参数等，从而导致程序崩溃或执行了攻击者预设的恶意代码。</p><p>​堆溢出则是指程序在使用堆内存时出现错误，向堆中写入了超出预留空间的数据，覆盖了堆上的其他重要数据，例如分配堆内存时的管理结构体等，从而导致程序崩溃或执行了攻击者预设的恶意代码。</p></blockquote><h3 id="解释浏览器为什么成为客户端攻击的重点。"><a href="#解释浏览器为什么成为客户端攻击的重点。" class="headerlink" title="解释浏览器为什么成为客户端攻击的重点。"></a>解释浏览器为什么成为客户端攻击的重点。</h3><blockquote><p>​浏览器是现代计算机中最广泛使用的应用程序之一，用户使用浏览器访问互联网上的各种服务和资源，包括网站、应用程序、视频、音频和文本等。浏览器的广泛使用和开放的特性使得它成为攻击者攻击用户的主要目标。</p><p>浏览器也存在一些安全缺陷，其中有，沙箱逃逸、SOP绕过、Cookie盗取等。</p><p>​1.沙箱逃逸：沙箱是将不可信代码限制在一个低权限范围内运行的环境。利用某种方式绕过沙箱获取访问敏感数据的权限，就可以达到沙箱逃逸的目的。</p><p>​2.SOP绕过：同源策略，是浏览器中最基本也是最核心的安全机制，负责页面之间的访问控制。最大的缺陷目前该策略是一个规范，并不是强制要求。</p><p>​3.Cookie盗取：Cookie存储的数据有时候非常重要。</p><p>对于浏览器的攻击，主要分为两大类：</p><p>​1.对浏览器本身的程序进行攻击。</p><p>​2.对浏览器内嵌第三方扩展或者是插件进行渗透攻击。</p><p>​此外，由于浏览器通常在互联网上运行，攻击者可以通过发送恶意代码或链接，通过互联网攻击数千甚至数百万的用户，这也使浏览器成为客户端攻击的主要目标之一。</p></blockquote><h3 id="简述浏览器攻击、扩展攻击和插件攻击的方法"><a href="#简述浏览器攻击、扩展攻击和插件攻击的方法" class="headerlink" title="简述浏览器攻击、扩展攻击和插件攻击的方法"></a>简述浏览器攻击、扩展攻击和插件攻击的方法</h3><blockquote><p>浏览器扩展（Extensions）和浏览器插件（Plugins）都是浏览器的功能增强组件，但两者有以下不同：</p><ol><li>功能：</li></ol><p>  浏览器扩展主要是用来<strong>增强浏览器功能</strong>，例如广告拦截、翻译、截屏等；</p><p>  浏览器插件主要是用来在<strong>浏览器中运行特定的应用程序</strong>，例如Adobe Flash、Java等插件。</p><ol start="2"><li><p>安全性：由于浏览器插件是以系统管理员权限运行的，因此安全性存在一定的风险；而浏览器扩展一般以普通用户权限运行，相对来说更加安全。</p></li><li><p>架构：浏览器插件的开发需要使用特定的API和SDK，如Adobe Flash、Java等；而浏览器扩展的开发则可以使用标准的Web技术，如HTML、CSS和JavaScript等。</p></li></ol><p>总之，两者的区别在于浏览器扩展更多地关注于浏览器的功能增强和用户体验，而浏览器插件更多地关注于提供特定的应用程序功能。</p><p><strong>浏览器攻击方法：</strong></p><ol><li><p>XSS攻击（跨站脚本攻击）：攻击者向网站中注入恶意脚本，当其他用户访问该网站时，恶意脚本会被执行，导致用户信息泄露或网站受到破坏。</p></li><li><p>CSRF攻击（跨站请求伪造攻击）：攻击者利用受害者已登录的身份，在受害者不知情的情况下发送恶意请求，以达到攻击目的。</p></li><li><p>Clickjacking攻击：攻击者将一个网站隐藏在一个透明的网页上，使得用户误以为是点击了某个按钮，但实际上点击的是隐藏网站的按钮，以此达到攻击目的。</p></li><li><p>钓鱼攻击：攻击者伪造一个网站或电子邮件，诱骗用户提供敏感信息，如用户名和密码。</p></li></ol><p><strong>扩展攻击方法：</strong></p><p>扩展（Extension）是浏览器提供的一种功能，通过添加扩展可以增强浏览器的功能。扩展攻击方法一般是通过恶意扩展来实现，如：</p><ol><li><p>假冒扩展：攻击者伪造一个扩展，通过类似于钓鱼攻击的方式诱骗用户下载和安装该扩展，以达到窃取用户信息或攻击网站的目的。</p></li><li><p>代码注入：攻击者将恶意代码注入到合法扩展中，当用户安装并运行该扩展时，恶意代码会被执行，以达到攻击目的。</p></li></ol><p><strong>插件攻击方法：</strong></p><p>插件（Plugin）是浏览器提供的一种插件式的扩展机制，插件攻击方法与扩展攻击类似，主要是通过恶意插件实现，如：</p><ol><li>假冒插件：攻击者伪造一个插件，通过类似于钓鱼攻击的方式诱骗用户下载和安装该插件，以达到窃取用户信息或攻击网站的目的。</li><li>代码注入：攻击者将恶意代码注入到合法插件中，当用户安装并运行该插件时，恶意代码会被执行，以达到攻击目的。</li></ol></blockquote><h3 id="简述实现HTTPs-降级为-HTTP-的方法。"><a href="#简述实现HTTPs-降级为-HTTP-的方法。" class="headerlink" title="简述实现HTTPs 降级为 HTTP 的方法。"></a>简述实现HTTPs 降级为 HTTP 的方法。</h3><blockquote><p>浏览器指纹获取，识别浏览器的平台和版本，识别唯一地标不同的浏览器，确定浏览器版本主要查看http请求首部，dom属性以及浏览器的独有特征，在侦查过程中，可能会遇到https的保护无法实施网络嗅探窃听。</p><p>阻止用户访问https站点，或者是通过其他方式吧用户转到网站的http板上。</p><p>一，截取网络数据并重写请求，二是在浏览器内部重写链接。</p><ol><li>SSLStrip</li></ol><p>SSLStrip攻击利用的是Web应用程序未正确配置的漏洞，可以将原本的HTTPs链接重定向到HTTP链接，使得HTTPs流量被劫持到HTTP链接上，并将传输的敏感信息暴露给攻击者。</p><ol><li>HTTPS连接劫持</li></ol><p>HTTPS连接劫持攻击是利用攻击者控制的代理服务器来中间人攻击通信的另一种方式。攻击者通过伪造CA证书或通过自签名证书来欺骗客户端与代理服务器建立连接，然后将请求转发给服务器，获取服务器响应后再将响应转发给客户端，从而达到窃取或篡改通信内容的目的。</p><p>为了避免HTTPs降级攻击，建议采用以下方法：</p><ol><li>在应用程序的代码中进行严格的输入验证和输出编码，以避免注入和跨站点脚本等攻击。</li><li>使用HSTS（HTTP Strict Transport Security）协议，要求客户端始终使用HTTPs连接，以防止HTTPs被降级为HTTP。</li><li>采用HTTP Public Key Pinning（HPKP）技术，指定可信任的证书机构，避免中间人攻击。</li><li>避免在Web应用程序中使用混合内容（HTTP和HTTPs混合），以避免攻击者能够通过劫持HTTP链接来篡改HTTPs链接。</li></ol></blockquote><h3 id="简述文件格式漏洞利用原理。"><a href="#简述文件格式漏洞利用原理。" class="headerlink" title="简述文件格式漏洞利用原理。"></a>简述文件格式漏洞利用原理。</h3><blockquote><p>​攻击者一般会恶意构造符合正常格式的畸形文件进行漏洞利用，攻击者构造恶意文件并将其发送给受害者，当受害者尝试打开或解析这个文件时，恶意代码就会被执行，从而导致攻击成功。</p></blockquote><h3 id="简述文件格式漏洞的挖掘方法。"><a href="#简述文件格式漏洞的挖掘方法。" class="headerlink" title="简述文件格式漏洞的挖掘方法。"></a>简述文件格式漏洞的挖掘方法。</h3><blockquote><p>文件格式漏洞指的是利用文件格式解析器（如图像解码器、PDF阅读器等）的漏洞来进行攻击的一类漏洞。挖掘文件格式漏洞的方法一般包括以下几个步骤：</p><ol><li>寻找目标：选择常用的文件格式，如图片、视频、音频、文档等，并寻找常用的解析器。可以通过搜索常见的文件格式解析器的源代码、官方文档、博客等途径来寻找目标。</li><li>学习文件格式：深入学习目标文件格式的结构、特征、解析方式等，理解其内部原理。可以通过查看文档、相关论文、源代码等途径来学习。</li><li>构造恶意文件：利用对文件格式的深入理解，构造出一个带有漏洞的文件，并在其中嵌入恶意代码。</li><li>寻找漏洞：使用工具或手工对构造的恶意文件进行解析，寻找文件格式解析器中的漏洞。</li><li>利用漏洞：在找到漏洞后，可以利用它来进行攻击，如实现代码执行、绕过安全机制、读取敏感信息等。</li><li>提交漏洞报告：将发现的漏洞报告给厂商或开发者，并与其进行合作修复漏洞。</li></ol><p>需要注意的是，挖掘文件格式漏洞需要对目标文件格式有深入的理解，同时需要具备较强的代码审计能力和漏洞利用能力。在挖掘过程中，需要严格遵守法律法规，不得进行非法攻击和窃取敏感信息等行为。</p></blockquote><h3 id="什么是-HID-如何利用-HID进行USB-设备渗透"><a href="#什么是-HID-如何利用-HID进行USB-设备渗透" class="headerlink" title="什么是 HID?如何利用 HID进行USB 设备渗透?"></a>什么是 HID?如何利用 HID进行USB 设备渗透?</h3><blockquote><p>​HID（Human Interface Device）是指人机接口设备，如键盘、鼠标、游戏手柄等。由于HID设备在操作系统上通常被当作输入设备来对待，因此可以利用HID设备进行USB设备渗透，将恶意代码注入到目标计算机上，从而实现攻击目的。</p><p>​一种常见的利用HID进行USB设备渗透的方法是利用Rubber Ducky这样的工具。Rubber Ducky是一种外形类似USB闪存盘的HID设备，可以被当作键盘使用。攻击者将恶意脚本预先编写好并存储在Rubber Ducky中，然后将Rubber Ducky插入目标计算机，Rubber Ducky就会自动模拟键盘输入，执行恶意脚本。</p><p>​例如，攻击者可以编写一个恶意脚本，用于窃取目标计算机上的敏感信息，并将该脚本存储在Rubber Ducky中。在攻击时，攻击者将Rubber Ducky插入目标计算机，Rubber Ducky就会自动模拟键盘输入，将恶意脚本输入到目标计算机上。恶意脚本会执行一系列命令，从而窃取敏感信息并将其发送给攻击者控制的服务器。由于Rubber Ducky被当作键盘使用，因此其攻击效果与真实的键盘输入无异，能够绕过大多数安全软件的检测。</p></blockquote><h3 id="解释BadUSB渗透的思想。"><a href="#解释BadUSB渗透的思想。" class="headerlink" title="解释BadUSB渗透的思想。"></a>解释BadUSB渗透的思想。</h3><blockquote><p>​BadUSB渗透是一种利用USB设备固件漏洞的攻击方式，它的基本思想是通过修改USB设备的固件代码，使得USB设备在插入计算机时可以实现隐藏操作、破解计算机密码、安装恶意软件等一系列攻击行为。</p><p>​具体来说，BadUSB攻击者需要了解目标计算机的操作系统及USB设备的驱动程序等相关信息，针对目标设备的固件漏洞进行开发和定制，制作出恶意固件进行篡改，然后通过替换掉正常USB设备的固件或直接生产带有恶意固件的USB设备来进行攻击。</p></blockquote><h1 id="第七章：网络设备渗透测试"><a href="#第七章：网络设备渗透测试" class="headerlink" title="第七章：网络设备渗透测试"></a>第七章：网络设备渗透测试</h1><h3 id="简述网络分层。"><a href="#简述网络分层。" class="headerlink" title="简述网络分层。"></a>简述网络分层。</h3><blockquote><p>1.核心层</p><p>核心层是骨干网，提供高容错性，并尽量以最小的延迟处理大量流量。</p><p>2.分发层</p><p>分发层位于骨干网和终端用户LAN之间，是网络中实现控制功能的部分</p><p>3.访问层</p><p>访问层包括用户工作站、服务器、交换机以及它们之间连接的访问点</p></blockquote><h3 id="简述网络安全特征。"><a href="#简述网络安全特征。" class="headerlink" title="简述网络安全特征。"></a>简述网络安全特征。</h3><blockquote><p>对网络设备进行安全加固可以减少攻击者的攻击机会，如果设备本身存在安全上的脆弱性，往往会成为攻击目标，为了确保网络的安全运行，网络设备需要满足一定的安全特征。</p><p>1.路由器的安全特征</p><ol><li>访问控制：路由器应该具备对用户进行身份验证、对用户进行访问控制的功能，以确保只有授权用户可以访问路由器。</li><li>防火墙：<strong>路由器应该支持基本的防火墙功能，可以检测和阻止未经授权的数据包流经路由器。</strong></li><li>加密和认证：路由器应该支持加密和认证功能，以保护路由器管理通道和网络流量的机密性和完整性。</li><li>远程管理：<strong>路由器应该支持远程管理功能，但是需要采取适当的安全措施，如加密、访问控制和认证等，以防止未经授权的用户访问和操纵路由器。</strong></li><li>日志记录和警报：<strong>路由器应该支持日志记录和警报功能，以便管理员能够监视和分析路由器的活动，并对异常情况进行及时响应。</strong></li><li>固件更新：路由器应该支持固件更新功能，以及时修复安全漏洞和缺陷，提高路由器的安全性和可靠性。</li><li>审计和合规性：路由器应该支持审计和合规性功能，以便管理员能够监视和报告路由器的安全性和合规性水平，确保网络安全和合规性要求得到满足。</li></ol><p>2.交换机的安全特征</p><ol><li>VLAN：<strong>交换机支持虚拟局域网(VLAN)技术，将物理网络划分为逻辑网络，可以实现不同VLAN之间的隔离和通信。</strong></li><li>认证与授权：交换机提供用户认证和授权服务，可以对接入的用户进行身份验证和权限控制，避免未授权的用户访问网络。</li><li>MAC地址过滤：交换机可以根据MAC地址过滤数据包，只允许已授权的MAC地址通过交换机转发数据包。</li><li>端口安全：交换机提供端口安全功能，可以限制每个端口的MAC地址数量，避免通过端口连接多个未授权设备。</li><li>网络监测：交换机支持网络监测功能，可以实时监测网络流量和带宽使用情况，及时发现网络异常。</li><li>防攻击：交换机可以对一些常见的攻击进行防御，如ARP欺骗、MAC地址欺骗等攻击。</li><li>交换机管理安全：<strong>交换机的管理接口需要设置安全口令，限制管理权限，避免未授权用户通过管理接口修改交换机配置。</strong></li></ol></blockquote><h3 id="简述网络设备的入侵动机。"><a href="#简述网络设备的入侵动机。" class="headerlink" title="简述网络设备的入侵动机。"></a>简述网络设备的入侵动机。</h3><blockquote><p>恶意控制路由器或交换机比针对工作站或服务器实施的攻击更为严重，因为攻击者可以在网络中获得一个极佳的切入点。</p><p>1.路由器的入侵目的</p><p>​(1)完整地映射内部网络，包括被动方式，如ARP(地址解析协议)表、路由表、流量嗅探和主动方式如 Telner和SSH(Secure ShelD)转发针对该网络的端口扫描。</p><p>​(2) 将任意类型的流量从控制主机转发给被攻击网络中的主机。</p><p>​(3)嗅探并修改穿过路由器的所有或特定流量。将流量从被控制的路由器镜像到指主机、或者简单地将这些流量重新路由穿过被控主机。</p><p>​(4) 迫使通常不会流经某台路由器的流量穿过它</p><p>​(5)建立一条到达被黑的网络的加密后门通道。</p><p>​(6)从被控制的路由器或者通过它攻击其他网络</p><p>​(7)注入 VoIP(Voice over Intemet Protocol)打免费电话，更改呼叫转移(只针对 VOIP网关和网守。</p><p>2.交换机的入侵目的</p><p>获得交换机的控制权可以实现以下目的:<br>(1)以被动和主动方式映射内部网络。<br>(2)嗅探穿过所有或特定交换端口的网络流量。<br>(3)滥用802.1d和802.1g 协议探交换网络，并迫使通常不会流经该交换机的流量穿过<br>(4)旁路虚拟 LAN(VLAN隔离(“跳跃的VLAN”)，并禁用MAC地址过滤。<br>(5)截断连接着不受欢迎的主机，如入侵检测系统传感器和监控台以及系统管理员的作站的端口。<br>(6)通过Telnet 或 Secure Shell(SSH)访问其他网络设备。<br>(7)通过滥用数据连接层(锁定交换机之后禁用STP从而导致Layer2环路)引起各种难处理的连接问题。</p><p>概括起来，黑客接管路由器、交换机或其他网络设备的原因包括:</p><ul><li>利用网络管理员的疏忽(他们未保护、更新或监控自己的网络设备:</li><li>当设备被入侵时，难以执行取证和正确的事件响应;</li><li>很容易利用不同的路由器和路由器链跳跃隐藏踪迹:</li><li>实现逻辑挑战，即发现并利用目标平台上设备的操作系统的弱点。</li></ul></blockquote><h3 id="网络设备入侵的方法有哪些"><a href="#网络设备入侵的方法有哪些" class="headerlink" title="网络设备入侵的方法有哪些?"></a>网络设备入侵的方法有哪些?</h3><blockquote><p>对网络设备的入侵方法包括入侵设备和协议攻击两类。</p><p>1.入侵设备</p><p>​网络设备也是具有特定功能的主机，因此，第 5、6章讨论的主机入侵方式同样适用于网络设备的入侵。</p><p>​(1)在配备大量网络设备的复杂网络中，最早是以明文方式保存口令的，后来采用了各种加密手段，使得攻击者即使得到了配置文件或者截获到了加密后的口令，也无法获得实际口令，但是通过密码破译或利用管理缺陷依然可以尝试获得口令。<br>​(2)攻击者先列举整个网络，然后挑选并精确地列举出特定的目标，再依据目标的漏洞发起漏洞利用攻击，获得并保持超级用户级别的访问，通过或从被入侵的网络设备发起进一步的毁坏性攻击。</p><p>2.协议攻击</p><p>​路由协议攻击可分为多种，常见的有利用叛变路由器进行攻击、利用流氓路由器进行攻击、利用假冒路由器进行攻击等。</p><p>​(1)利用叛变路由器进行攻击:叛变路由器(subverted roufer)由攻击者接管，用于取对目标网络的进一步控制。</p><p>​(2)利用流氓路由器进行攻击:流氓路电器rogle router)是指由攻击者非法部署在网络上的路由器，如果路由更新时缺乏身份验证机制，或者身份验证机制已被破坏，则这种流氓路由器可参与网络的路由选择，并能根据攻击者的需要更改路由。流氓路由器可以是运行通用操作系统并安装有路由软件的机器，攻击者也可以用 NemesisSpoof或IRPAS等数据包制作工具向网络中注入非法路由更新数据。<br>​(3)利用假冒路由器进行攻击:假冒路由器(masquerading router)是指通过假冒合法路由器身份而获得路由信息的流氓路由器。这种攻击可用以突破访问控制列表的限制，并可能涉及源路由攻击。<br>​攻击者还可以通过利用<strong>处理路由数据时的漏洞来接管路由器</strong>，虽然这并不是真正的路由攻击，但也是一种需要认真考虑的威胁。<br>​任何路由攻击的最终结果都是导致网络上的流量重定向。要实现这个目的，攻击者可进行如下操作:</p><ul><li>更改路由的量度(通常改为一个表示所插入恶意路由优先级的数值):</li><li>更改所通告网络的网络掩码，需要记住的是，路由的网络掩码越长、越具体，其优先级就越高;</li><li>更改策略路由、路由重分布和管理距离(很少见):</li><li>删除指向所涉及路由器的路由或引发拒绝服务(DOS)</li><li>完成路由器的攻击之后，对于目标的渗透攻击将因具有数据包流向控制的能力而具有更加有利的条件。</li></ul></blockquote><h3 id="简述路由器的漏洞及利用方法。"><a href="#简述路由器的漏洞及利用方法。" class="headerlink" title="简述路由器的漏洞及利用方法。"></a>简述路由器的漏洞及利用方法。</h3><blockquote><p>​路由器的安全漏洞分为三个不同层次的漏洞:<strong>软件操作系统安全漏洞</strong>(包括缓冲区溢出漏洞和客户端漏洞)、<strong>运行协议漏洞</strong>(包括网络服务和路由协议漏洞)和<strong>配置管理漏洞</strong>。</p><p><strong>1.缓冲区溢出漏洞</strong></p><p>路由器处理对象主要是各种报文，这些报文使用堆存储，一般路由器很少在函数中使用局部变量，即很少使用栈存储变量，因此，<strong>路由器缓冲区溢出以堆溢出为主</strong>。路由器通常使用其特有的堆管理和保护机制对堆块进行管理和安全保护，但是，近年来随着对此安全机制研究的深入，堆管理和保护机制的安全脆弱性也逐渐暴露出来，出现了绕过堆保护机制的堆溢出攻击。</p><p><strong>2、客户端漏洞</strong></p><p>​路由器之间为了完成状态协商及数据传输等，有时必须使路由器访问其他网上服务，这样攻击者可以利用其客户端漏洞。尤其是提供一个可扩展平台，随着需求和技术的发展有更多新功能引入路由器，导致情况变得更加严重。</p><p><strong>3.网络服务漏洞</strong></p><p>​路由器可以作为网络服务器和客户端。IOs 网络服务包括 HTTP 服务器(用于配置和控)、HTTPS服务器、telnet 和 SSH 远程访问、FTP和TFTP 服务器等，过去，人们己经》现HTTP、FIP和TFTP 服务中的内存溃漏洞，开发了相应的 POC程序。</p><p><strong>4.路由协议漏洞</strong></p><p>​路由协议制定时，环境是相当安全的，并只用于学术研究。路由器为完成其路由功能需要提供一些基本协议，包括路由协议通信(OSPF、ISIS、BGP、RIP)，以及网络支持服3如DHCP中继和IPv6路由发现，增加了被攻击概率。</p><p><strong>5.配置管理漏洞</strong></p><p>​网络管理员对设备的错误或不当配置也可能产生受攻击的漏洞。如默认的口令密码弱口令，开启了存在隐患的网络服务，如SNMPv1&#x2F;v2，配置了默认的Community stringCDP协议等。攻击者通过字典攻击技术，通过远程访问方式(TELNET、FTP、SSH、HTTPIHTTPs等)猜测和暴力破解路由器的用户名和口令，或者利用其他手段获得配置文件通过对口令破解得到用户名与口令，从而获得路由器的控制权限，远程控制与管理路由器，危害整个网络的安全性。<br>​对于一些具有无线网络功能的路由器，无线安全漏洞也被引入到路由中。</p><p><strong>路由器渗透方法</strong></p><p><strong>1，远程溢出攻击</strong></p><p>​远程溢出攻击是最为常用的一种方式，也是最重要的一种方式。通过远程溢出，攻击者可以直接获取管理员 Shell，实现了控制路由器的可能性。在正常情况下，堆保护机制可以有效地检测出堆溢出错误，主动重新启动系统以避免对系统造成更大的破坏。因此，精心构造的堆溢出攻击数据包可能会超过堆保护机制，以达到破坏或控制系统的目的。利用堆溢出攻击，只能导致路由器重新启动或拒绝服务攻击(DoS)。</p><p><strong>2.数据重定向攻击技术</strong></p><p>​IP 报文首部的可选项中有“源站选路”，如果选择要求按源站选路，则服务器在收到信息后会返回信息给这个源站(报文通过路由来返回来记录经过的路由)。源路由功能指定数据包必须经过的一条路径，这一功能包括两种类型的源路由选择。</p><p>​攻击者C进行源路由欺骗，伪装成B的IP 地址，给服务器A发送了一个包此时A收到包后发现要返回信息，正常的话因为发送栏地址是 B，应该返回给 B，但由于源路由信息记录了来时的路线，反推回去就把应该给 B 的信息给了 C，而A 没有意识到问题，B对此一无所知，C拿到了 B 才能拿到的信息。这样，通过IP 源路由欺骗，攻击者可以将敏喀信息重新定向到攻击者主机，实现对重要数据的截获分析</p><p>对路由器还可以实施ICMP 重定向攻击、RIP 重定向攻击、OSPF 重定向攻击。</p><p><strong>3.口令攻击</strong></p><p>​口令攻击尝试猜解路由器口令，继而控制路由器。通过远程访问方式(TELNET、FTPSSH、HTTP&#x2F;HTTPs 等)猜测和暴力破解路由器的用户名和口令，或者利用其他手段获得配置文件，通过对口令破解得到用户名与口令。由于对未知团体名的SNMP 请求不会产生任何响应，因此，对 SNMP 的字典攻击可以使用以下两种手段:一种是对路由器实施临时的UDP端口扫描:另一种是利用多个已知的团体名进行尝试扫描。也可采用口令暴力破解的方法实施口令攻击。</p><p><strong>4.DOS攻击</strong></p><p>​DOS攻击利用路由器的TCP连接漏洞发起该漏洞攻击者通过操纵一个TCP连接的状态，可迫使 TCP 连接保持在一个可能无限期存在的状态。如果有足够的 TCP 连接都被迫进入长期存在或不确定的状态下，受到攻击的系统上的资源可能会被消耗掉，进而达到攻击的目的。要实施 DOS 攻击，攻击者必须能够完成一个有漏洞的系统的TCP三次挥丰。</p><p>​针对路由器攻击技术和相应的安全防护技术方面的研究，对于网络的安全渗透性测试,积极采取防范措施对提高路由器的抗攻击性、健壮性具有重要意义。</p></blockquote><h3 id="简述交换机的漏洞及利用方法。"><a href="#简述交换机的漏洞及利用方法。" class="headerlink" title="简述交换机的漏洞及利用方法。"></a>简述交换机的漏洞及利用方法。</h3><blockquote><p>​网络交换机作为网络环境中重要的转发设备，在局域网络中占有极其重要的地位，因此成为攻击者入侵和病毒肆虐的重点对象。</p><p>MAC 地址、DHCP 应用、ARP 请求和SPANNINGTREE 协议都处在数据链路层，极易遭受欺骗攻击。</p><p>​对于交换机可以依次尝试中继威胁攻击、VTP 攻击、地址解析协议攻击、STP 攻击以及非法接入。</p><p><strong>1.中继威胁攻击</strong></p><p>​正常情况下，网络交换机上划分的 VLAN 具有隔离广播、在一定程度上保护网络安全的作用。在没有路由的情况下，一个 VLAN 上的计算机无法与另一个 VLAN 上的用户进行通信。<strong>VLAN中继威胁攻击充分利用了动态中继协议(Dynamic Trunk Protocol，DTP)攻者利用 DTP 冒充由网络交换机发送的正常报文，进而攻击此台计算机所连接的交换机。</strong>因此，如果网络交换机启动了中继功能，就会导致异常报文发送到被攻击的机器上,从而在不同的VLAN 中进行网络攻击。</p><p><strong>2.VTP攻击</strong></p><p>​VLAN中继协议(VLANTrunk Protocol，VTP)是一种管理协议，可以减少交换环境中的配置数量。就VTP而言，网络交换机可以是 VTP 服务器、VTP 客户端或VTP交换机。用户每次对工作于 VTP 服务器模式下的交换机进行配置改动时，无论是添加、修改还是移除VLAN，VTP配置版本号都会增加1，VTP 客户端看到配置版本号大于目前的版本号后就会与VTP服务器进行同步。于是,当攻击者发送VTP 消息到配置版本号高于当前的VTP服务器时，就会导致所有网络交换机都与恶意攻击者的计算机进行同步，从而把所有非默认的 VLAN从VLAN 数据库中移除出去，这样就可以进入其他每个用户所在的同一个VLAN 上.</p><p><strong>3.地址解析协议攻击</strong></p><p>​在网络传输中，往往不能仅仅通过IP 地址进行网络传输，因为目前大规模的网络泛滥IP地址已经远远不能够满足当前的需要，IP 已经完全没有办法定位到被使用的是哪一台机器。另外，由于目前大规模路由器、交换机的使用，虚拟IP 逐渐增多，为了进行通信只能依赖MAC 地址。地址解析协议(Address Resolution Protocol，ARP)就是首先将目标机器的IP 地址解析成为唯一的MAC 地址，然后ARP 会自动搜索IP 到MAC 的解析，并通过广播的形式进行请求的发送，这样所有的主机就都可以收到报文信息。于是，攻击者就可利用ARP 获取发送报文的信息流，采用欺骗方式连接上目标主机并进行通信，使目标主机出现大量的异常报文，导致网络交换机的瘫痪。</p><p><strong>4.STP攻击</strong></p><p>​生成树协议(Spanning Tree Protocol，STP)可以通过阻寨元余线路，消除交换环境中出现的回路。如果网络中有回路，网络广播就会在网络中反复发送，进而形成广播风暴导致整个网络崩溃。使用 STP 的所有网络交换机都可通过网桥协议数据单元(Bridge ProtocoData Unit，BPDU)来共享信息。网络交换机发送并接收这些 BPDU，以确定哪个网络交换机拥有最低的网桥 ID，这个拥有最低网桥 ID 的网络交换机就称为根网桥。由其他每个网络交换机确定返回根网桥的最佳路线(端口速度、可靠性最高的路径)，而把其他路径的端口设为阻塞模式。</p><p>​STP 威胁攻击就是恶意攻击者首先连接到一个网络交换机，然后设计一组 BPDU并发送给最低网桥ID，就可欺骗网络交换机导致 STP 重新收敛。由于 STP协议收敛速度较慢，在一定时间内会产生回路，容易导致网络崩溃。对于内网交换机，还可尝试将未经过授权的计算机接入到网络交换机端口，尝试进入到局域网内部，来测试内部网络存在的安全隐患。</p></blockquote><h3 id="简述防火墙的漏洞及利用方法。"><a href="#简述防火墙的漏洞及利用方法。" class="headerlink" title="简述防火墙的漏洞及利用方法。"></a>简述防火墙的漏洞及利用方法。</h3><blockquote><p>防火墙本身是安全设备，除了被攻击者规避之外(见 5.6.1小节)，同时自身也可能遭受到攻击。</p><p><strong>攻击面</strong></p><p>防火墙遭受攻击是因为存在以下缺陷和不足:</p><p>​(1)传统防火墙是一种被动防卫技术，它假设了网络安全的边界和服务，对内部的非法访问往往难以实施有效的控制。</p><p>​(2)防火墙无法防范通过防火墙以外的其他途径的攻击，这就对网络安全造成了极大的威胁。</p><p>​(3)防火墙无法彻底防范计算机病毒。尽管现在有些新的防火墙产品能够在数据流过时检测病毒，但聪明的攻击者仍然可以用很多方法把病毒程序包装起来以穿过防火墙。</p><p>​(4)防火墙不能防止内部网合法用户的不法行为和疏忽大意:无法禁止内部合法用户将敏感数据拷贝到软盘上，也不能防止掉电、网络断开等物理故障。</p><p>​(5)防火墙本身的设置也可能成为安全隐患。随着防火墙系统功能的日益强大和复杂，它对设置和使用者的要求也越来越高，因此必须进行正确、合理的设置，否则防火墙形同虚设。</p><p>防火墙的安全漏洞还应包括所承载的操作系统本身的漏洞。</p><p>防火墙渗透方法可以分为三类。</p><ul><li><p>防火墙探测渗透:探测在目标网络上安装的是何种防火墙系统，并且找出此防火墙系统允许哪些服务。</p></li><li><p>防火墙欺骗渗透:采取地址欺骗、TCP 序号攻击等手法绕过认证机制，破坏防火和内部网络。</p></li><li><p>防火墙主机渗透:寻找、利用防火墙系统实现和设计上的安洞，从而有舒对地发动攻击。</p></li></ul><p>渗透测试可以依次采用以上三类方法实施，针对不同的防火墙类型具体还有以下诊方法。</p><p>1.数据包伪装</p><p>​        对于包过滤型防火墙，可以利用实时数据包伪装渗透。对攻击数据包进行修饰伪装，修改数据包的源地址、目的地址和端口，模仿一些非法的数据包骗过防火墙的检测。</p><p>2.非授权访问</p><p>​对于代理型防火墙，可以采用非授权访问渗透。代理防火墙运行在应用层，其攻击的方法很多。可以利用安全漏洞获得 WinGate 的授权 Web 和 Socks 的访问，从而伪装成 WinGate 主机的身份对攻击目标发动攻击。</p><p>3，利用协议隧道</p><p>​对于监测型防火墙，可以利用协议隧道进行渗透。协议隧道是指将一种协议的数据封装进另一种协议的数据包中。隧道是一项通用的技，可以携带某种协议通过异质的网络。协议隧道的渗透思想类似VPN 的实现原理，攻击者将一些恶意的攻击数据包隐藏在些协议分组的头部,从而穿透防火墙系统对内部网络进行攻击</p><p>4、利用信任服务</p><p>​对于监测型防火瑞，还可以利用信任服务进行渗透。为了提高通过效率，并不是每一种服务都需要进行过滤。防火墙会开辟一些信任通道提高通过效率，例如80端口或 FTP 服务等。可以利用FTP-pasy 绕过防火墙认证的攻击FTP-pusv 攻击是针对防火墙实施入侵的重要手段之一，目前很多防火墙不能过滤这种攻击手段。</p><p>5.反弹木马攻击</p><p>​对于防火墙的攻击，还可以使用反弹木马的通用方法。<br>反弹木马利用防火墙对80端口的信任实现突破，攻击者设在内部网络的反弹木马定时地连接外部攻击者控制的主机，由于连接是从内郎发起的，防火墙都认为其是一个合法的连接，因此基本上防火墙的盲区。防火墙不能区分木马的连接和合法的连接。</p><p>6，旁路攻击</p><p>​旁路攻击(bypass)就是在内网与外部之间开辟一条新的数据通路。对于一些设计有缺陷或安全管理薄弱的内网，可能存在通过无线&#x2F;有线网络非法外联的情况(如图 7-3 所示)，通过发现这样的通路可以绕开防火墙</p><p>7.DDOS 攻击<br>    通过对防火墙的 DDOS 攻击阻塞防火墙的过滤。简单的防火墙不能跟踪 TCP 的状态，很容易受到拒绝服务攻击，一旦防火墙受到 DOS攻击，它可能会忙于处理而忽略了自己的过滤功能。</p></blockquote><h1 id="第八章：后渗透测试"><a href="#第八章：后渗透测试" class="headerlink" title="第八章：后渗透测试"></a>第八章：后渗透测试</h1><h3 id="什么是后渗透测试，它的目的是什么"><a href="#什么是后渗透测试，它的目的是什么" class="headerlink" title="什么是后渗透测试，它的目的是什么?"></a>什么是后渗透测试，它的目的是什么?</h3><blockquote><p>​后渗透测试攻击是相对于前期渗透测试而言的测试工作，具体是指渗透测试漏洞利用成功后的后续渗透行为，即获得系统权限后为了进一步深入测试目标的功能、最具价值资产而开展的高级渗透测试活动。</p><p>后渗透测试的目的可以概况为提供能够对客户组织造成最重要业务影响的攻击途径的验证和演示，并以此评估黑客攻击可能造成的危害和等级。</p></blockquote><h3 id="对“权利”与“权限”进行区别比较"><a href="#对“权利”与“权限”进行区别比较" class="headerlink" title="对“权利”与“权限”进行区别比较"></a>对“权利”与“权限”进行区别比较</h3><blockquote><p>权限源自计算机安全访问，是针对资源而言，，权利主要是针对用户而言，包含登陆权利，决定用户如何登陆计算机。特权则是一些列系统权力的总称。</p></blockquote><h3 id="简述后渗透测试的主要内容。"><a href="#简述后渗透测试的主要内容。" class="headerlink" title="简述后渗透测试的主要内容。"></a>简述后渗透测试的主要内容。</h3><blockquote><p><strong>权限维持和内网渗透</strong></p><p>权限维持是指攻击者在获取系统控制权之后，利用各种手段维持自己的权限，以确保自己能够持续地控制目标系统。权限维持的方式包括但不限于以下几种：</p><ol><li>注入恶意代码：攻击者可以将恶意代码注入到系统的某些组件中，以便在系统启动时自动运行，并维持攻击者的权限。</li><li>提权攻击：攻击者可以通过漏洞利用或其他手段提升自己的权限，以便更好地控制系统。</li><li>建立后门：攻击者可以在系统中留下后门，以便在以后的时间里能够再次进入系统。</li></ol><p>内网渗透是指攻击者在获取对某个系统的控制权之后，进一步深入目标网络，以获取更多的敏感信息或攻击机会。内网渗透的方式包括但不限于以下几种：</p><ol><li>横向渗透：攻击者可以利用已经获取的系统控制权，在目标网络中寻找其他易受攻击的系统，并进一步攻击这些系统。</li><li>密码攻击：攻击者可以通过暴力破解等手段获取其他系统的密码，从而进一步渗透网络。</li><li>社交工程：攻击者可以利用社交工程手段获取其他系统的访问权限，以便进一步控制网络。</li></ol></blockquote><h3 id="什么是-APT攻击-简述APT-攻击的检测难度"><a href="#什么是-APT攻击-简述APT-攻击的检测难度" class="headerlink" title="什么是 APT攻击?简述APT 攻击的检测难度"></a>什么是 APT攻击?简述APT 攻击的检测难度</h3><blockquote><p>APT攻击及高级可持续威胁攻击也称为定向威胁攻击，指某组织对特定对象展开的持续有效的攻击活动。</p><p>1.先进的攻击方法，攻击者为摄影防御者的入侵检测能力，变得攻击不确定</p><p>2.持续性攻击与隐藏，通常进入系统后采取隐藏策略进入休眠状态，待时机成熟后，才利用间隙与外界服务器交流。</p><p>3.长期驻留目标系统并保持系统的访问权限，有自启与痕迹自毁功能</p></blockquote><h3 id="简述网络攻击杀伤链与钻石模型。"><a href="#简述网络攻击杀伤链与钻石模型。" class="headerlink" title="简述网络攻击杀伤链与钻石模型。"></a>简述网络攻击杀伤链与钻石模型。</h3><blockquote><p><strong>网络攻击杀伤链</strong>（Cyber Kill Chain）是由美国网络安全公司Lockheed Martin提出的模型，用于描述网络攻击的不同阶段，包括情报收集、攻击准备、攻击执行、内部渗透、数据挖掘和窃取等环节。该模型提供了一个分析网络攻击的框架，可以帮助安全专家在不同阶段进行预防和应对。</p><p>网络攻击杀伤链包括以下7个阶段：</p><ol><li>侦察（Reconnaissance）：攻击者在这个阶段通过网络或其他方式获取目标系统的相关信息，包括IP地址、操作系统类型、应用程序、网络拓扑结构等。</li><li>入侵（Weaponization）：攻击者根据目标系统的信息和漏洞，选择相应的攻击载荷和工具，将攻击负载嵌入到可执行文件、文档、邮件等中，使其具有攻击性。</li><li>邮件传递（Delivery）：攻击者通过电子邮件、社交媒体、恶意广告等方式将攻击载荷发送给目标系统，实现攻击载荷的传递。</li><li>利用（Exploitation）：攻击者通过漏洞利用、社会工程学等手段，将攻击载荷注入到目标系统中，并实现远程代码执行、提权等操作。</li><li>安装（Installation）：攻击者在目标系统中安装后门、木马等恶意程序，用于控制系统、窃取敏感信息等。</li><li>操作（Command and Control）：攻击者通过已安装的后门、木马等恶意程序，远程控制目标系统，执行指令、窃取敏感信息等。</li><li>行动（Actions on Objectives）：攻击者在目标系统中完成所设定的目标，比如窃取敏感信息、破坏系统等。</li></ol><p><strong>钻石模型</strong>（Diamond Model）则是由美国网络安全公司Mandiant提出的模型，是一种网络攻击模型，用于描述网络攻击的四个方面：攻击者、受害者、工具和信息。这个模型基于四个问题：谁（Who）正在做什么（What）使用哪些工具（How）获取了什么（What），通过将这些问题组合成钻石形状的模型来描述网络攻击。</p><p>​用于描述网络攻击的四个要素：攻击者、目标、工具和技术。该模型认为，在任何一次网络攻击中，这四个要素都是密不可分的，彼此影响和支撑，分析这些要素的关系和变化可以帮助安全专家更好地理解攻击过程和实施相应的防范措施。</p><p>​在钻石模型中，攻击者和受害者分别位于模型的两个顶点，攻击工具和攻击信息分别位于另外两个顶点。攻击工具描述了攻击者使用的技术和工具，攻击信息描述了攻击者获取的信息。</p></blockquote><h3 id="简述后渗透测试的步骤。"><a href="#简述后渗透测试的步骤。" class="headerlink" title="简述后渗透测试的步骤。"></a>简述后渗透测试的步骤。</h3><blockquote><p>(1)打开代理: 通过代理访问目标，提升安全性;<br>(2) 绕过白名单:绕过白名单保护机制实现访问;<br>(3)提权:提升在目标系统里的访问权限:<br>(4)收集信息:收集目标的功能和最具有价值资产<br>(5)持续化控制:建立持续访问通道;<br>(6)检测与迁移:规避用户紧测</p></blockquote><h3 id="什么是提权-提权有哪些分类"><a href="#什么是提权-提权有哪些分类" class="headerlink" title="什么是提权?提权有哪些分类?"></a>什么是提权?提权有哪些分类?</h3><blockquote><p>提高权限简称提权，顾名思义，就是提高用户在系统中的权限。从低到高分为</p><p>1.应用后台权限</p><p>2.shell权限</p><p>3.服务器权限</p><p>4.域控权限</p></blockquote><h3 id="什么是持久化-持久化的方法有哪些"><a href="#什么是持久化-持久化的方法有哪些" class="headerlink" title="什么是持久化?持久化的方法有哪些?"></a>什么是持久化?持久化的方法有哪些?</h3><blockquote><p>​持久化的目的是实现对目标网络设备或节点系统的持续控制，这即是进行网络情报获取等攻击性网络空间行动所依赖的基础，也是开张积极防御繁殖威慑乃至实现网络展攻击的重要前提。</p><p>​持久化方法主要是干扰系统的正常启动逻辑，通过在服务器上放置一些后门来实现以后持久性的入侵，常见的方法包括Rootkit、Bootkit、注册表修改、WIM操作、定时任务、修改服务、劫持、创建自启动服务器、powershell、bitsadmin等</p></blockquote><h3 id="简述跳板攻击的过程。"><a href="#简述跳板攻击的过程。" class="headerlink" title="简述跳板攻击的过程。"></a>简述跳板攻击的过程。</h3><blockquote><p>为了更好地隐蔽自己，一些网络攻击者通常并不直接从自己的系统向目标发动攻击，而是先攻破若干中间系统，让他们称为“跳板”，再通过跳板系统完成攻击行动</p></blockquote><h3 id="简述端口转发。"><a href="#简述端口转发。" class="headerlink" title="简述端口转发。"></a>简述端口转发。</h3><blockquote><p>端口转发有时候被称为隧道，是安全壳为网络安全通信使用的一种方法。是将一个网络端口从一个网络节点转发到另一个网络节点的行为，他是一个外部用户从外部经过一个被激活的NAT路由器到达一个再私有内部IP地址上的一个端口</p></blockquote><h3 id="简述会话劫持的方法与步骤。"><a href="#简述会话劫持的方法与步骤。" class="headerlink" title="简述会话劫持的方法与步骤。"></a>简述会话劫持的方法与步骤。</h3><blockquote><p>会话劫持（Session Hijacking）指攻击者盗取合法用户的身份认证信息，利用这些信息欺骗系统，以合法用户的身份进行攻击行为的过程。常见的会话劫持方式有以下几种：</p><ol><li>IP 欺骗：攻击者通过欺骗网络中的路由器或者交换机，将合法用户的请求流量重定向到攻击者的计算机，从而劫持了用户的会话。</li><li>ARP 欺骗：攻击者通过 ARP 欺骗攻击，将网络中合法用户的请求流量重定向到攻击者的计算机，从而劫持了用户的会话。</li><li>XSS 攻击：攻击者通过在网页中植入恶意脚本，当用户访问该网页并执行脚本时，攻击者就可以获取到用户的身份认证信息，从而劫持了用户的会话。</li><li>会话劫持工具：攻击者使用专门的工具，如 Cookie Digger、Session Sniffer 等，来截获合法用户的 Cookie 或 Session ID，从而劫持用户的会话。</li></ol><p>会话劫持的步骤如下：</p><ol><li>攻击者通过各种方式获取到合法用户的会话信息，例如 Cookie 或 Session ID。</li><li>攻击者使用获取到的会话信息模拟用户的身份进行攻击，例如访问敏感页面、发送恶意请求等。</li><li>如果攻击成功，攻击者就可以获得被攻击系统的控制权限，并在其中进行恶意行为。</li><li>合法用户可能会在不知情的情况下继续使用被劫持的会话，导致攻击者可以持续访问被攻击系统。</li></ol><p>为了防止会话劫持，可以采取以下措施：</p><ol><li>使用 HTTPS：通过使用 HTTPS 协议，可以对用户和服务器之间的通信进行加密，从而避免会话信息被窃取。</li><li>增加 Session ID 的复杂度：增加 Session ID 的复杂度可以有效防止攻击者通过猜测 Session ID 来获取会话信息。</li><li>对输入进行验证：通过对用户的输入进行验证，可以有效防止 XSS 攻击等漏洞，从而减少会话劫持的风险。</li><li>使用双因素认证：使用双因素认证可以增加攻击者窃取会话信息的难度，从而提高系统的安全性。</li></ol></blockquote><h3 id="比较后渗透测试信息收集与前期渗透测试信息收集的异同点。"><a href="#比较后渗透测试信息收集与前期渗透测试信息收集的异同点。" class="headerlink" title="比较后渗透测试信息收集与前期渗透测试信息收集的异同点。"></a>比较后渗透测试信息收集与前期渗透测试信息收集的异同点。</h3><blockquote><p>​1.信息内容</p><p>​前期渗透测试主要关注的是目标系统本身的参数和信息。其目的是获得非授权进入目标系统的条件:后渗透测试在已经获得目标系统的部分非授权访问的条件下，根据渗透测试交互阶段的约定，按照任务要求主要收集最具价值和尝试安全保护的信息和资产。</p><ol start="2"><li><p>收集行为</p><p>  前期渗透测试考虑到网络的开放性，不用过于关注行为的隐蔽，因此可以采用主被动相结合的信息收集方法; 实施后渗透攻击，特别是 APT 渗透，其目的是最大程度的隐藏,存活越久才可以发现更多，因此多采取屏幕观看、键盘记录等方式，不多做主动行为(即使模拟用户行为也不做)，当然外传数据采用闲时传送、压缩、加密等手段是必不可少的。只有达到最终收割阶段的时候，各种方式才都会被采取，最大化窃取数据才是最终目的。</p></li><li><p>权限等级</p></li></ol><p> ​前期渗透获取的信息大部分都是在没有权限等级要求下就可以得到的公开信息;而后渗透测试获取的信息一般都是以某种权限等级为前提才能获得的非公开信息，因此在获取过程中，提权和密码破译手段的运用就显得十分重要。<br> 后渗透测试的信息收集是渗透方法与信息获取手段的综合应用。</p></blockquote><h3 id="后渗透测试收集的信息有哪些"><a href="#后渗透测试收集的信息有哪些" class="headerlink" title="后渗透测试收集的信息有哪些?"></a>后渗透测试收集的信息有哪些?</h3><blockquote><p>​由于已经完成了前期渗透，初步进入目标系统，具有一定的从接触外部无法触及信息的权限，因此可以再次执行信息收集的任务。<br>后渗透测试尝试获取的信息包括:</p><p>​(1)内网结构、参数、拓扑、漏洞等;<br>​(2)业务系统种类、等级、价值等;<br>​(3) 权限策略信息、管理员账号&#x2F;哈希值、令牌、cookie 等;<br>​(4)员工当前业务、工作习惯、个人信息等;<br>​(5)最具价值和尝试安全保护的信息和资产，以及其他信息等。</p></blockquote><h3 id="如何规避应用程序控制策略"><a href="#如何规避应用程序控制策略" class="headerlink" title="如何规避应用程序控制策略?"></a>如何规避应用程序控制策略?</h3><blockquote><p>(1) Ofice 宏:利用宏获得程序执行;<br>(2) dII&#x2F;CPL:将 dIl 重命名为 CPL 并运行;(3)Chm 后门捆绑:利用捆绑工具，将恶意程序捆到白名单进程中;<br>(4)Powershell;通过本地的 Powershell 运行程序,如禁用了 Powershell 则可以通过NET执行 powershell再运行;<br>(5)Regsvr32:通过执行 Regsvr32 修复程序;<br>(6)Regsvcs: Regasm 和 Regsvcs 都是用于向 COM 对象注册程序集文件的 Microsoft二进制文件。这些二进制文件可以在.NET 框架中找到，并且由于它们是可信的，可以绕过应用限制;<br>(7)Installutil:使用Istallutil将恶意程序安装为系统服务;<br>(8)关闭控制机制:在提权的基础上获得管理员权限，针对性地关闭部分限制策略<br>随着渗透技术的不断发展，还有很多规避方法。</p></blockquote><h3 id="什么是横向移动-横向移动的方法有哪些"><a href="#什么是横向移动-横向移动的方法有哪些" class="headerlink" title="什么是横向移动?横向移动的方法有哪些?"></a>什么是横向移动?横向移动的方法有哪些?</h3><blockquote><p>横向移动渗透攻击技术是复杂网络攻击中广泛使用的一种技术，特别是再APT中更加热衷使用的攻击技术。以被攻陷的系统为跳板访问其他主机，包括邮箱、共享文件夹或者是凭证信息在内的敏感信息。</p><p>1.基于域间信任关系欺骗方法：在内部子网中，为了方便管理一般会设域控制器，收起管理的主机默认对域控制器信任。</p><p>2.基于共享资源污染的方法：为了方便协同工作，通常会建立共享资源机制，共同对某些文件进行操作，形成交叉影响</p></blockquote><h3 id="简述网络取证。"><a href="#简述网络取证。" class="headerlink" title="简述网络取证。"></a>简述网络取证。</h3><blockquote><p>完成后渗透测试后，整个测试活动也就接近尾声了，为了记录测试过程，同时为测试结论提供佐证，需要对测试过程中采用的方法、收集的数据、渗透的手段进行取证。</p><p>计算机取证也称数据取证、电子取证、是对计算机犯罪证据的获取、保存、分析、出示、是以技术手段对计算机犯罪过程进行重建的一个过程。</p></blockquote><h1 id="第九章：社会工程学渗透测试"><a href="#第九章：社会工程学渗透测试" class="headerlink" title="第九章：社会工程学渗透测试"></a>第九章：社会工程学渗透测试</h1><h3 id="什么是社会工程-社会工程具有什么特征"><a href="#什么是社会工程-社会工程具有什么特征" class="headerlink" title="什么是社会工程?社会工程具有什么特征?"></a>什么是社会工程?社会工程具有什么特征?</h3><blockquote><p>​社会工程学是利用人性的弱点侦察、获取有价值信息的实践方法。社会工程学的方法的核心是使用心理学去唆使人们不经意地透露他们所知的信息或访问权限的过程。</p><p>从被攻击者的行为表现来分析，社会工程学攻击一般分为一致性、合作性、关联性的显著特征，</p><p>​一致性，当一个人处理一种群体环境下往往会收到群体的压力，个人的行动在满足群个体决定的行为时将会收到约束，呈现出与集体保持一致性的倾向。利用这种心理特征，攻击者可能会提出有引导性的请求行为，诱导受攻击者对攻击者的请求进行响应。</p><p>​合作性，攻击大部分是由攻击者以及被攻击者合作实现的，被攻击者在壁纸请的情况下直接或间接完成了对攻击者的配合。通常攻击者针对目标都会设计号攻击的模拟场景，引导收攻击者去主动配合攻击者一起合作完成某个事项。受攻击者主动顺从地配合攻击者完成行为，体现了社会工程学攻击的与人交互的合作性。</p><p>​关联性，社会工程学的成功实施取决于开展本次攻击的目标与个体之间的关联关系，关联性低的个体往往是开展社会工程学的目标。因为他们对攻击所获得的信息并非有很高的关联性，往往忽略了该类信息的重要性。</p><ol><li>一致性：指攻击者能够获得攻击目标的信任，并且让目标相信攻击者是合法的。攻击者通常会伪装成一个可信的个体或机构，比如伪装成银行客服或是IT管理员，以获取目标的信任。攻击者还会利用目标的心理，比如好奇心、恐惧心理等，来使目标放松警惕。</li><li>合作性：指攻击者能够获取目标的合作，让目标主动提供所需的信息或执行所需的行为。攻击者通常会使用诱骗、欺骗、威胁等手段来促使目标合作。</li><li>关联性：指攻击者能够将攻击行为与目标的实际情况联系起来，让目标认为攻击是合理的。攻击者通常会调查目标的相关信息，比如公司组织结构、工作流程等，从而使攻击行为看起来合理而不引起怀疑。</li></ol></blockquote><h3 id="社会工程渗透的方法有哪些"><a href="#社会工程渗透的方法有哪些" class="headerlink" title="社会工程渗透的方法有哪些?"></a>社会工程渗透的方法有哪些?</h3><blockquote><p><strong>技术方法有：在线攻击，电话攻击，非交互式技术，反向社会工程，学科交叉技术</strong></p><p>在线攻击有邮件利用、钓鱼技术、域欺骗技术。</p><p>电话攻击有直接索取、成控交换机、信息服务平台</p><p>非交互式有垃圾搜索、公共信息媒体、搜索引擎搜索</p><p>反向社会工程是迫使目标人员反过来向攻击者求助的手段。</p><p>学科交叉技术有组织行为学技术、安全心里盲区、网管心理分析</p><p><strong>实施方法有：冒名顶替，投桃报李、狐假虎威、诱骗重利、观点共鸣</strong></p><p>冒名顶替是指攻击人员假装成他人以获得对方的信任。</p><p>投桃报李是指通过利益交换的方式达成双方各自利益的行为</p><p>狐假虎威是冒充单位业务负责人的身份从而干预正常业务的做法就是狐假虎威。</p><p>诱骗重利基于人们的欲望心理，设计交换条件获得重要信息</p><p>观点共鸣，作为人，我们总是需要某种形式的社会关系，以分享思想、感情做法。由于这种强烈的感情和信任的错觉，人们可能在不经意间向对手透露了信息。</p></blockquote><h3 id="简述社会工程渗透的一般步骤。"><a href="#简述社会工程渗透的一般步骤。" class="headerlink" title="简述社会工程渗透的一般步骤。"></a>简述社会工程渗透的一般步骤。</h3><blockquote><p>情报收集：采用高级搜索工具收集目标人员的邮箱地址；利用社交网络收集目标人员的个人信息；识别目标使用的软件、参与的经营社交会议等、准确推测筛选目标人员。</p><p>识别漏洞：一旦选中人后，接下来就是跟对方开始建立信任关系和友谊，这样可以在不惊动对方的情况下截获对方的信息，保证整个行动的隐蔽性和保密性</p><p>规划攻击：制定计划，可以对目标直接发起攻击，也可利用电子辅助技术被动地攻击目标。从挖掘来的情报入口着手拟定攻击路径和方法。</p><p>执行攻击：保持足够的信息和耐心执行攻击，过程中根据对象的反应变化不断地调整攻击方案。攻击成功后，也宣告结束。</p></blockquote><h3 id="安全专家是如何对社会工程渗透进行防范的-如何进行突破"><a href="#安全专家是如何对社会工程渗透进行防范的-如何进行突破" class="headerlink" title="安全专家是如何对社会工程渗透进行防范的?如何进行突破?"></a>安全专家是如何对社会工程渗透进行防范的?如何进行突破?</h3><blockquote><p>1.建立完善的信息安全管理策略</p><p>2.对系统管理相关人员进行培训</p><p>3.建立安全事件应急响应小组</p><p>对于社会工程渗透的突破，安全专家需要不断地跟进新的攻击技术和手段，并采取相应的防范措施。</p><p>此外，他们还需要加强安全监控和漏洞管理，及时发现并修复系统中的漏洞。</p><p>同时，安全专家也可以采取一些主动的渗透测试，发现系统中存在的安全风险并加以修复</p></blockquote><h3 id="基于社交网络的社会工程渗透有哪些特点"><a href="#基于社交网络的社会工程渗透有哪些特点" class="headerlink" title="基于社交网络的社会工程渗透有哪些特点?"></a>基于社交网络的社会工程渗透有哪些特点?</h3><blockquote><p>信息传播是社交网络的核心功能之一，SNS信息传播有以下特点。</p><p>1.低成本传播</p><p>2.多维度的信息传播</p><p>3.即时互动</p><p>4.基于人际关系</p><p>5.裂变式</p><ul><li>隐蔽性强：攻击者可以伪装成目标用户的朋友、同事、客户等，利用社交网络上的各种功能和渠道，如私信、评论、转发、点赞等，来与目标用户建立信任关系，从而达到欺骗或诱导的目的。</li><li>成本低廉：攻击者不需要使用复杂的技术手段或工具，只需要利用社交网络上已有的信息和功能，就可以实施攻击。例如，通过搜索目标用户的个人资料、兴趣爱好、工作单位等，就可以制定针对性的攻击策略。</li><li>危害严重：攻击者可以通过社会工程渗透获取目标用户的敏感信息，如密码、银行卡号、身份证号等，或者诱使目标用户下载安装恶意软件，从而造成经济损失或隐私泄露。</li></ul></blockquote><h3 id="简述SET工具包的主要功能。"><a href="#简述SET工具包的主要功能。" class="headerlink" title="简述SET工具包的主要功能。"></a>简述SET工具包的主要功能。</h3><blockquote><p>社会工程工具包是一款先进的多功能的社会工程学计算机辅助工具包，它可以性质有效的用科幻段应用程序的漏洞获取目标的信息。</p><ol><li><p>伪造网站攻击（Website Attack Vectors）：可以伪造各种类型的恶意网站，包括钓鱼网站、恶意下载、社交工程网站等，用于诱骗目标用户进行点击或输入敏感信息。</p></li><li><p>伪造电子邮件攻击（Email Spoofing Attack Vectors）：可以伪造各种类型的电子邮件，包括欺诈邮件、恶意附件邮件、钓鱼邮件等，用于欺骗目标用户打开恶意文件或链接。</p></li><li><p>嵌入式攻击（Embedded Attack Vectors）：可以将各种类型的恶意代码嵌入到常见的文档、图像、音频和视频文件中，通过社交工程手段诱骗目标用户打开文件，从而实现攻击。</p></li><li><p>自定义攻击向量（Custom Attack Vectors）：可以自定义各种类型的攻击向量，包括USB攻击、QR码攻击、电话攻击、钓鱼攻击等。</p></li><li><p>集成第三方工具（Third Party Integrations）：可以集成第三方工具，如Metasploit、Nmap、BeEF等，增强攻击功能和效果。</p></li></ol></blockquote><h1 id="第十章：工控网络渗透测试"><a href="#第十章：工控网络渗透测试" class="headerlink" title="第十章：工控网络渗透测试"></a>第十章：工控网络渗透测试</h1><h3 id="简述SCADA网络的应用"><a href="#简述SCADA网络的应用" class="headerlink" title="简述SCADA网络的应用"></a>简述SCADA网络的应用</h3><blockquote><p>1.在电力系统的应用：作为能量管理系统EMS的最主要的子系统，具有信息完整、效率高、能正确掌握系统运行状态、决策快、能推断出系统故障状态等优势。</p><p>2.铁道电气化</p><p>3.输油管道，采集设备状态数据，监控提供预警保护。</p><p>4.工业自动化，自动化生产线组成包括控制单元、数据采集与监控、机器人传感器。</p></blockquote><h3 id="简述工控网络的结构。"><a href="#简述工控网络的结构。" class="headerlink" title="简述工控网络的结构。"></a>简述工控网络的结构。</h3><blockquote><p>系统结构：硬件（客户、服务器）、软件（多任务系统）、通信（内部外部IO三种）</p><ol><li>管理层：包括网络管理和控制设备管理等，主要负责对工控网络进行管理和监控。</li><li>数据中心层：包括数据库和服务器等，主要负责存储和处理工控系统产生的数据。</li><li>控制层：包括PLC（Programmable Logic Controller）、DCS（Distributed Control System）等，主要负责对生产过程进行控制和调度。</li><li>设备层：包括传感器、执行器等，主要负责对生产设备进行控制和监测。</li></ol></blockquote><h3 id="解释什么是梯形逻辑"><a href="#解释什么是梯形逻辑" class="headerlink" title="解释什么是梯形逻辑?"></a>解释什么是梯形逻辑?</h3><blockquote><p>梯形逻辑是一种编程语言，它通过基于继电器逻辑电路图的图形来代表程序<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2%E9%80%BB%E8%BE%91">1</a><a href="https://zh.wikipedia.org/zh-cn/%E6%A2%AF%E5%BD%A2%E9%80%BB%E8%BE%91">2</a>。它主要用于开发可编程逻辑控制器（PLC）的软件，用于工业控制应用<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2%E9%80%BB%E8%BE%91">1</a><a href="https://zh.wikipedia.org/zh-cn/%E6%A2%AF%E5%BD%A2%E9%80%BB%E8%BE%91">2</a>。梯形逻辑的程序看起来像一个一级一级的梯子，具有两条是指边和多个水平的梯级<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2%E9%80%BB%E8%BE%91">1</a><a href="https://zh.wikipedia.org/zh-cn/%E6%A2%AF%E5%BD%A2%E9%80%BB%E8%BE%91">2</a>。每个梯级都包含一个或多个输入条件和一个输出条件，当输入条件满足时，输出条件就会被激活<a href="https://blog.csdn.net/qq_34492170/article/details/120470308">3</a><a href="https://cloud.tencent.com/developer/article/1430688">4</a>。</p></blockquote><h3 id="工控网络的安全漏洞有哪些"><a href="#工控网络的安全漏洞有哪些" class="headerlink" title="工控网络的安全漏洞有哪些?"></a>工控网络的安全漏洞有哪些?</h3><blockquote><p>1.SCADA系统软件漏洞</p><p>2.操作系统漏洞</p><p>3.网络通信协议漏洞</p><p>4.安全策略与管理流程漏洞</p></blockquote><h3 id="简述震网病毒的入侵思路。"><a href="#简述震网病毒的入侵思路。" class="headerlink" title="简述震网病毒的入侵思路。"></a>简述震网病毒的入侵思路。</h3><blockquote><p>震网病毒入侵目标的整体传播思路是: 首先侵入位于互联网中主机然后感染U盘，利用微软的快捷方式文件解析漏洞MS0-046)传播到工业专用内部网络:接下来在内网中T通过 RPC 远程代码执行漏洞(MS08-067)、打印机后台远程服务中的远程代码执行漏洞(MS10-061)、计划任务服务限提升漏洞(MS10-092)Windows内核模式驱动程序权限提升漏洞(MS10-73)等，实现在内网主机之间的传播量后抵达安装有 WinCC系统的主机，修改其可编程逻辑控制器，劫持控制逻辑发送控制指令，使工业控制系统控制混乱，最终造成业务系统异常、核心数据泄露、停产停工等</p></blockquote><h3 id="简述工控网络渗透测试的主要步骤"><a href="#简述工控网络渗透测试的主要步骤" class="headerlink" title="简述工控网络渗透测试的主要步骤"></a>简述工控网络渗透测试的主要步骤</h3><blockquote><p>1.内网访问</p><p>2.目标分析</p><p>3.过程控制</p><ol><li>网络架构分析：对工控系统的物理和逻辑拓扑结构进行分析，包括网络设备、工控设备、通讯协议等。</li><li>服务识别和端口扫描：通过端口扫描工具扫描网络上开放的端口和服务，确定可以攻击的目标。</li><li>操作系统识别和漏洞扫描：通过漏洞扫描工具扫描网络设备和工控设备上的操作系统和应用程序是否存在已知漏洞。</li><li>无线网络渗透测试：如果工控网络中存在无线设备，则需要对其进行渗透测试。</li><li>嗅探和协议分析：对网络上的通信流量进行嗅探和协议分析，获取有价值的信息。</li><li>漏洞利用和提权：根据漏洞扫描结果，使用渗透测试工具对目标设备进行漏洞利用和提权。</li><li>后渗透测试：获取管理员权限后，进一步测试系统的安全性，包括数据泄漏、持久化攻击等。</li><li>覆盖痕迹：删除攻击痕迹，避免被检测到。</li></ol></blockquote><h1 id="第十一章：无线网络渗透测试"><a href="#第十一章：无线网络渗透测试" class="headerlink" title="第十一章：无线网络渗透测试"></a>第十一章：无线网络渗透测试</h1><h3 id="简述无线网络的发展。"><a href="#简述无线网络的发展。" class="headerlink" title="简述无线网络的发展。"></a>简述无线网络的发展。</h3><blockquote><ol><li>无线电通信时代（20世纪初至20世纪40年代）：这个阶段的无线通信主要用于无线电广播、电报和军事通信等。当时使用的技术主要是无线电波，主要特点是传输距离远但带宽小。</li><li>蜂窝移动通信时代（20世纪70年代至90年代）：这个阶段无线通信进入了商业化阶段，开始应用于移动通信。蜂窝移动通信网络可以分为1G、2G、3G、4G等几代，每一代都有自己的特点和技术。</li><li>无线局域网时代（20世纪90年代至今）：随着移动计算设备的发展，无线局域网技术开始应用于家庭和办公室等小范围网络的构建。最初的无线局域网标准是IEEE 802.11，后来又出现了一些变种，如802.11a、802.11b、802.11g、802.11n、802.11ac等。</li><li>无线城域网和广域网时代（21世纪初至今）：这个阶段主要是针对无线网络的覆盖范围和容量进行扩展。无线城域网和广域网的技术可以支持大规模的无线网络覆盖，例如城市Wi-Fi、无线城市和移动通信网络等。</li><li>5G时代（2019年至今）：5G是第五代移动通信技术，具有高带宽、低时延和大连接数的特点。5G网络的应用将更加广泛，涉及智能家居、智慧城市、自动驾驶等多个领域。</li></ol></blockquote><h3 id="分析无线网络的安全问题。"><a href="#分析无线网络的安全问题。" class="headerlink" title="分析无线网络的安全问题。"></a>分析无线网络的安全问题。</h3><blockquote><p>由于无线路由器的DNS设置被暴力篡改</p><p>由于公共场所无线网络的开放性</p><p>无线网络密码设置过于简单</p><p>无线网络的信号受外部电磁环境影响较大</p></blockquote><h3 id="无线网络的攻击方式有哪些"><a href="#无线网络的攻击方式有哪些" class="headerlink" title="无线网络的攻击方式有哪些?"></a>无线网络的攻击方式有哪些?</h3><blockquote><p>未经授权用户私自连接</p><p>网络病毒侵入</p><p>数据泄露</p><p>网络窃听隐患</p><p>流氓接入点</p><p>信号干扰</p></blockquote><h3 id="解释什么是战争驾驶。"><a href="#解释什么是战争驾驶。" class="headerlink" title="解释什么是战争驾驶。"></a>解释什么是战争驾驶。</h3><blockquote><p>“战争驾驶”（WarDriving）是一种利用车辆或其他移动设备，收集无线网络信息的行为。WarDriving的主要目的是为了发现无线网络的安全漏洞，包括未加密的Wi-Fi网络，弱密码和易受攻击的网络设备等。</p><p>WarDriving的步骤通常包括使用设备（如笔记本电脑、智能手机、GPS接收器等）和软件来扫描和记录无线网络的SSID、加密方式、信号强度和位置等信息。这些信息可以被黑客用来定位易受攻击的网络，并进行未经授权的访问或攻击。因此，WarDriving的行为在一定程度上是非法的，也可能会对网络安全造成威胁。</p></blockquote><h3 id="如何实现无线网络嗅探-比较它与有线网络嗅探的异同"><a href="#如何实现无线网络嗅探-比较它与有线网络嗅探的异同" class="headerlink" title="如何实现无线网络嗅探?比较它与有线网络嗅探的异同"></a>如何实现无线网络嗅探?比较它与有线网络嗅探的异同</h3><blockquote><p>​无线网络嗅探指的是通过一定的技术手段，监控和捕获无线网络中的数据流量和信号，并对其进行分析，以了解网络的状态和性能，或者进行安全评估和攻击等行为。无线网络嗅探的主要目的是为了监控和管理无线网络，或者为了进行网络安全攻击和渗透测试等行为。</p><p>​与有线网络嗅探不同的是，无线网络嗅探需要对无线信号进行抓取和解码，并对无线协议进行深入分析。由于无线信号的传输受到环境、干扰等因素的影响，因此无线网络嗅探的难度较大，需要使用专门的无线嗅探设备和软件来实现。此外，无线网络嗅探涉及到的安全问题也比有线网络更加复杂和敏感，需要采取更加严格和细致的安全措施和防护策略。</p><p>​实现无线网络嗅探的常用工具有Wireshark、Airodump-ng、Kismet等。这些工具可以在无线网络中捕获数据包并对其进行分析，以获得无线网络中的信息。</p><p>与有线网络嗅探相比，无线网络嗅探存在以下几个异同点：</p><p>相同点：</p><ul><li>都可以用于捕获网络中的数据包并进行分析。</li><li>都需要特殊的工具和技能。</li></ul><p>不同点：</p><ul><li>无线网络嗅探需要使用无线网卡，而有线网络嗅探则需要使用有线网卡。</li><li>无线网络嗅探受到无线信号的干扰和传播距离的限制，有时可能无法捕获到所有数据包。而有线网络嗅探则不会受到这些限制。</li><li>由于无线网络是广播信道，因此所有无线数据包都可以在物理层面上被任何拥有无线网卡的设备所接收到。这意味着任何拥有无线网卡的设备都可以进行无线网络嗅探。而有线网络只能被物理连接到网络中的设备所接收到。</li></ul><p>总的来说，无线网络嗅探与有线网络嗅探在原理上是相似的，但在具体实现和应用上存在较大的区别。</p></blockquote><h3 id="如何进行电磁信息的泄露与复现"><a href="#如何进行电磁信息的泄露与复现" class="headerlink" title="如何进行电磁信息的泄露与复现"></a>如何进行电磁信息的泄露与复现</h3><blockquote><ol><li>环境准备：需要一些专业的设备，如电磁信号接收器和分析软件等。</li><li>收集信息：使用电磁信号接收器，可以获取目标设备发出的电磁信号，比如无线电信号、辐射信号等。收集到的信号可以保存到文件中，作为后续分析的数据源。</li><li>信号分析：对收集到的信号进行分析，找出其中有用的信息，如通信内容、加密算法等。可以使用专业的分析软件，如Wireshark等。</li><li>信息重现：根据分析结果，重现目标设备的行为，比如复制加密密钥、仿造无线电信号等。</li></ol></blockquote><h3 id="简述WEP密钥破解过程。"><a href="#简述WEP密钥破解过程。" class="headerlink" title="简述WEP密钥破解过程。"></a>简述WEP密钥破解过程。</h3><blockquote><p>WEP共享密钥猜测 密钥破解是指获得数据并通过暴力译码或FMS译码攻击来复原WEP密钥。</p><p>WEP（Wired Equivalent Privacy）是无线局域网（WLAN）安全的一种加密方式，它已经被更加安全的加密方式WPA和WPA2所取代。WEP加密方式使用一个固定的密钥来对数据进行加密和解密。下面是WEP密钥破解的基本过程：</p><ol><li>收集数据包：通过无线网络接收器在信道上监听数据包并捕获WEP加密的数据包。</li><li>识别有效数据包：使用特殊工具或软件来过滤和识别有效的数据包。有效的数据包通常包含一个被攻击者发送的明文（未加密）数据，如ARP请求等。</li><li>破解WEP密钥：攻击者利用软件工具对WEP加密算法进行攻击，可以使用现成的工具，如Aircrack-ng、Airsnort等，或者自己编写代码进行攻击。攻击方式主要有两种：基于已知的密钥流攻击和基于弱IV攻击。基于已知的密钥流攻击是指攻击者拥有一部分密钥流并通过分析密钥流生成算法来破解整个密钥。基于弱IV攻击是指攻击者寻找WEP加密中使用的弱IV（初始化向量）并利用其漏洞进行破解。攻击者可以通过重复发送相同的数据包来收集大量的数据包并破解密钥。</li><li>获取网络访问权：一旦攻击者破解了WEP密钥，他们就可以使用网络资源，并嗅探网络中的数据流量来获取敏感信息。</li></ol><p>需要注意的是，WEP加密方式已经被证明非常不安全，并且易于攻击。因此，建议使用更加安全的加密方式，如WPA和WPA2。</p></blockquote><h3 id="如何进行无线网络授权攻击"><a href="#如何进行无线网络授权攻击" class="headerlink" title="如何进行无线网络授权攻击?"></a>如何进行无线网络授权攻击?</h3><blockquote><p>入侵者可以使用授权攻击来窃取合法用户的身份和机密信息，并进入私人网络和服务。</p><ol><li>伪造MAC地址：攻击者可以使用MAC地址欺骗的方式来伪造合法设备的MAC地址，以获取访问控制列表中的访问权限。攻击者可以使用工具来进行MAC地址伪造，如SpoofMAC等。</li><li>ARP欺骗：攻击者可以使用ARP欺骗的方式来获取网络访问权限。攻击者向目标设备发送伪造的ARP数据包，将目标设备的IP地址映射到攻击者的MAC地址上。攻击者可以使用工具来进行ARP欺骗，如Ettercap等。</li><li>欺骗用户：攻击者可以通过社交工程的方式来欺骗用户，以获取用户的登录信息。攻击者可以发送钓鱼邮件、伪造网站等方式来欺骗用户，以获取用户的账号密码等信息。</li><li>破解密码：攻击者可以使用破解工具来破解无线网络密码，以获取网络访问权限。常见的破解工具包括Aircrack-ng、Hashcat等。</li><li>具体的技术点</li></ol><ul><li>MAC地址欺骗：攻击者检测到授权设备上的网络适配器MAC地址，企图冒充授权设备建立新连接<a href="https://bing.com/search?q=%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%8E%88%E6%9D%83%E6%94%BB%E5%87%BB">1</a>。</li><li>帧欺骗（又叫帧注入）：攻击者发送看似来自合法发送者的恶意数据帧<a href="https://bing.com/search?q=%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%8E%88%E6%9D%83%E6%94%BB%E5%87%BB">1</a>。</li><li>IP欺骗：攻击者使用篡改过的IP数据包来隐藏数据包的真实来源<a href="https://bing.com/search?q=%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%8E%88%E6%9D%83%E6%94%BB%E5%87%BB">1</a>。</li><li>数据重放：攻击者捕获无线传输的数据，篡改传输内容，并将篡改后的内容重新传输给目标系统<a href="https://bing.com/search?q=%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%8E%88%E6%9D%83%E6%94%BB%E5%87%BB">1</a>。</li><li>身份验证重放：攻击者捕获用户之间的身份验证交换内容，并在攻击中重新使用这些交换内容<a href="https://bing.com/search?q=%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%8E%88%E6%9D%83%E6%94%BB%E5%87%BB">1</a>。</li><li><a href="https://baijiahao.baidu.com/s?id=1752714725580170329">非法接入点：攻击者将任何未经授权的接入点连接到网络，从而访问网络中的应用和数据</a><a href="https://baijiahao.baidu.com/s?id=1752714725580170329">2</a><a href="http://www.cnetsec.com/dfaq_wordpress/?p=39118">3</a>。</li><li><a href="https://baijiahao.baidu.com/s?id=1752714725580170329">无线网络钓鱼（又叫双面恶魔）：攻击者设置一个与目标网络类似或相同名称和配置的假冒接入点，诱使用户连接并窃取其敏感信息</a><a href="https://baijiahao.baidu.com/s?id=1752714725580170329">2</a><a href="http://www.cnetsec.com/dfaq_wordpress/?p=39118">3</a>。</li></ul></blockquote><h3 id="简述如何进行蓝牙渗透测试。"><a href="#简述如何进行蓝牙渗透测试。" class="headerlink" title="简述如何进行蓝牙渗透测试。"></a>简述如何进行蓝牙渗透测试。</h3><blockquote><ol><li>收集目标蓝牙设备的信息：包括设备类型、蓝牙地址、制造商、服务、协议等信息。</li><li>扫描目标蓝牙设备：使用蓝牙扫描工具扫描周围的蓝牙设备，并记录它们的MAC地址和服务信息。</li><li>获取目标蓝牙设备的服务信息：使用蓝牙扫描工具获取目标蓝牙设备的服务信息，包括服务名称、服务UUID、端口号等信息。</li><li>尝试连接目标蓝牙设备：使用蓝牙连接工具尝试连接目标蓝牙设备，并进行身份验证和授权操作。</li><li>分析蓝牙通信协议：对目标蓝牙设备和应用进行分析，了解其通信协议和数据格式，并尝试寻找漏洞。</li><li>利用蓝牙漏洞进行攻击：根据分析结果，利用蓝牙漏洞进行攻击，例如通过蓝牙进行远程代码执行、篡改蓝牙通信数据、获取设备敏感信息等。</li><li>渗透测试报告撰写：根据渗透测试结果，编写渗透测试报告，并提出相应的修复建议。</li></ol></blockquote><h3 id="简述移动终端的渗透测试"><a href="#简述移动终端的渗透测试" class="headerlink" title="简述移动终端的渗透测试"></a>简述移动终端的渗透测试</h3><blockquote><p><a href="https://www.freebuf.com/articles/terminal/235143.html">移动终端渗透测试是一种用来检测移动APP和相关系统安全性的方法。测试的目的是充分分析和挖掘移动APP和相关系统存在的安全问题，进而帮助其进行修复，提升安全性，保护用户信息</a><a href="https://www.freebuf.com/articles/terminal/235143.html">1</a>。</p><p><a href="https://www.freebuf.com/articles/terminal/235143.html">在移动APP架构中，面临安全威胁的目标&#x2F;路径主要有三个，它们分别是：移动APP、数据传输和服务端</a></p></blockquote><blockquote><ol><li>信息收集：获取目标设备的相关信息，如操作系统版本、安装应用程序、网络连接情况等。</li><li>应用分析：对目标设备上的应用程序进行分析，包括反编译应用程序代码、检测应用程序漏洞等。</li><li>网络渗透测试：检测目标设备的网络漏洞，例如WiFi、蓝牙和NFC漏洞等。</li><li>攻击面评估：评估目标设备的攻击面，并分析其可能的攻击路径。</li><li>漏洞利用：利用已知或发现的漏洞对目标设备进行攻击，例如代码注入、应用程序漏洞利用等。</li><li>漏洞修复：对发现的漏洞进行修复，以提高目标设备的安全性。</li><li>报告编写：撰写渗透测试报告，包括发现的漏洞、攻击路径和修复建议等。</li></ol><p>移动终端渗透测试需要使用一些工具和技术，如反编译工具、网络分析工具、漏洞扫描器、代码注入工具等。同时，渗透测试人员需要对移动设备的操作系统、应用程序和通信协议有深入的了解。</p></blockquote><h1 id="第十二章：渗透测试自动化框架"><a href="#第十二章：渗透测试自动化框架" class="headerlink" title="第十二章：渗透测试自动化框架"></a>第十二章：渗透测试自动化框架</h1><h3 id="什么是自动化测试"><a href="#什么是自动化测试" class="headerlink" title="什么是自动化测试?"></a>什么是自动化测试?</h3><blockquote><p>​自动化测试是执行某种程序设计语言编制的自动测试程序，控制被测程序的执行，模拟手动测试步骤，完成全自动或半自动测试。目的是提高软件测试的效率，降低人为因素带来的风险，从而达到提高应用软件测试质量的目的。</p></blockquote><h3 id="简述自动化测试的特点和局限性。"><a href="#简述自动化测试的特点和局限性。" class="headerlink" title="简述自动化测试的特点和局限性。"></a>简述自动化测试的特点和局限性。</h3><blockquote><p>特点：</p><p>​1.可以自动对程序的新版本执行回归测试</p><p>​2.可以执行一些手工测试困难或不可能进行的测试</p><p>​3.可以更好地利用资源。</p><p>​4.测试具有一致性和可重复性</p><p>​5.测试具有重用性</p><p>​6.可以更快地将软件推向市场</p><p>​7.可以增加软件信任度</p></blockquote><blockquote><p>局限性：</p><p>​1.手工测试比自动化测试发现的故障要多</p><p>​2.自动化测试不能提高测试的有效性</p><p>​3.自动化测试不具有想象力</p></blockquote><h3 id="简述安全自动化测试的特点和主要方法。"><a href="#简述安全自动化测试的特点和主要方法。" class="headerlink" title="简述安全自动化测试的特点和主要方法。"></a>简述安全自动化测试的特点和主要方法。</h3><blockquote><p>特点：</p><ol><li>提高效率：相对于手动测试，自动化测试可以提高测试效率和准确性。</li><li>重复性强：可以对同一功能进行反复测试，确保测试结果的一致性和可靠性。</li><li>覆盖面广：可以对系统的各个方面进行全面测试，包括功能、性能、安全等多个方面。</li><li>可追溯性高：可以记录测试的过程和结果，方便问题定位和分析。</li></ol></blockquote><blockquote><p>主要方法：</p><p>1.NIST SP800-115 信息安全测试技术指导方针是美国国家标准和技术研究所发布的关于安全测试技术的一份指导性文件。</p><p>2.ISSAF 信息系统安全评估框架是一个开源的安全测试和分析框架，按照逻辑顺序进行安全评估，主要关注技术和管理。</p><p>3.OSSTMN开源安全测试方法手册是一个被业界认可的用于安全测试和分析的国际标准。许多组织内部的日常安全评估中都是用该标准。分为四个关键部分，范围划定、通道、索引、向量，范围划定是收集目标资产，一个通道代表了一种与这些资产进行通信的方法和交互，这些通道组成了一个独立的安全组件的集合，在评估中需要对这些组件进行测试和验证。索引是一个非常游泳的方法，来将目标中的字长按照其特定标识进行分类。一个向量代表一个技术方向，审计人员可以在这个方向上对目标环境中的所有资产进行评估和分析。</p><p>4.PTES渗透测试执行标准是安全业界在渗透测试技术领域中正在开发的新标准，目标是对渗透测试进行重新定义。过程分为前期交互、情报收集、威胁模型、漏洞分析、渗透攻击、后渗透攻击、报告七个阶段。</p></blockquote><h3 id="自动化渗透测试框架有哪些分类，举例说明各类具有代表性的工具。"><a href="#自动化渗透测试框架有哪些分类，举例说明各类具有代表性的工具。" class="headerlink" title="自动化渗透测试框架有哪些分类，举例说明各类具有代表性的工具。"></a>自动化渗透测试框架有哪些分类，举例说明各类具有代表性的工具。</h3><blockquote><p>按分类分为综合型和专用型两种。</p><p>自动化渗透测试框架可以分为开源框架和商业框架两种类型。</p><p>开源框架：</p><ol><li>Metasploit Framework：是一款广泛使用的自动化渗透测试框架，支持多种操作系统和漏洞扫描、攻击等功能。</li><li>BeEF：是一个浏览器漏洞框架，用于检测浏览器和Web应用程序的漏洞，并进行攻击。</li><li>OWASP ZAP：是一款用于自动化测试Web应用程序安全性的工具，可以进行漏洞扫描、漏洞攻击等操作。</li><li>Nmap：是一个开源的网络探测和安全审计工具，可以进行端口扫描、服务探测、操作系统识别等操作，也可以用于渗透测试。</li><li>Arachni：是一款用于Web应用程序渗透测试的开源工具，可以检测多种Web应用程序漏洞。</li></ol><p>商业框架：</p><ol><li>Cobalt Strike：是一款商业的渗透测试框架，支持多种攻击向量和功能，包括漏洞扫描、攻击、命令和控制等。</li><li>Immunity Canvas：是一款商业的漏洞扫描和渗透测试框架，支持多种操作系统和漏洞利用技术。</li><li>Core Impact：是一款商业的渗透测试工具，提供了多种攻击向量和漏洞利用技术，包括漏洞扫描、攻击、权限提升、数据窃取等。</li><li>Rapid7 Nexpose：是一款商业的漏洞扫描工具，支持多种操作系统和应用程序，可以自动识别漏洞并提供解决方案。</li><li>SAINT Security Suite：是一款商业的渗透测试和漏洞扫描工具，支持多种漏洞扫描和攻击技术，包括SQL注入、XSS、CSRF等。</li></ol></blockquote><h3 id="MSF有哪些版本"><a href="#MSF有哪些版本" class="headerlink" title="MSF有哪些版本?"></a>MSF有哪些版本?</h3><blockquote><p>Metasploit是一个开源的安全漏洞检测框架，用于开发和执行安全漏洞测试、攻击等任务。Metasploit包含了多个工具和资源，支持渗透测试、漏洞检测和漏洞利用等各个阶段的安全测试任务。以下是Metasploit的主要组成部分：</p><ol><li>Exploit模块：包含多个漏洞利用模块，用于检测和利用各种软件和系统的漏洞，如操作系统漏洞、Web应用程序漏洞等。</li><li>Payload模块：用于生成各种类型的攻击载荷，如反向Shell、Meterpreter等，支持多种操作系统和平台。</li><li>Auxiliary模块：包含各种辅助工具和模块，如扫描器、密码破解器、DOS攻击工具等。</li><li>Post模块：用于在攻击成功后进行后续操作，如数据获取、命令执行等。</li></ol><p>Metasploit还提供了Web界面和命令行界面两种使用方式，支持自定义脚本和模块的开发和使用。Metasploit的特点包括可扩展性、可定制性、易于使用等，被广泛应用于安全测试、漏洞研究、恶意代码分析等领域。</p><p>Metasploit 有以下多种版本？</p><ol><li>Metasploit Framework：这是最常见的版本，是一个开源的渗透测试框架，可用于发现漏洞、开发自定义的漏洞利用和执行渗透测试。</li><li>Metasploit Pro：这是一个商业版本，提供了更多的功能，例如自动化渗透测试、风险评估、漏洞管理等。</li><li>Metasploit Express：这也是一个商业版本，与Metasploit Pro相比，功能较少，但价格也更便宜，适合小型企业使用。</li><li>Metasploit Community Edition：这是一个免费版本，功能相对较少，适合初学者使用。</li></ol></blockquote><h3 id="绘图描述MSF的框架结构。"><a href="#绘图描述MSF的框架结构。" class="headerlink" title="绘图描述MSF的框架结构。"></a>绘图描述MSF的框架结构。</h3><blockquote><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/MSF%E4%BD%93%E7%B3%BB%E6%A1%86%E6%9E%B6.jpg" style="zoom:80%;" /><center>MSF体系结构</center></blockquote><h3 id="MSF有哪些操作模式"><a href="#MSF有哪些操作模式" class="headerlink" title="MSF有哪些操作模式?"></a>MSF有哪些操作模式?</h3><blockquote><p>目前提供了GUI、控制台、命令行、Armitage四种操作模式供用户选择</p></blockquote><h3 id="简述MSF测试的基本流程。"><a href="#简述MSF测试的基本流程。" class="headerlink" title="简述MSF测试的基本流程。"></a>简述MSF测试的基本流程。</h3><blockquote><p>操作流程：</p><p>​根据MSF的操作手册，MSF 具有显著的模式化，主要流程包括创建项目、发现设备获取对主机的访问权限、控制会话、从目标主机收集证据、清除会话、生成报告等。<br>()创建项目:创建渗透测试的项目实例。<br>(2)发现设备:通过扫描发现主机信息。<br>(3)获取对主机的访问权限:利用 EXP 突破主机，获得访问权限。<br>(4) 控制会话:对主机实施控制，建立远程连接的会话。<br>(5)从目标主机收集证据:收集证据，证明安全权限的存在。<br>(6)清除会话:关闭会话连接，并清除会话记录和线索，以防被他人利用造成危害(7)生成报告:形成具有指导性的、规范的技术报告，供被测者参考，以改进系统MSF 操作流程如图 12-6 所示。12.4.3 小节将结合具体实例介绍MSF 的操作方法。</p><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/MSF%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" style="zoom:80%;" /><center>MSF操作流程图</center></blockquote><blockquote><p>基本流程：</p><p>第一步，在侦察的基础上，针对目标的漏洞情况发起漏洞攻击，并根据渗透目标需求选取适当的攻击载荷。</p><p>第二步，受到漏洞的影响，目标系统运行漏洞攻击代码，导致漏洞利用，再运行攻击载荷。</p><p>第三步，攻击载荷回连攻击主机，渗透测试人员提升权限并进行数据的的上传与下载。</p><p>第四步，测试人员还可以进行后渗透攻击手段，在目标系统内扩大渗透成果。</p></blockquote><h1 id="第十三章：渗透测试程序设计"><a href="#第十三章：渗透测试程序设计" class="headerlink" title="第十三章：渗透测试程序设计"></a>第十三章：渗透测试程序设计</h1><h3 id="比较各种主流编程语言，分析其用于渗透测试编程的优缺点"><a href="#比较各种主流编程语言，分析其用于渗透测试编程的优缺点" class="headerlink" title="比较各种主流编程语言，分析其用于渗透测试编程的优缺点"></a>比较各种主流编程语言，分析其用于渗透测试编程的优缺点</h3><blockquote><p>源码- 编译- 目标代码- 执行- 输出</p><p>源程序+输入- 解释器 -输出</p><p>​汇编语言：是一种用于电子计算机、微处理器、微控制器或其他可编程器件的符号语言。汇编语言对应着不同的机器语言指令集，通过编译过程转化成机器指令。相对于机器语言，它更便于记忆和书写，保留了机器语言高速度和高效率的特点，通常用于底层程序优化或硬件操作的场合。</p><ol><li>Python</li></ol><p>Python是渗透测试领域中最常用的编程语言之一，因为它具有简单易学、开源、功能强大、跨平台等优点。Python也有许多第三方库和模块可用于渗透测试，例如Scapy和Nmap等。</p><ol><li>Ruby</li></ol><p>Ruby是一种动态脚本语言，也是渗透测试人员经常使用的一种语言。Ruby具有类似Python的特点，易于学习、跨平台、灵活性高等优点。渗透测试领域中的Metasploit框架就是使用Ruby编写的。</p><ol><li>Java</li></ol><p>Java是一种跨平台的面向对象编程语言，因此具有广泛的应用范围。Java在渗透测试中也有其用途，例如编写Web应用程序、漏洞扫描工具等。Java的缺点是语法相对复杂，学习曲线较陡峭。</p><ol><li>C&#x2F;C++</li></ol><p>C&#x2F;C++是编写操作系统、驱动程序、网络协议栈等方面最常用的编程语言之一，因此在渗透测试中也有其用处。C&#x2F;C++具有运行速度快、效率高等优点，但需要更多的编程经验和技能。</p><p>总的来说，编程语言的选择取决于具体的场景和需求，需要考虑安全性、效率、易用性、可扩展性等多个方面的因素。在渗透测试中，Python和Ruby是最受欢迎的两种语言，但C&#x2F;C++和Java也有其特殊的用途。</p></blockquote><h3 id="简述黑客编程如何入手。"><a href="#简述黑客编程如何入手。" class="headerlink" title="简述黑客编程如何入手。"></a>简述黑客编程如何入手。</h3><blockquote><p>黑客的编程思想是围绕着如何实现非授权访问展开的，其编程思路可以概括为密码破译和漏洞利用两部分。</p><p>密码破译：对于黑客而言，密码分析工具可以分为暴力攻击，基于数学分析的方法和基于物理特性的分析方法三类</p><ol><li>暴力攻击：攻击者对截获到的密文尝试遍历所有可能的密钥，直到获得一种从密文到明文的可理解的转换。</li><li>基于数学分析方法：突破点在于密码算法本身，如果将密码看作从明文空间到密文空间的数学变换，那么可以通过数学分析方法建立铭文密文和密钥的数学方程或统计规律，从而实施攻击。</li><li>基于物理特性分析方法：当攻击者能够接触到密码设备时，便可以基于密码设备的物理特征，如不同的密码运算所消耗的时间和功耗不同来对密码进行攻击，这种方法称为边信道攻击或旁路攻击</li></ol><p>漏洞利用：EXP和Shellcode编程</p><ol><li>EXP可以以一段植入代码的形式出现，用于生成攻击性的网络数据包或者是其他形式的攻击性输入。往往针对漏洞而言。</li><li>Shellcode就是一种payload。在论文那种，作者演示了如何向进程中植入一段用于获得Shell代码，并将这段代码称为Shellcode。</li></ol></blockquote><h3 id="什么是进程劫持-什么是进程注入-比较两者的异同点。"><a href="#什么是进程劫持-什么是进程注入-比较两者的异同点。" class="headerlink" title="什么是进程劫持?什么是进程注入?比较两者的异同点。"></a>什么是进程劫持?什么是进程注入?比较两者的异同点。</h3><blockquote><p>​进程劫持和进程注入是渗透测试中常用的技术手段，它们的基本原理是利用系统进程间通信机制实现对目标进程的控制，但具体实现方式有所不同。</p><p>​进程劫持是指利用已有的进程，将恶意代码注入到进程的地址空间中，从而获得该进程的执行权限和操作权限，达到控制该进程的目的。进程劫持通常分为静态劫持和动态劫持两种方式。</p><p>​进程注入是指创建一个新的进程，并将恶意代码注入到新进程的地址空间中，使其执行恶意操作。进程注入通常分为远程注入和本地注入两种方式。</p><p>​两者的区别在于，进程劫持利用已有的进程执行恶意代码，而进程注入则是创建新的进程执行恶意代码。进程劫持的优势在于不需要创建新的进程，不会被杀毒软件拦截，但需要找到可以被劫持的进程，进程注入的优势在于可以在受害者不知情的情况下执行恶意代码，并且可以通过更改进程的执行路径绕过杀毒软件的检测。</p></blockquote><h3 id="结合函数调用过程，解释-EIP、ESP寄存器在进程注入过程中的作用"><a href="#结合函数调用过程，解释-EIP、ESP寄存器在进程注入过程中的作用" class="headerlink" title="结合函数调用过程，解释 EIP、ESP寄存器在进程注入过程中的作用"></a>结合函数调用过程，解释 EIP、ESP寄存器在进程注入过程中的作用</h3><blockquote><p>​在程序运行时，函数调用过程会将函数的返回地址存储在栈中。当函数执行完成后，程序会从栈中弹出返回地址，将程序流程返回到调用函数的位置。<strong>EIP寄存器</strong>则是记录当前代码执行的地址，它指向下一条将要执行的指令。</p><p>​在进程注入攻击中，攻击者通过向缓冲区中注入恶意代码，使得在程序执行到缓冲区的代码时，覆盖了栈中的返回地址，将其修改为攻击者构造的地址。当程序执行完缓冲区中的代码后，会弹出被篡改过的返回地址，将程序流程跳转到攻击者构造的地址处执行。此时，攻击者就可以控制程序的执行流程，执行任意的恶意代码。</p><p>​<strong>ESP寄存器</strong>则是记录当前栈顶的地址。在进程注入攻击中，攻击者通过向栈中注入恶意代码，需要考虑栈顶的位置。攻击者需要将恶意代码写入缓冲区，并将栈顶指针指向缓冲区中恶意代码的起始位置。这样，当程序从缓冲区中执行代码时，可以顺利地执行攻击者的恶意代码。</p></blockquote><h3 id="简述渗透测试程序在内存对抗方面采取的主要方法有哪些"><a href="#简述渗透测试程序在内存对抗方面采取的主要方法有哪些" class="headerlink" title="简述渗透测试程序在内存对抗方面采取的主要方法有哪些?"></a>简述渗透测试程序在内存对抗方面采取的主要方法有哪些?</h3><blockquote><p>缓冲区溢出保护策略</p><p>内存保护技术</p><p>内存攻击与防护博弈</p></blockquote><h3 id="什么是Shellcode-叙述-Shellcode-简单功能实现的过程"><a href="#什么是Shellcode-叙述-Shellcode-简单功能实现的过程" class="headerlink" title="什么是Shellcode? 叙述 Shellcode 简单功能实现的过程"></a>什么是Shellcode? 叙述 Shellcode 简单功能实现的过程</h3><blockquote><p>Shellcode是一段代码或填充数据（用来发送到服务器，并利用特定的漏洞诱发执行攻击代码），一般可以获取管理权限。</p></blockquote><blockquote><p>简单实现：</p><ul><li>直接编写十六进制操作码</li><li>采用C或者是Delphi这种高级语言编写程序，编译后，对其反汇编进而获得十六进制操作码</li><li>编写汇编程序，然后从二进制中提取十六进制操作码</li></ul><p>Shellcode 是高级程序设计语言的机器码形式，可以利用IDE 工具和调试功能将编译后的这段代码定位并抠出，这就是 Shellcode 的简单实现过程。下面在 Windows XP 平台上，以VC++6.0为编译工具,实现一段弹出窗口的 Shellcode 程序(由于 Win7 系统引入了 ASLR机制，因此本例不能在 Shellcode 中使用固定的内存地址，但是可以采用13.2.2小节介绍的方法进行对抗)。</p></blockquote><p>1.首先使用高级语言将 Shellcode 想要实现的功能进行设计，编写程序如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv l)</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>，<span class="literal">NULL</span>，<span class="literal">NULL</span>，<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述程序实现了弹出一个对话框的功能(这里仅作为演示，实际可以编写程序实现更复杂的功能，如关闭进程、打开网络端口、外连远程服务器等)。</span></span><br></pre></td></tr></table></figure><p>2.函数寻址</p><p>3.内联汇编改写</p><p>4.抠取Shellcode代码</p><p>5.Shellcode调用</p><h3 id="实现-Shellcode的通用化有哪些方法"><a href="#实现-Shellcode的通用化有哪些方法" class="headerlink" title="实现 Shellcode的通用化有哪些方法?"></a>实现 Shellcode的通用化有哪些方法?</h3><blockquote><p>通用化，就是通过代码的修改使Shellcode具有通用的特性，从而能够在大多数目标系统中运行。</p><p>1.自动定位Shellcode 起点</p><p>2.自动定位API</p><p>3.Shellcode精简</p></blockquote><h3 id="什么是免杀-简述常用免杀方法的原理与过程"><a href="#什么是免杀-简述常用免杀方法的原理与过程" class="headerlink" title="什么是免杀?简述常用免杀方法的原理与过程"></a>什么是免杀?简述常用免杀方法的原理与过程</h3><blockquote><p>​免杀（Evasion）指的是针对安全产品和安全技术的检测机制，通过修改、隐藏或混淆攻击载荷（payload）的方式来规避检测，从而使攻击载荷成功绕过安全防御机制，达到攻击目标的目的。大多数杀毒软件会对恶意软件进行识别，例如，使用特征码来识别恶意代码。这些特征码装载在杀毒引擎中，用来对磁盘和进程进行扫描，并寻找匹配对象。</p><p>​为了避开杀毒软件，攻击者可以针对受到杀毒软件保护的目标创建一个独一无二的攻击载荷，它不会与杀毒软件的任何特征码匹配。此外，当进行渗透攻击时，攻击载荷可以仅仅在内存中运行，不将任何数据写入到硬盘上，这样发起攻击并上传攻击载荷后大多数杀毒软件都无法检测出它已在目标系统上运行。所以，Shellcode 的编写需要采用免杀的方法进行预先处理。</p><p>​手动免杀:手动免杀是由程序员手工修改 Shellcode 代码来完成的，可以采用的方法包括特征码免杀、花指令免杀、加壳免杀等。</p><p>1.特征码免杀<br>Shellcode 被查杀，很有可能是存在杀毒软件所备注的恶意软件特征码。杀毒软件在对文件进行查杀的时候，会挑选文件内部的一句或者几句代码来作为识别病毒的方式，这种代码被称为病毒的特征码。如果将这个代码变更或者修改，就会使得杀毒软件无法对其查杀，这就是特征码免杀的原理。</p><p>2.花指令免杀</p><p>​花指令是源于汇编语言的一种技术，使用汇编语言的程序员为了避免他人窃取自己的思想或者保护软件中的小秘密，于是采用了一些干扰指令来对自己的程序进行类似加密的操作，后来被广泛采用。命名为“花指令”的意思就是如同花朵一样的指令，用它来吸引别人的注意力，而将真正的“果实”隐藏在后面。简而言之，花指令就是一段本身可以不存在的指令，对于程序的执行没有实质的影响，它存在的唯一目的就是掩盖程序中的细节。</p><p>3.加壳免杀</p><p>​加壳与特征码和花指令不同，它是通过编码的方式对 Shellcode 进行整体变形，也称为编码技术。Shellcode 的加壳技术源自病毒的加壳。病毒加壳躲避杀毒软件的查杀过程是首先对自身编码，若直接查看病毒文件的代码段会发现只有几条用于解码的指令，其余都是无效指令:当装入 PE 开始运行时，解码器将真正的代码指令还原出来并运行，实施破坏活动:杀毒软件将一种特征记录之后，病毒开发者只需要使用新的编码算法(密钥)重新对PE文件编码，即可躲过查杀。</p></blockquote><h3 id="解释什么是单一特征码和复合特征码。"><a href="#解释什么是单一特征码和复合特征码。" class="headerlink" title="解释什么是单一特征码和复合特征码。"></a>解释什么是单一特征码和复合特征码。</h3><blockquote><p>特征码按照识别的目标可以分为文件特征码和内存特征码;按照分布的数量可以分为单一文件特征码和复合文件特征码。</p><p>​文件特征码就是静态存储在程序代码中、被杀毒软件作为识别依据的代码。内存特征码是程序运行以后，以系统内存中的运行程序代码存在的、被杀毒软件作为识别依据的代码。</p><p>​单一特征码是一个程序中独立的一段代码，被杀毒软件作为识别标志(修改以后就可实现免杀)。复合特征码是一个程序中的多句代码，被杀毒软件作为识别标志(有一处不修改都不能免杀)。</p></blockquote><h3 id="简述特征码定位的原理"><a href="#简述特征码定位的原理" class="headerlink" title="简述特征码定位的原理"></a>简述特征码定位的原理</h3><blockquote><p>特征码定位。文件特征码定位的原理是先对免杀处理的文件进行分割，自动生成若干个文件(可以采用依次二分)，然后把这些文件中的部分代码过滤掉(用全 0 或全 1)，用杀毒软件查杀后观察查杀结果。</p><p>显然，存在两种情况，即被杀和不被杀。如果文件没有被杀掉，说明该生成文件中的特征代码已经被过滤掉了。也就是说，特征码就在过滤的部分导致现在的文件没有被杀。如果文件被杀掉，说明文件里面的特征码没有被破坏，因此被过滤部分没有完整的特征码。通过不断重复这种方法，即分块过滤、生成文件、杀毒、挑选免杀的文件特征码，逐步进行精确定位。</p></blockquote><h3 id="特征码有哪些修改方法"><a href="#特征码有哪些修改方法" class="headerlink" title="特征码有哪些修改方法?"></a>特征码有哪些修改方法?</h3><blockquote><p>​方法一:修改特征码的十六进制。<br>​修改方法:把特征码对应的十六进制改成数字加1或者减1。适用范围:一定要精确定位特征码对应的十六进制，修改后一定要测试文件能否正常使用。</p><p>​方法二，大小写替换。</p><p>​修改方法：转每码对应的内容是字符串的，大小写互换。适用范围，特征码对应的内容必须是字符中，否则不能成功。</p><p>​方法三，替换法。</p><p>​将特证码对应的汇编指令替换成相同或相似的其他指令。适用范圈，转证码中必须有可以替换的汇编指令(可以从 8080 汇编手册查询替换指令）</p><p>​方法四:顺序调换法。</p><p>​穆改方法:将特征码对应的指令顺序互换一下。适用范围:具有一定的局限性，代码互换后一定不能影响程序的正常执行。</p><p>​方法五:JMP法。<br>​修改方法:把特征码移到零区域，然后用一个JMP 又跳回来执行。适用范围:这是一种通用方法。</p><p>​方法六:移位法。</p><p>​修改方法:把定位到函数的特征码复制到NOP的0区域，然后JMP 回到原来 NOP的下一个地址。适用范围:这是一种通用方法。</p><p>内存查杀与文件查杀一样，因为杀毒软件的内存扫描原理与硬盘上的文件扫描原理是一样的，都是通过特征码比对的，只不过大多数反病毒公司的内存扫描与文件扫描采用的不是同一套特征码，这就导致一个病毒木马同时拥有两套特征码，必须要将它们全部破坏掉才能躲过反病毒软件的查杀。内存特征码的免杀与上述文件特征码的免杀类似。</p></blockquote><h3 id="简述-Shellcode-加壳的编码与解码过程"><a href="#简述-Shellcode-加壳的编码与解码过程" class="headerlink" title="简述 Shellcode 加壳的编码与解码过程"></a>简述 Shellcode 加壳的编码与解码过程</h3><blockquote><p>Shellcode加壳是指将Shellcode放入到一个小型的程序中，来欺骗杀毒软件和防火墙，使其不被检测和拦截。加壳的过程通常分为编码和解码两个阶段。</p><ol><li>编码过程：在编码过程中，需要先将原始的Shellcode进行加密和压缩，以提高安全性和运行效率。加密算法可以使用XOR、AES等对称加密算法，压缩算法可以使用LZ77、LZ78、Huffman编码等压缩算法。加密和压缩后的Shellcode被嵌入到一个小型的程序中，通常是一个精简的PE文件。这个程序会负责解密和解压Shellcode，并将其注入到进程中执行。</li><li>解码过程：在解码过程中，首先需要将加密和压缩后的Shellcode解密和解压缩回原始的Shellcode。解密和解压缩的过程是编码过程的逆过程，需要使用相同的算法和密钥。解密和解压缩后的Shellcode可以直接注入到进程中执行，也可以通过一定的技巧来绕过杀毒软件和防火墙的检测。</li></ol></blockquote><h3 id="简述基于MSF的渗透程序的二次开发过程"><a href="#简述基于MSF的渗透程序的二次开发过程" class="headerlink" title="简述基于MSF的渗透程序的二次开发过程"></a>简述基于MSF的渗透程序的二次开发过程</h3><blockquote><p>MSF的开发不是对其所有文件内容进行修改、替换，而主要是对MSF的模块、插件部分进行开发。</p><p><strong>创建新模块</strong></p><p>​在Metasploit中增加新创建的模块时，最快捷的方法是仿照现有的模块方式、使用MSF中提供的协议(例如，MSF中提供的socket 方法要比ruby中的socket 方法使用起来更加方便，meterpreter 不但实现了对 socket 进行的封装和扩展功能，而且增加了代理、SSH等特征，对于渗透应用的实现具有更好的支持)。模块写好后放在相应的目录，重新启动 consolc即可看到自己增加的模块部分。</p><p><strong>修改现有模块</strong></p><p>​MSF 开发时，还可以直接对现有模块进行修改、增删。依据文件名和相关描述，对于开放源码的exploit、payload 等模块，直接找到相应的文件进行编辑修改并保存，重新启动console 即可看到自己修改后的模块的效果。</p><p><strong>移植</strong></p><p>​MSF还支持用多种语言编写的模块移植入MSF，移植方法在13.4.3小节介绍。<br>​Windows或Linux 均提供上述类似方法，可以进行二次开发。<br>​MSF 二次开发环境为渗透测试个性化、漏洞研究和 Shellcode 编写提供了一个可靠的平台，将其作为开发基础配合已有工具进行渗透测试，就好比让普通测试者“站在巨人的肩膀上”，大大降低了 EXP 的开发周期和对开发者背景知识的要求，成为新的、广受欢迎的测试工作模式。</p></blockquote><h3 id="分析MSF模板框架结构"><a href="#分析MSF模板框架结构" class="headerlink" title="分析MSF模板框架结构"></a>分析MSF模板框架结构</h3><blockquote><p>Metasploit框架是一个用于渗透测试的开源工具集，它提供了一系列的漏洞利用、扫描和负载等模块，可用于攻击测试中对目标系统进行漏洞利用测试。MSF框架由一系列的组件和模块组成，下面对其主要组件进行分析。</p><ol><li>模块：Metasploit框架中的基本单元是模块。模块提供了执行特定任务的功能，比如利用漏洞、扫描网络、执行命令等。每个模块都是独立的，它们可以组合在一起以实现复杂的任务。</li><li>负载：负载是由攻击者控制的恶意代码，可以用于在目标系统上执行操作。Metasploit框架提供了多种负载类型，包括反向Shell、Meterpreter、VNC和Windows管理工具等。</li><li>执行器：执行器是负责执行模块和负载的组件。它们负责加载模块、执行代码并返回结果。</li><li>收集器：收集器用于收集目标系统上的信息。收集器通常是模块的一部分，用于在目标系统上执行命令并返回结果。</li><li>反射器：反射器是Metasploit框架中的核心组件之一，它用于维护与目标系统之间的通信。反射器负责处理网络数据包和负载，并将它们发送到正确的模块和执行器。</li><li>数据库：Metasploit框架可以将扫描和渗透测试结果保存到数据库中。这些数据可以用于生成报告和跟踪进度。</li><li>插件：Metasploit框架还支持插件，这些插件可以扩展框架的功能，添加新的模块和执行器。</li></ol><p>总之，Metasploit框架的模块化设计使其非常灵活和可扩展，可以根据需要进行定制和配置。同时，它也为渗透测试提供了一个统一的平台，使测试人员能够方便地执行各种任务并收集结果。</p></blockquote><h1 id="第十四章：渗透测试质量控制"><a href="#第十四章：渗透测试质量控制" class="headerlink" title="第十四章：渗透测试质量控制"></a>第十四章：渗透测试质量控制</h1><h3 id="简述渗透测试的常用标准"><a href="#简述渗透测试的常用标准" class="headerlink" title="简述渗透测试的常用标准"></a>简述渗透测试的常用标准</h3><blockquote><ol><li>PTES（Penetration Testing Execution Standard）：PTES是一份综合性的渗透测试标准，它包括7个主要阶段，分别是前期准备、情报收集、漏洞扫描、漏洞利用、提权、持久性和清理，以及渗透测试报告。</li><li>OSSTMM（Open Source Security Testing Methodology Manual）：OSSTMM是一个开放的安全测试方法，它着重于应用层面的安全测试，包括网络渗透测试、Web应用程序安全测试等。</li><li>ISSAF（Information Systems Security Assessment Framework）：ISSAF是一个详细的渗透测试框架，包括情报收集、漏洞扫描、漏洞利用和后渗透测试等阶段，还提供了工具和技术的参考。</li><li>NIST SP 800-115：NIST SP 800-115是由美国国家标准与技术研究院发布的一个渗透测试指南，包括前期准备、情报收集、漏洞扫描、漏洞利用和报告等阶段。</li><li>SANS Penetration Testing：SANS Penetration Testing是SANS安全机构提供的一份渗透测试指南，它包括前期准备、情报收集、漏洞扫描、漏洞利用和报告等阶段。</li></ol></blockquote><h3 id="简述渗透测试的风险控制"><a href="#简述渗透测试的风险控制" class="headerlink" title="简述渗透测试的风险控制"></a>简述渗透测试的风险控制</h3><blockquote><p>1.合法性授权：在进行渗透测试前，一定要经过合法性授权，以避免因未经授权的渗透测试引发法律纠纷。</p><p>2.明确测试范围：在进行渗透测试前，要明确测试的范围和目标，避免误操作导致的不必要损失。</p><p>3.备份数据：在进行渗透测试前，要备份目标系统中的数据，以避免测试过程中误操作导致的数据丢失。</p><p>4.定期报告：在进行渗透测试过程中，要及时汇报测试进展情况，定期向上级领导和客户提交测试报告。</p><p>5.保密性：在进行渗透测试时，要注意保密测试过程中涉及到的信息，避免信息泄露引发安全问题。</p><p>6.测试结束后，要对测试过程中发现的漏洞和安全隐患及时告知客户，并提供解决方案和建议，帮助客户改进安全防护措施。</p></blockquote><h3 id="如何评价渗透测试工具"><a href="#如何评价渗透测试工具" class="headerlink" title="如何评价渗透测试工具?"></a>如何评价渗透测试工具?</h3><blockquote><p>1.功能完备性</p><p>2.自动化程度</p><p>3.测试噪声</p></blockquote><h3 id="如何评价渗透测试方案"><a href="#如何评价渗透测试方案" class="headerlink" title="如何评价渗透测试方案?"></a>如何评价渗透测试方案?</h3><blockquote><p>1.沟通的充分性</p><p>2.测试方案的有效性</p><p>3.测试方案的复杂度</p><p>4.测试代价分析</p></blockquote><h3 id="如何实施测试监控确保测试安全"><a href="#如何实施测试监控确保测试安全" class="headerlink" title="如何实施测试监控确保测试安全?"></a>如何实施测试监控确保测试安全?</h3><blockquote><p>在工程实施过程中，确定不同阶段的测试人员以及客户方的配合人员，建立直接沟通的渠道，并在工程出现难题的过程中保持合理沟通。</p><p>​I)系统监测</p><p>​在评估过程中，由于渗透测试的特殊性，用户可以要求对整体测试流匿进行警控(这可能提高渗透测试的成本)。测试方法可以是测试方自控、用户监测两种方法，或兼而有之</p><p>​2)测试方自控</p><p>​由测试者对本次渗透测试过程中以下三方面数据进行完整记录，最终形成完整有序的渔透测试检测报告提交给用户。<br>​(1)操作:包括测试方实施的主要操作行为、时间、对象、范围等;<br>​(2)响应:包括测试方发起操作后，收集到被测方的响应现象、状态、现场参数等:<br>​(3)分析:对操作与响应进行因果、相关性分析，给出推论。</p><p>​3)用户监控</p><p>​用户监控可以有以下三种形式。<br>​(1) 全程监控:采用类似 Ethereal或 Sniffer Pro 的探软件进行全程抓包嗅探。其优点是全过程都能完整记录;其缺点是数据量太大，不易分析，需要大容量存储设备。</p><p>​(2)择要监控:不对扫描过程进行录制，仅仅在安全工程师分析数据后、准备发起潘透前，才开启类似 Ethereal或 Sniffer Pro 的软件进行嗅探。</p><p>​3)主机监控，仅监控受测主机的存活状态，避免意外情况发生。目前国内应用比较多的就是这种监控形式。</p><p>在测试过程中，一旦发现违规、越权行为，应立即终止测试，确保系统安全。</p></blockquote><h3 id="测试方法有哪些-如何实施交叉渗透测试"><a href="#测试方法有哪些-如何实施交叉渗透测试" class="headerlink" title="测试方法有哪些?如何实施交叉渗透测试?"></a>测试方法有哪些?如何实施交叉渗透测试?</h3><blockquote><p>1.盲测</p><p>​在盲测过程中，测试人员不需要知道任何关于目标系统的前置知识，但是在开始执行一个审计范围(adit scope)之前，必须先通知被测试目标的(管理员或所有者)。如伦理黑客行为(ethical hacking)入侵游戏(war game)都可以归为盲测类型。这种测试类型被广泛接受因为它会在道德前提下，将所发生的一切告知被测试目标。</p><p>2.双盲测试</p><p>​在双盲测试中，审计人员不需要知道任何关于目标系统的前置知识，同时被测试目标(管理员或所有者)也不会在测试开始前得到通知。黑盒测试和渗透测试都可以归为这一类当前绝大多数的安全审计采用双盲测试方法，对审计人员来说，每一个审计任务都是一巧实实在在的挑战，为了达到目标，必须选用最好的工具和最佳的技术。</p><p>3.灰盒测试</p><p>​在灰盒测试中，审计人员需要对被测试系统具有一定的了解，而测试开始前也会通知被测试目标。漏洞评估是灰盒测试的一个例子。</p><p>4.双灰盒测试</p><p>​双灰盒测试的过程和灰盒测试类似，只不过在双灰盒测试中，会给审计人员定义一个时限，并且不会测试任何通道和向量。白盒测试是双灰盒测试的一个例子。</p><p>5.串联测试</p><p>​在串联测试中，审计人员对目标系统只有最低限度的了解，且在测试开始前会详细通知被测试系统的管理员或者所有者。需要注意的是，串联测试会做得非常彻底。水晶盒(crystal box)测试和内部审计(in-house audit)都属于串联测试。</p><p>6.反向测试</p><p>​在反向测试中，审计人员拥有关于目标系统的所有知识，且在测试开始前被测试目标(管理员或所有者)不会得到任何通知。红队测试red-teaming)就是反向测试的一个例子。在实践中使用 OSSTMM 方法论，可以大幅降低漏报和误报，并提供更为精确的安全度量;OSSTMM 框架可以被许多不同类型的安全测试所使用，例如渗透测试、白盒审计漏洞评估等。它确保了每一次安全评估都具有彻底性，并且最终结果可以以一种一致的、可以量化的、稳定的方式进行聚合。</p><p>​基于上述方法，在渗透测试的实施过程中，渗透测试还可以采用交叉测试的方法。所谓交叉测试，是指在测试的某一阶段，测试人员相互交换测试的模块，这样不但可以使不同的测试人员保持测试的新鲜感，还可以进一步发掘测试的未知领域，发现交叉测试的模块和之前测试的模块间的联系，甚至可以构建更多的测试场景，帮助提高渗透测试质量。</p></blockquote><h3 id="简述测试报告的典型结构。"><a href="#简述测试报告的典型结构。" class="headerlink" title="简述测试报告的典型结构。"></a>简述测试报告的典型结构。</h3><blockquote><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg" style="zoom:50%;" /><center>渗透测试报告的框架结构</center><ol><li>概述：对测试执行情况进行简要概述，包括测试的范围、目的、方法和执行时间等基本信息。</li><li>测试计划：描述测试执行的详细计划，包括测试用例、测试数据、测试环境、测试人员等信息。</li><li>测试执行：详细记录测试执行的过程和结果，包括测试步骤、测试数据、测试结果、缺陷信息等内容。</li><li>缺陷汇总：列出所有发现的缺陷信息，包括缺陷的类型、严重程度、发现时间、状态、责任人等信息。</li><li>测试总结：对整个测试过程进行总结，包括测试执行情况、发现的问题、测试结果分析、风险评估等内容。</li><li>建议和改进：提出测试过程中发现的问题、改进方案和建议，以帮助提高测试质量和效率。</li><li>附录：包括测试用例、测试数据、测试日志、缺陷报告等补充性信息。</li></ol></blockquote><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><h2 id="测试人员能力素养"><a href="#测试人员能力素养" class="headerlink" title="测试人员能力素养"></a>测试人员能力素养</h2><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E8%83%BD%E5%8A%9B%E7%AD%89%E7%BA%A7%E8%A1%A81.jpg" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E8%83%BD%E5%8A%9B%E7%AD%89%E7%BA%A7%E8%A1%A82.jpg" style="zoom:40%;" /><img src="https://raw.githubusercontent.com/GiyaYon/mypicGo/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E8%80%83%E8%AF%95%E8%AE%A4%E8%AF%81.jpg" style="zoom:33%;" /><h2 id="后文-1"><a href="#后文-1" class="headerlink" title="后文"></a>后文</h2><p>Github:  GiyaYon</p><p>完成时间：2023&#x2F;3&#x2F;18</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本书是《网络安全渗透测试》王晓东 西安电子科技大学出版社.&lt;/p&gt;
&lt;p&gt;在信息安全领域中，渗透测试是公认度非常高的新型安全测试方法。从其机</summary>
      
    
    
    
    <category term="网络工程" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="网络安全" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="渗透测试" scheme="http://giyayonlib.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="网络安全" scheme="http://giyayonlib.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="网络" scheme="http://giyayonlib.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://giyayonlib.com/2023/02/22/hello-world/"/>
    <id>http://giyayonlib.com/2023/02/22/hello-world/</id>
    <published>2023-02-22T05:12:47.574Z</published>
    <updated>2023-02-22T05:12:47.574Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
